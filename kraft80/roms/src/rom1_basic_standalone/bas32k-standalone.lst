ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 1.
Hexadecimal [24-Bits]



                                      1 ;--------------------------------------------------------------------------
                                      2 ;  crt0.s - Generic crt0.s for a Z80
                                      3 ;
                                      4 ;  Copyright (C) 2000, Michael Hope
                                      5 ;
                                      6 ;  This library is free software; you can redistribute it and/or modify it
                                      7 ;  under the terms of the GNU General Public License as published by the
                                      8 ;  Free Software Foundation; either version 2, or (at your option) any
                                      9 ;  later version.
                                     10 ;
                                     11 ;  This library is distributed in the hope that it will be useful,
                                     12 ;  but WITHOUT ANY WARRANTY; without even the implied warranty of
                                     13 ;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
                                     14 ;  GNU General Public License for more details.
                                     15 ;
                                     16 ;  You should have received a copy of the GNU General Public License 
                                     17 ;  along with this library; see the file COPYING. If not, write to the
                                     18 ;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
                                     19 ;   MA 02110-1301, USA.
                                     20 ;
                                     21 ;  As a special exception, if you link this library with other files,
                                     22 ;  some of which are compiled with SDCC, to produce an executable,
                                     23 ;  this library does not by itself cause the resulting executable to
                                     24 ;  be covered by the GNU General Public License. This exception does
                                     25 ;  not however invalidate any other reasons why the executable file
                                     26 ;  might be covered by the GNU General Public License.
                                     27 ;--------------------------------------------------------------------------
                                     28 
                                     29 ;;;-----------------------------------------------------------------------
                                     30 ;;; BOOT CODE
                                     31 ;;; INTERRUPT HANDLERS & VECTORS
                                     32 ;;; HARDWARE DRIVERS FOR THE TANG NANO HARDWARE:
                                     33 ;;;    SERIAL & TIMER (NO ROM LEFT TO DRIVE THE VIDEO AND PS2 KBD!)
                                     34 ;;;    BY ARMCODER - 2025
                                     35 ;;;-----------------------------------------------------------------------
                                     36 
                           002200    37 RAMTOP		.equ 0x2200
                           002100    38 STACKTOP	.equ RAMTOP - 0x100
                           002100    39 isr0vector	.equ STACKTOP
                           002102    40 isr1vector	.equ STACKTOP+2
                           002104    41 isr2vector	.equ STACKTOP+4
                           002106    42 isr3vector	.equ STACKTOP+6
                           002108    43 isr4vector	.equ STACKTOP+8
                           00210A    44 isr5vector	.equ STACKTOP+10
                           00210C    45 isr6vector	.equ STACKTOP+12
                           00210E    46 isr7vector	.equ STACKTOP+14
                           000080    47 BUFRXSIZE	.equ 0x80
                           002110    48 bufrx		.equ STACKTOP+16
                           002190    49 bufrxins	.equ bufrx+BUFRXSIZE
                           002191    50 bufrxget	.equ bufrxins+1
                           002192    51 bufrxqty	.equ bufrxget+1
                                     52 
                           0021FE    53 timecount	.equ RAMTOP-2
                                     54 
                           000000    55 PORTLEDS	.equ 0x00
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 2.
Hexadecimal [24-Bits]



                                     56 
                                     57 
                                     58 ; FPGA addr mapping (base 0x50)
                                     59 ; 0000: Video RAM Data (R/W)
                                     60 ; 0001: Video ADDR Low (W)
                                     61 ; 0010: Video ADDR High (W)
                                     62 ; 0011: Video control (W)
                                     63 ; 0100: Timer Status & Control(R/W)
                                     64 ; 0101: PS/2 RX Data (R)
                                     65 ; 0110: Sound REG Index (W)
                                     66 ; 0111: Sound REG Data (W)
                                     67 ; 1000: Serial Status & Control (R/W)
                                     68 ; 1001: Serial Data RX/TX (R/W)
                                     69 ; 1010
                                     70 ; 1011
                                     71 ; 1100
                                     72 ; 1101
                                     73 ; 1110
                                     74 ; 1111: Status Reg (R)
                                     75 
                                     76 ; FPGA
                                     77 ;   VIDEO
                           000050    78 PORTDATA	.equ	0x50	; Video ports
                           000051    79 PORTADDRL	.equ	0x51
                           000052    80 PORTADDRH	.equ	0x52
                           000053    81 PORTMODE	.equ	0x53
                                     82 
                                     83 ; TIMER STATUS/CONTROL
                           000054    84 PORTTIMER	.equ	0x54
                                     85 
                                     86 ;   PS2 KEYBOARD
                           000055    87 PORTKEY		.equ	0x55
                                     88 
                                     89 ; AUDIO
                           000056    90 PORTAYADDR	.equ	0x56
                           000057    91 PORTAYDATA	.equ	0x57
                                     92 
                                     93 ; SERIAL
                           000058    94 PORTSERSTATUS	.equ	0x58
                           000058    95 PORTSERCTL	.equ	0x58
                           000002    96 	PORTSER_EN	.equ	2
                           000001    97 	PORTSER_RTSON	.equ	1
                           000000    98 	PORTSER_DIS	.equ	0
                           000000    99 	PORTSER_RTSOFF	.equ	0
                                    100 
                           000059   101 PORTSERDATA	.equ	0x59
                                    102 
                                    103 ;   FPGA STATUS
                           00005F   104 PORTFPGASTATUS	.equ	0x5F
                                    105 
                                    106 	.module crt0
                                    107 
                                    108 	.area	_HEADER (ABS)
                                    109 	;; Reset vector
      000000                        110 	.org 	0
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 3.
Hexadecimal [24-Bits]



      000000 C3 00 01         [10]  111 	jp	init
                                    112 
      000008                        113 	.org	0x08
      000008 C3 6B 01         [10]  114 	jp	tx_char	;reti
                                    115 	
      000010                        116 	.org	0x10
      000010 C3 79 01         [10]  117 	jp	rx_char ;reti
                                    118 	
      000018                        119 	.org	0x18
      000018 C3 74 01         [10]  120 	jp	has_rxchar ;reti
                                    121 
      000020                        122 	.org	0x20
      000020 ED 4D            [14]  123 	reti
      000028                        124 	.org	0x28
      000028 ED 4D            [14]  125 	reti
      000030                        126 	.org	0x30
      000030 ED 4D            [14]  127 	reti
                                    128 
                                    129 	;///////////////////////////////////////////////////////////////////////
                                    130 	;//////////////////////////   ISR DISPATCH   ///////////////////////////
                                    131 	;///////////////////////////////////////////////////////////////////////
      000038                        132 	.org	0x38
                                    133 
      000038 F5               [11]  134 fpga_isr:	push	af
      000039 E5               [11]  135 		push	hl
                                    136 
      00003A DB 5F            [11]  137 fpga_isrloop:	in	a,(PORTFPGASTATUS)
      00003C E6 07            [ 7]  138 		and	#0x07
      00003E 28 2A            [12]  139 		jr	z,fpga_isrend
                                    140 
      000040 CB 47            [ 8]  141 		bit	0,a			; Has PS/2 interrupt?
      000042 28 08            [12]  142 		jr	z,fpga_isr1		; No
                                    143 
      000044 21 4C 00         [10]  144 		ld	hl,#fpga_isr1
      000047 E5               [11]  145 		push	hl
      000048 2A 02 21         [16]  146 		ld	hl,(isr1vector)
      00004B E9               [ 4]  147 		jp	(hl)
                                    148 
      00004C DB 5F            [11]  149 fpga_isr1:	in	a,(PORTFPGASTATUS)	; Has timer interrupt?
      00004E CB 4F            [ 8]  150 		bit	1,a			; No
      000050 28 0A            [12]  151 		jr	z,fpga_isr2
                                    152 
      000052 DB 54            [11]  153 		in	a,(PORTTIMER)		; Timer EOI
      000054 21 5C 00         [10]  154 		ld	hl,#fpga_isr2
      000057 E5               [11]  155 		push	hl
      000058 2A 04 21         [16]  156 		ld	hl,(isr2vector)
      00005B E9               [ 4]  157 		jp	(hl)
                                    158 
      00005C DB 5F            [11]  159 fpga_isr2:	in	a,(PORTFPGASTATUS)	; Has Serial RX interrupt?
      00005E CB 57            [ 8]  160 		bit	2,a			; No
      000060 28 D8            [12]  161 		jr	z,fpga_isrloop
                                    162 
                                    163 	;;;;	in	a,(PORTSERDATA)
      000062 21 3A 00         [10]  164 		ld	hl,#fpga_isrloop
      000065 E5               [11]  165 		push	hl
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 4.
Hexadecimal [24-Bits]



      000066 2A 00 21         [16]  166 		ld	hl,(isr0vector)
      000069 E9               [ 4]  167 		jp	(hl)
                                    168 
      00006A E1               [10]  169 fpga_isrend:	pop	hl
      00006B F1               [10]  170 		pop	af
      00006C FB               [ 4]  171 		ei
      00006D ED 4D            [14]  172 		reti
                                    173 
                                    174 	;///////////////////////////////////////////////////////////////////////
                                    175 
                                    176 
      00006F                        177 timer_isr:
      00006F 3A FE 21         [13]  178 		ld	a,(timecount)
      000072 3C               [ 4]  179 		inc	a
      000073 32 FE 21         [13]  180 		ld	(timecount),a
                                    181 		;out	(PORTLEDS),a
      000076 C9               [10]  182 		ret
                                    183 
                                    184 
      000077                        185 ps2_isr:
      000077 DB 55            [11]  186 		in	a,(PORTKEY)
      000079 C9               [10]  187 		ret
                                    188 
      00007A 3A 92 21         [13]  189 rx_isr:		ld	a,(bufrxqty)
      00007D FE 80            [ 7]  190 		cp	#BUFRXSIZE
      00007F 20 03            [12]  191 		jr	nz,rx_isr1
      000081 DB 59            [11]  192 		in	a,(PORTSERDATA)
      000083 C9               [10]  193 		ret
                                    194 	
      000084 3C               [ 4]  195 rx_isr1:	inc	a
      000085 FE 70            [ 7]  196 		cp	#(BUFRXSIZE-16)
      000087 20 06            [12]  197 		jr	nz,rx_isr1a
                                    198 	
      000089 F5               [11]  199 		push	af
      00008A 3E 02            [ 7]  200 		ld	a,#(PORTSER_EN|PORTSER_RTSOFF)
      00008C D3 58            [11]  201 		out	(PORTSERCTL),a
      00008E F1               [10]  202 		pop	af
                                    203 
      00008F 32 92 21         [13]  204 rx_isr1a:	ld	(bufrxqty),a
      000092 3A 90 21         [13]  205 		ld	a,(bufrxins)
      000095 C5               [11]  206 		push	bc
      000096 4F               [ 4]  207 		ld	c,a
      000097 06 00            [ 7]  208 		ld	b,#0
      000099 E5               [11]  209 		push	hl
      00009A 21 10 21         [10]  210 		ld	hl,#bufrx
      00009D 09               [11]  211 		add	hl,bc
      00009E DB 59            [11]  212 		in	a,(PORTSERDATA)
      0000A0 77               [ 7]  213 		ld	(hl),a
      0000A1 E1               [10]  214 		pop	hl
      0000A2 79               [ 4]  215 		ld	a,c
      0000A3 C1               [10]  216 		pop	bc
                                    217 
      0000A4 3C               [ 4]  218 		inc	a
      0000A5 FE 80            [ 7]  219 		cp	#BUFRXSIZE
      0000A7 38 01            [12]  220 		jr	c,rx_isr2
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 5.
Hexadecimal [24-Bits]



      0000A9 AF               [ 4]  221 		xor	a
                                    222 
      0000AA 32 90 21         [13]  223 rx_isr2:	ld	(bufrxins),a
                                    224 
      0000AD C9               [10]  225 		ret
                                    226 
                                    227 	;///////////////////////////////////////////////////////////////////////
                                    228 	;////////////////////////   INITIALIZATION   ///////////////////////////
                                    229 	;///////////////////////////////////////////////////////////////////////
                                    230 
      000100                        231 .org	0x100
      000100                        232 init:
                                    233 	;; Stack at the top of memory.
      000100 31 00 21         [10]  234 	ld	sp,#STACKTOP
                                    235 
      000103 21 7A 00         [10]  236 	ld	hl,#rx_isr
      000106 22 00 21         [16]  237 	ld	(isr0vector),hl
      000109 21 77 00         [10]  238 	ld	hl,#ps2_isr
      00010C 22 02 21         [16]  239 	ld	(isr1vector),hl
      00010F 21 6F 00         [10]  240 	ld	hl,#timer_isr
      000112 22 04 21         [16]  241 	ld	(isr2vector),hl
                                    242 
      000115 3E F0            [ 7]  243 	ld	a,#0xf0
      000117 32 FE 21         [13]  244 	ld	(timecount),a
                                    245 
      00011A AF               [ 4]  246 	xor	a
      00011B 32 90 21         [13]  247 	ld	(bufrxins),a
      00011E 32 91 21         [13]  248 	ld	(bufrxget),a
      000121 32 92 21         [13]  249 	ld	(bufrxqty),a
                                    250 
                                    251 	;; Initialize FPGA: Timer & Serial
      000124 3E 01            [ 7]  252 	ld	a,#1
      000126 D3 54            [11]  253 	out	(PORTTIMER),a
      000128 3E 03            [ 7]  254 	ld	a,#(PORTSER_EN|PORTSER_RTSON)
      00012A D3 58            [11]  255 	out	(PORTSERCTL),a	; Enable RTS & INT RX
                                    256 
      00012C ED 56            [ 8]  257 	im	1
      00012E FB               [ 4]  258 	ei
                                    259 	
      00012F 21 38 01         [10]  260 	ld	hl,#signon
      000132 CD 62 01         [17]  261 	call	prints
                                    262 	
      000135 C3 00 02         [10]  263 	jp	COLD
                                    264 
      000138                        265 signon:
      000138 0D 0A                  266 	.db	13,10
      00013A 4B 72 61 66 74 20 38   267 	.ascii	'Kraft 80 - Z80 Computer'
             30 20 2D 20 5A 38 30
             20 43 6F 6D 70 75 74
             65 72
      000151 0D 0A                  268 	.db	13,10
      000153 42 49 4F 53 20 52 65   269 	.ascii	'BIOS Rev 1.1'
             76 20 31 2E 31
      00015F 0D 0A 00               270 	.db	13,10,0
                                    271 	
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 6.
Hexadecimal [24-Bits]



                                    272 	;///////////////////////////////////////////////////////////////////////
      000162                        273 prints:
      000162 7E               [ 7]  274 	ld	a,(hl)
      000163 B7               [ 4]  275 	or	a
      000164 C8               [11]  276 	ret	z
      000165 E5               [11]  277 	push	hl
      000166 CF               [11]  278 	rst	#0x08
      000167 E1               [10]  279 	pop	hl
      000168 23               [ 6]  280 	inc	hl
      000169 18 F7            [12]  281 	jr	prints
                                    282 
                                    283 	;///////////////////////////////////////////////////////////////////////
      00016B                        284 tx_char:
                                    285         ;di
      00016B D3 59            [11]  286 	out	(PORTSERDATA),a
      00016D                        287 wait_tx:
      00016D DB 58            [11]  288 	in	a,(PORTSERSTATUS)
      00016F CB 4F            [ 8]  289 	bit	1,a
      000171 20 FA            [12]  290 	jr	nz,wait_tx
                                    291 	;ei
      000173 C9               [10]  292 	ret
                                    293 
                                    294 	;///////////////////////////////////////////////////////////////////////
      000174                        295 has_rxchar:
      000174 3A 92 21         [13]  296 	ld	a,(bufrxqty)
      000177 B7               [ 4]  297 	or	a
                                    298 
      000178                        299 default_isr:
      000178 C9               [10]  300 	ret
                                    301 
                                    302 	;///////////////////////////////////////////////////////////////////////
      000179                        303 rx_char:
      000179 3A 92 21         [13]  304 	ld	a,(bufrxqty)
      00017C B7               [ 4]  305 	or	a
      00017D 20 01            [12]  306 	jr	nz,rx_char0
      00017F C9               [10]  307 	ret		;; No char available, return Z
                                    308 
      000180                        309 rx_char0:
      000180 F3               [ 4]  310 	di
      000181 3A 92 21         [13]  311 	ld	a,(bufrxqty)
      000184 3D               [ 4]  312 	dec	a
      000185 32 92 21         [13]  313 	ld	(bufrxqty),a
      000188 FE 08            [ 7]  314 	cp	#8
      00018A 20 04            [12]  315 	jr	nz,rx_char2
                                    316 
      00018C 3E 03            [ 7]  317 	ld	a,#(PORTSER_EN|PORTSER_RTSON)
      00018E D3 58            [11]  318 	out	(PORTSERCTL),a	; Enable RTS & INT RX
                                    319 
      000190                        320 rx_char2:
      000190 E5               [11]  321 	push	hl
                                    322 
      000191 C5               [11]  323 	push	bc
      000192 3A 91 21         [13]  324 	ld	a,(bufrxget)
      000195 4F               [ 4]  325 	ld	c,a
      000196 06 00            [ 7]  326 	ld	b,#0
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 7.
Hexadecimal [24-Bits]



      000198 21 10 21         [10]  327 	ld	hl,#bufrx
      00019B 09               [11]  328 	add	hl,bc
      00019C C1               [10]  329 	pop	bc
                                    330 
      00019D 3C               [ 4]  331 	inc	a
      00019E FE 80            [ 7]  332 	cp	#BUFRXSIZE
      0001A0 20 03            [12]  333 	jr	nz,rx_char1	;; Condition NZ
                                    334 
      0001A2 AF               [ 4]  335 	xor	a
      0001A3 FE 01            [ 7]  336 	cp	#1		;; Force condition NZ
                                    337 
      0001A5                        338 rx_char1:
      0001A5 32 91 21         [13]  339 	ld	(bufrxget),a
      0001A8 7E               [ 7]  340 	ld	a,(hl)
      0001A9 E1               [10]  341 	pop	hl
      0001AA FB               [ 4]  342 	ei
      0001AB C9               [10]  343 	ret			;; Always return NZ
                                    344 
                                    345 	;///////////////////////////////////////////////////////////////////////
                                    346 
                                    347 
                                    348 ;==================================================================================
                                    349 ; The updates to the original BASIC within this file are copyright Grant Searle
                                    350 ;
                                    351 ; You have permission to use this for NON COMMERCIAL USE ONLY
                                    352 ; If you wish to use it elsewhere, please include an acknowledgement to myself.
                                    353 ;
                                    354 ; http://searle.hostei.com/grant/index.html
                                    355 ;
                                    356 ; eMail: home.micros01@btinternet.com
                                    357 ;
                                    358 ; If the above don't work, please perform an Internet search to see if I have
                                    359 ; updated the web page hosting service.
                                    360 ;
                                    361 ;==================================================================================
                                    362 
                                    363 ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
                                    364 ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
                                    365 ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
                                    366 ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
                                    367 ; the original ROM code (checksum A934H). PA
                                    368 
                                    369 ; GENERAL EQUATES
                                    370 
                           000003   371 CTRLC   .EQU    0x03             ; Control "C"
                           000007   372 CTRLG   .EQU    0x07             ; Control "G"
                           000008   373 BKSP    .EQU    0x08             ; Back space
                           00000A   374 LF      .EQU    0x0A             ; Line feed
                           00000C   375 CS      .EQU    0x0C             ; Clear screen
                           00000D   376 CR      .EQU    0x0D             ; Carriage return
                           00000F   377 CTRLO   .EQU    0x0F             ; Control "O"
                           000011   378 CTRLQ	.EQU	0x11             ; Control "Q"
                           000012   379 CTRLR   .EQU    0x12             ; Control "R"
                           000013   380 CTRLS   .EQU    0x13             ; Control "S"
                           000015   381 CTRLU   .EQU    0x15             ; Control "U"
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 8.
Hexadecimal [24-Bits]



                           00001B   382 ESC     .EQU    0x1B             ; Escape
                           00007F   383 DEL     .EQU    0x7F             ; Delete
                                    384 
                                    385 ; BASIC WORK SPACE LOCATIONS
                                    386 
                           002300   387 WRKSPC  .EQU    RAMTOP + 0x100;0x8045               ; BASIC Work space
                           002303   388 USR     .EQU    WRKSPC+0x03          ; "USR (x)" jump
                           002306   389 OUTSUB  .EQU    WRKSPC+0x06          ; "OUT p,n"
                           002307   390 OTPORT  .EQU    WRKSPC+0x07          ; Port (p)
                           002309   391 DIVSUP  .EQU    WRKSPC+0x09          ; Division support routine
                           00230A   392 DIV1    .EQU    WRKSPC+0x0A          ; <- Values
                           00230E   393 DIV2    .EQU    WRKSPC+0x0E          ; <-   to
                           002312   394 DIV3    .EQU    WRKSPC+0x12          ; <-   be
                           002315   395 DIV4    .EQU    WRKSPC+0x15          ; <-inserted
                           002317   396 SEED    .EQU    WRKSPC+0x17          ; Random number seed
                           00233A   397 LSTRND  .EQU    WRKSPC+0x3A          ; Last random number
                           00233E   398 INPSUB  .EQU    WRKSPC+0x3E          ; #INP (x)" Routine
                           00233F   399 INPORT  .EQU    WRKSPC+0x3F          ; PORT (x)
                           002341   400 NULLS   .EQU    WRKSPC+0x41          ; Number of nulls
                           002342   401 LWIDTH  .EQU    WRKSPC+0x42          ; Terminal width
                           002343   402 COMMAN  .EQU    WRKSPC+0x43          ; Width for commas
                           002344   403 NULFLG  .EQU    WRKSPC+0x44          ; Null after input byte flag
                           002345   404 CTLOFG  .EQU    WRKSPC+0x45          ; Control "O" flag
                           002346   405 LINESC  .EQU    WRKSPC+0x46          ; Lines counter
                           002348   406 LINESN  .EQU    WRKSPC+0x48          ; Lines number
                           00234A   407 CHKSUM  .EQU    WRKSPC+0x4A          ; Array load/save check sum
                           00234C   408 NMIFLG  .EQU    WRKSPC+0x4C          ; Flag for NMI break routine
                           00234D   409 BRKFLG  .EQU    WRKSPC+0x4D          ; Break flag
                           00234E   410 RINPUT  .EQU    WRKSPC+0x4E          ; Input reflection
                           002351   411 POINT   .EQU    WRKSPC+0x51          ; "POINT" reflection (unused)
                           002354   412 PSET    .EQU    WRKSPC+0x54          ; "SET"   reflection
                           002357   413 RESET   .EQU    WRKSPC+0x57          ; "RESET" reflection
                           00235A   414 STRSPC  .EQU    WRKSPC+0x5A          ; Bottom of string space
                           00235C   415 LINEAT  .EQU    WRKSPC+0x5C          ; Current line number
                           00235E   416 BASTXT  .EQU    WRKSPC+0x5E          ; Pointer to start of program
                           002361   417 BUFFER  .EQU    WRKSPC+0x61          ; Input buffer
                           002366   418 STACK   .EQU    WRKSPC+0x66          ; Initial stack
                           0023AB   419 CURPOS  .EQU    WRKSPC+0xAB          ; Character position on line
                           0023AC   420 LCRFLG  .EQU    WRKSPC+0xAC          ; Locate/Create flag
                           0023AD   421 TYPE    .EQU    WRKSPC+0xAD          ; Data type flag
                           0023AE   422 DATFLG  .EQU    WRKSPC+0xAE          ; Literal statement flag
                           0023AF   423 LSTRAM  .EQU    WRKSPC+0xAF          ; Last available RAM
                           0023B1   424 TMSTPT  .EQU    WRKSPC+0xB1          ; Temporary string pointer
                           0023B3   425 TMSTPL  .EQU    WRKSPC+0xB3          ; Temporary string pool
                           0023BF   426 TMPSTR  .EQU    WRKSPC+0xBF          ; Temporary string
                           0023C3   427 STRBOT  .EQU    WRKSPC+0xC3          ; Bottom of string space
                           0023C5   428 CUROPR  .EQU    WRKSPC+0xC5          ; Current operator in EVAL
                           0023C7   429 LOOPST  .EQU    WRKSPC+0xC7          ; First statement of loop
                           0023C9   430 DATLIN  .EQU    WRKSPC+0xC9          ; Line of current DATA item
                           0023CB   431 FORFLG  .EQU    WRKSPC+0xCB          ; "FOR" loop flag
                           0023CC   432 LSTBIN  .EQU    WRKSPC+0xCC          ; Last byte entered
                           0023CD   433 READFG  .EQU    WRKSPC+0xCD          ; Read/Input flag
                           0023CE   434 BRKLIN  .EQU    WRKSPC+0xCE          ; Line of break
                           0023D0   435 NXTOPR  .EQU    WRKSPC+0xD0          ; Next operator in EVAL
                           0023D2   436 ERRLIN  .EQU    WRKSPC+0xD2          ; Line of error
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 9.
Hexadecimal [24-Bits]



                           0023D4   437 CONTAD  .EQU    WRKSPC+0xD4          ; Where to CONTinue
                           0023D6   438 PROGND  .EQU    WRKSPC+0xD6          ; End of program
                           0023D8   439 VAREND  .EQU    WRKSPC+0xD8          ; End of variables
                           0023DA   440 ARREND  .EQU    WRKSPC+0xDA          ; End of arrays
                           0023DC   441 NXTDAT  .EQU    WRKSPC+0xDC          ; Next data item
                           0023DE   442 FNRGNM  .EQU    WRKSPC+0xDE          ; Name of FN argument
                           0023E0   443 FNARG   .EQU    WRKSPC+0xE0          ; FN argument value
                           0023E4   444 FPREG   .EQU    WRKSPC+0xE4          ; Floating point register
                           0023E7   445 FPEXP   .EQU    FPREG+3              ; Floating point exponent
                           0023E8   446 SGNRES  .EQU    WRKSPC+0xE8          ; Sign of result
                           0023E9   447 PBUFF   .EQU    WRKSPC+0xE9          ; Number print buffer
                           0023F6   448 MULVAL  .EQU    WRKSPC+0xF6          ; Multiplier
                           0023F9   449 PROGST  .EQU    WRKSPC+0xF9          ; Start of program text area
                           00245D   450 STLOOK  .EQU    WRKSPC+0x15D         ; Start of memory test
                                    451 
                                    452 ; BASIC ERROR CODE VALUES
                                    453 
                           000000   454 NF      .EQU    0x00             ; NEXT without FOR
                           000002   455 SN      .EQU    0x02             ; Syntax error
                           000004   456 RG      .EQU    0x04             ; RETURN without GOSUB
                           000006   457 OD      .EQU    0x06             ; Out of DATA
                           000008   458 FC      .EQU    0x08             ; Function call error
                           00000A   459 OV      .EQU    0x0A             ; Overflow
                           00000C   460 OM      .EQU    0x0C             ; Out of memory
                           00000E   461 UL      .EQU    0x0E             ; Undefined line number
                           000010   462 BS      .EQU    0x10             ; Bad subscript
                           000012   463 DD      .EQU    0x12             ; Re-DIMensioned array
                           000014   464 DZ      .EQU    0x14             ; Division by zero (/0)
                           000016   465 ID      .EQU    0x16             ; Illegal direct
                           000018   466 TM      .EQU    0x18             ; Type miss-match
                           00001A   467 OS      .EQU    0x1A             ; Out of string space
                           00001C   468 LS      .EQU    0x1C             ; String too long
                           00001E   469 ST      .EQU    0x1E             ; String formula too complex
                           000020   470 CN      .EQU    0x20             ; Can't CONTinue
                           000022   471 UF      .EQU    0x22             ; UnDEFined FN function
                           000024   472 MO      .EQU    0x24             ; Missing operand
                           000026   473 HX      .EQU    0x26             ; HEX error
                           000028   474 BN      .EQU    0x28             ; BIN error
                                    475 
      000200                        476         .ORG    0x0200
                                    477 
      000200 C3 06 02         [10]  478 COLD:   JP      STARTB          ; Jump for cold start
      000203 C3 A4 02         [10]  479 WARM:   JP      WARMST          ; Jump for warm start
      000206                        480 STARTB: 
      000206 DD 21 00 00      [14]  481         LD      IX,#0           ; Flag cold start
      00020A C3 11 02         [10]  482         JP      CSTART          ; Jump to initialise
                                    483 
      00020D A2 0A                  484         .WORD   DEINT           ; Get integer -32768 to 32767
      00020F 18 12                  485         .WORD   ABPASS          ; Return integer in AB
                                    486 
                                    487 
      000211 21 00 23         [10]  488 CSTART: LD      HL,#WRKSPC      ; Start of workspace RAM
      000214 F9               [ 6]  489         LD      SP,HL           ; Set up a temporary stack
      000215 C3 38 1E         [10]  490         JP      INITST          ; Go to initialise
                                    491 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 10.
Hexadecimal [24-Bits]



      000218 11 C9 04         [10]  492 INIT:   LD      DE,#INITAB      ; Initialise workspace
      00021B 06 63            [ 7]  493         LD      B,#INITBE-INITAB+3; Bytes to copy
      00021D 21 00 23         [10]  494         LD      HL,#WRKSPC       ; Into workspace RAM
      000220 1A               [ 7]  495 COPY:   LD      A,(DE)          ; Get source
      000221 77               [ 7]  496         LD      (HL),A          ; To destination
      000222 23               [ 6]  497         INC     HL              ; Next destination
      000223 13               [ 6]  498         INC     DE              ; Next source
      000224 05               [ 4]  499         DEC     B               ; Count bytes
      000225 C2 20 02         [10]  500         JP      NZ,COPY         ; More to move
      000228 F9               [ 6]  501         LD      SP,HL           ; Temporary stack
      000229 CD CA 06         [17]  502         CALL    CLREG           ; Clear registers and stack
      00022C CD 98 0C         [17]  503         CALL    PRNTCRLF        ; Output CRLF
      00022F 32 AA 23         [13]  504         LD      (BUFFER+72+1),A ; Mark end of buffer
      000232 32 F9 23         [13]  505         LD      (PROGST),A      ; Initialise program area
      000235 21 F3 02         [10]  506 MSIZE:  LD      HL,#MEMMSG      ; Point to message
      000238 CD 36 13         [17]  507         CALL    PRS             ; Output "Memory size"
      00023B CD E7 06         [17]  508         CALL    PROMPT          ; Get input with '?'
      00023E CD F0 09         [17]  509         CALL    GETCHR          ; Get next character
      000241 B7               [ 4]  510         OR      A               ; Set flags
      000242 C2 5A 02         [10]  511         JP      NZ,TSTMEM       ; If number - Test if RAM there
      000245 21 5D 24         [10]  512         LD      HL,#STLOOK      ; Point to start of RAM
      000248 23               [ 6]  513 MLOOP:  INC     HL              ; Next byte
      000249 7C               [ 4]  514         LD      A,H             ; Above address FFFF ?
      00024A B5               [ 4]  515         OR      L
      00024B CA 6C 02         [10]  516         JP      Z,SETTOP        ; Yes - 64K RAM
      00024E 7E               [ 7]  517         LD      A,(HL)          ; Get contents
      00024F 47               [ 4]  518         LD      B,A             ; Save it
      000250 2F               [ 4]  519         CPL                     ; Flip all bits
      000251 77               [ 7]  520         LD      (HL),A          ; Put it back
      000252 BE               [ 7]  521         CP      (HL)            ; RAM there if same
      000253 70               [ 7]  522         LD      (HL),B          ; Restore old contents
      000254 CA 48 02         [10]  523         JP      Z,MLOOP         ; If RAM - test next byte
      000257 C3 6C 02         [10]  524         JP      SETTOP          ; Top of RAM found
                                    525 
      00025A CD BC 0A         [17]  526 TSTMEM: CALL    ATOH            ; Get high memory into DE
      00025D B7               [ 4]  527         OR      A               ; Set flags on last byte
      00025E C2 98 05         [10]  528         JP      NZ,SNERR        ; ?SN Error if bad character
      000261 EB               [ 4]  529         EX      DE,HL           ; Address into HL
      000262 2B               [ 6]  530         DEC     HL              ; Back one byte
      000263 3E D9            [ 7]  531         LD      A,#0b11011001   ; Test byte
      000265 46               [ 7]  532         LD      B,(HL)          ; Get old contents
      000266 77               [ 7]  533         LD      (HL),A          ; Load test byte
      000267 BE               [ 7]  534         CP      (HL)            ; RAM there if same
      000268 70               [ 7]  535         LD      (HL),B          ; Restore old contents
      000269 C2 35 02         [10]  536         JP      NZ,MSIZE        ; Ask again if no RAM
                                    537 
      00026C 2B               [ 6]  538 SETTOP: DEC     HL              ; Back one byte
      00026D 11 5C 24         [10]  539         LD      DE,#STLOOK-1    ; See if enough RAM
      000270 CD 60 08         [17]  540         CALL    CPDEHL          ; Compare DE with HL
      000273 DA 35 02         [10]  541         JP      C,MSIZE         ; Ask again if not enough RAM
      000276 11 CE FF         [10]  542         LD      DE,#0-50        ; 50 Bytes string space
      000279 22 AF 23         [16]  543         LD      (LSTRAM),HL     ; Save last available RAM
      00027C 19               [11]  544         ADD     HL,DE           ; Allocate string space
      00027D 22 5A 23         [16]  545         LD      (STRSPC),HL     ; Save string space
      000280 CD A5 06         [17]  546         CALL    CLRPTR          ; Clear program area
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 11.
Hexadecimal [24-Bits]



      000283 2A 5A 23         [16]  547         LD      HL,(STRSPC)     ; Get end of memory
      000286 11 EF FF         [10]  548         LD      DE,#0-17         ; Offset for free bytes
      000289 19               [11]  549         ADD     HL,DE           ; Adjust HL
      00028A 11 F9 23         [10]  550         LD      DE,#PROGST      ; Start of program text
      00028D 7D               [ 4]  551         LD      A,L             ; Get LSB
      00028E 93               [ 4]  552         SUB     E               ; Adjust it
      00028F 6F               [ 4]  553         LD      L,A             ; Re-save
      000290 7C               [ 4]  554         LD      A,H             ; Get MSB
      000291 9A               [ 4]  555         SBC     A,D             ; Adjust it
      000292 67               [ 4]  556         LD      H,A             ; Re-save
      000293 E5               [11]  557         PUSH    HL              ; Save bytes free
      000294 21 BC 02         [10]  558         LD      HL,#SIGNON      ; Sign-on message
      000297 CD 36 13         [17]  559         CALL    PRS             ; Output string
      00029A E1               [10]  560         POP     HL              ; Get bytes free back
      00029B CD D9 19         [17]  561         CALL    PRNTHL          ; Output amount of free memory
      00029E 21 AD 02         [10]  562         LD      HL,#BFREE       ; " Bytes free" message
      0002A1 CD 36 13         [17]  563         CALL    PRS             ; Output string
                                    564 
      0002A4 31 66 23         [10]  565 WARMST: LD      SP,#STACK       ; Temporary stack
      0002A7 CD CA 06         [17]  566 BRKRET: CALL    CLREG           ; Clear registers and stack
      0002AA C3 E3 05         [10]  567         JP      PRNTOK          ; Go to get command line
                                    568 
      0002AD 20 42 79 74 65 73 20   569 BFREE:  .ascii  " Bytes free"
             66 72 65 65
      0002B8 0D 0A 00 00            570         .db     CR,LF,0,0
                                    571 
      0002BC 5A 38 30 20 42 41 53   572 SIGNON: .ascii  "Z80 BASIC Ver 4.7b"
             49 43 20 56 65 72 20
             34 2E 37 62
      0002CE 0D 0A                  573         .db      CR,LF
      0002D0 43 6F 70 79 72 69 67   574         .ascii  "Copyright (C) 1978 by Microsoft"
             68 74 20 28 43 29 20
             31 39 37 38 20 62 79
             20 4D 69 63 72 6F 73
             6F 66 74
      0002EF 0D 0A 00 00            575         .db     CR,LF,0,0
                                    576 
      0002F3 4D 65 6D 6F 72 79 20   577 MEMMSG: .ascii  "Memory top"
             74 6F 70
      0002FD 00                     578         .db     0
                                    579 
                                    580 ; FUNCTION ADDRESS TABLE
                                    581 
      0002FE 4E 18                  582 FNCTAB: .WORD   SGN
      000300 12 19                  583         .WORD   INT
      000302 64 18                  584         .WORD   ABS
      000304 03 23                  585         .WORD   USR
      000306 F6 11                  586         .WORD   FRE
      000308 7B 15                  587         .WORD   INP
      00030A 24 12                  588         .WORD   POS
      00030C D8 1A                  589         .WORD   SQR
      00030E B7 1B                  590         .WORD   RND
      000310 F3 16                  591         .WORD   LOG
      000312 26 1B                  592         .WORD   EXP
      000314 2C 1C                  593         .WORD   COS
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 12.
Hexadecimal [24-Bits]



      000316 32 1C                  594         .WORD   SIN
      000318 93 1C                  595         .WORD   TAN
      00031A A8 1C                  596         .WORD   ATN
      00031C CF 15                  597         .WORD   PEEK
      00031E 13 1D                  598         .WORD   DEEK
      000320 51 23                  599         .WORD   POINT
      000322 A8 14                  600         .WORD   LEN
      000324 C0 12                  601         .WORD   STR
      000326 42 15                  602         .WORD   VAL
      000328 B7 14                  603         .WORD   ASC
      00032A C8 14                  604         .WORD   CHR
      00032C 35 1D                  605         .WORD   HEX
      00032E C8 1D                  606         .WORD   BIN
      000330 D8 14                  607         .WORD   LEFT
      000332 08 15                  608         .WORD   RIGHT
      000334 12 15                  609         .WORD   MID
                                    610 
                                    611 ; RESERVED WORD LIST
                                    612 
      000336 C5                     613 WORDS:  .BYTE   'E'+0x80
      000337 4E 44                  614          .ascii "ND"
      000339 C6                     615         .BYTE   'F'+0x80
      00033A 4F 52                  616         .ascii  "OR"
      00033C CE                     617         .BYTE   'N'+0x80
      00033D 45 58 54               618         .ascii  "EXT"
      000340 C4                     619         .BYTE   'D'+0x80
      000341 41 54 41               620         .ascii  "ATA"
      000344 C9                     621         .BYTE   'I'+0x80
      000345 4E 50 55 54            622         .ascii  "NPUT"
      000349 C4                     623         .BYTE   'D'+0x80
      00034A 49 4D                  624         .ascii  "IM"
      00034C D2                     625         .BYTE   'R'+0x80
      00034D 45 41 44               626         .ascii  "EAD"
      000350 CC                     627         .BYTE   'L'+0x80
      000351 45 54                  628         .ascii  "ET"
      000353 C7                     629         .BYTE   'G'+0x80
      000354 4F 54 4F               630         .ascii  "OTO"
      000357 D2                     631         .BYTE   'R'+0x80
      000358 55 4E                  632         .ascii  "UN"
      00035A C9                     633         .BYTE   'I'+0x80
      00035B 46                     634         .ascii  "F"
      00035C D2                     635         .BYTE   'R'+0x80
      00035D 45 53 54 4F 52 45      636         .ascii  "ESTORE"
      000363 C7                     637         .BYTE   'G'+0x80
      000364 4F 53 55 42            638         .ascii  "OSUB"
      000368 D2                     639         .BYTE   'R'+0x80
      000369 45 54 55 52 4E         640         .ascii  "ETURN"
      00036E D2                     641         .BYTE   'R'+0x80
      00036F 45 4D                  642         .ascii  "EM"
      000371 D3                     643         .BYTE   'S'+0x80
      000372 54 4F 50               644         .ascii  "TOP"
      000375 CF                     645         .BYTE   'O'+0x80
      000376 55 54                  646         .ascii  "UT"
      000378 CF                     647         .BYTE   'O'+0x80
      000379 4E                     648         .ascii  "N"
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 13.
Hexadecimal [24-Bits]



      00037A CE                     649         .BYTE   'N'+0x80
      00037B 55 4C 4C               650         .ascii  "ULL"
      00037E D7                     651         .BYTE   'W'+0x80
      00037F 41 49 54               652         .ascii  "AIT"
      000382 C4                     653         .BYTE   'D'+0x80
      000383 45 46                  654         .ascii  "EF"
      000385 D0                     655         .BYTE   'P'+0x80
      000386 4F 4B 45               656         .ascii  "OKE"
      000389 C4                     657         .BYTE   'D'+0x80
      00038A 4F 4B 45               658         .ascii  "OKE"
      00038D D3                     659         .BYTE   'S'+0x80
      00038E 43 52 45 45 4E         660         .ascii  "CREEN"
      000393 CC                     661         .BYTE   'L'+0x80
      000394 49 4E 45 53            662         .ascii  "INES"
      000398 C3                     663         .BYTE   'C'+0x80
      000399 4C 53                  664         .ascii  "LS"
      00039B D7                     665         .BYTE   'W'+0x80
      00039C 49 44 54 48            666         .ascii  "IDTH"
      0003A0 CD                     667         .BYTE   'M'+0x80
      0003A1 4F 4E 49 54 4F 52      668         .ascii  "ONITOR"
      0003A7 D3                     669         .BYTE   'S'+0x80
      0003A8 45 54                  670         .ascii  "ET"
      0003AA D2                     671         .BYTE   'R'+0x80
      0003AB 45 53 45 54            672         .ascii  "ESET"
      0003AF D0                     673         .BYTE   'P'+0x80
      0003B0 52 49 4E 54            674         .ascii  "RINT"
      0003B4 C3                     675         .BYTE   'C'+0x80
      0003B5 4F 4E 54               676         .ascii  "ONT"
      0003B8 CC                     677         .BYTE   'L'+0x80
      0003B9 49 53 54               678         .ascii  "IST"
      0003BC C3                     679         .BYTE   'C'+0x80
      0003BD 4C 45 41 52            680         .ascii  "LEAR"
      0003C1 C3                     681         .BYTE   'C'+0x80
      0003C2 4C 4F 41 44            682         .ascii  "LOAD"
      0003C6 C3                     683         .BYTE   'C'+0x80
      0003C7 53 41 56 45            684         .ascii  "SAVE"
      0003CB CE                     685         .BYTE   'N'+0x80
      0003CC 45 57                  686         .ascii  "EW"
                                    687 
      0003CE D4                     688         .BYTE   'T'+0x80
      0003CF 41 42 28               689         .ascii  "AB("
      0003D2 D4                     690         .BYTE   'T'+0x80
      0003D3 4F                     691         .ascii  "O"
      0003D4 C6                     692         .BYTE   'F'+0x80
      0003D5 4E                     693         .ascii  "N"
      0003D6 D3                     694         .BYTE   'S'+0x80
      0003D7 50 43 28               695         .ascii  "PC("
      0003DA D4                     696         .BYTE   'T'+0x80
      0003DB 48 45 4E               697         .ascii  "HEN"
      0003DE CE                     698         .BYTE   'N'+0x80
      0003DF 4F 54                  699         .ascii  "OT"
      0003E1 D3                     700         .BYTE   'S'+0x80
      0003E2 54 45 50               701         .ascii  "TEP"
                                    702 
      0003E5 AB                     703         .BYTE   '+'+0x80
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 14.
Hexadecimal [24-Bits]



      0003E6 AD                     704         .BYTE   '-'+0x80
      0003E7 AA                     705         .BYTE   '*'+0x80
      0003E8 AF                     706         .BYTE   '/'+0x80
      0003E9 DE                     707         .BYTE   '^'+0x80
      0003EA C1                     708         .BYTE   'A'+0x80
      0003EB 4E 44                  709         .ascii  "ND"
      0003ED CF                     710         .BYTE   'O'+0x80
      0003EE 52                     711         .ascii  "R"
      0003EF BE                     712         .BYTE   '>'+0x80
      0003F0 BD                     713         .BYTE   '='+0x80
      0003F1 BC                     714         .BYTE   '<'+0x80
                                    715 
      0003F2 D3                     716         .BYTE   'S'+0x80
      0003F3 47 4E                  717         .ascii  "GN"
      0003F5 C9                     718         .BYTE   'I'+0x80
      0003F6 4E 54                  719         .ascii  "NT"
      0003F8 C1                     720         .BYTE   'A'+0x80
      0003F9 42 53                  721         .ascii  "BS"
      0003FB D5                     722         .BYTE   'U'+0x80
      0003FC 53 52                  723         .ascii  "SR"
      0003FE C6                     724         .BYTE   'F'+0x80
      0003FF 52 45                  725         .ascii  "RE"
      000401 C9                     726         .BYTE   'I'+0x80
      000402 4E 50                  727         .ascii  "NP"
      000404 D0                     728         .BYTE   'P'+0x80
      000405 4F 53                  729         .ascii  "OS"
      000407 D3                     730         .BYTE   'S'+0x80
      000408 51 52                  731         .ascii  "QR"
      00040A D2                     732         .BYTE   'R'+0x80
      00040B 4E 44                  733         .ascii  "ND"
      00040D CC                     734         .BYTE   'L'+0x80
      00040E 4F 47                  735         .ascii  "OG"
      000410 C5                     736         .BYTE   'E'+0x80
      000411 58 50                  737         .ascii  "XP"
      000413 C3                     738         .BYTE   'C'+0x80
      000414 4F 53                  739         .ascii  "OS"
      000416 D3                     740         .BYTE   'S'+0x80
      000417 49 4E                  741         .ascii  "IN"
      000419 D4                     742         .BYTE   'T'+0x80
      00041A 41 4E                  743         .ascii  "AN"
      00041C C1                     744         .BYTE   'A'+0x80
      00041D 54 4E                  745         .ascii  "TN"
      00041F D0                     746         .BYTE   'P'+0x80
      000420 45 45 4B               747         .ascii  "EEK"
      000423 C4                     748         .BYTE   'D'+0x80
      000424 45 45 4B               749         .ascii  "EEK"
      000427 D0                     750         .BYTE   'P'+0x80
      000428 4F 49 4E 54            751         .ascii  "OINT"
      00042C CC                     752         .BYTE   'L'+0x80
      00042D 45 4E                  753         .ascii  "EN"
      00042F D3                     754         .BYTE   'S'+0x80
      000430 54 52 24               755         .ascii  "TR$"
      000433 D6                     756         .BYTE   'V'+0x80
      000434 41 4C                  757         .ascii  "AL"
      000436 C1                     758         .BYTE   'A'+0x80
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 15.
Hexadecimal [24-Bits]



      000437 53 43                  759         .ascii  "SC"
      000439 C3                     760         .BYTE   'C'+0x80
      00043A 48 52 24               761         .ascii  "HR$"
      00043D C8                     762         .BYTE   'H'+0x80
      00043E 45 58 24               763         .ascii  "EX$"
      000441 C2                     764         .BYTE   'B'+0x80
      000442 49 4E 24               765         .ascii  "IN$"
      000445 CC                     766         .BYTE   'L'+0x80
      000446 45 46 54 24            767         .ascii  "EFT$"
      00044A D2                     768         .BYTE   'R'+0x80
      00044B 49 47 48 54 24         769         .ascii  "IGHT$"
      000450 CD                     770         .BYTE   'M'+0x80
      000451 49 44 24               771         .ascii  "ID$"
      000454 80                     772         .BYTE   0x80            ; End of list marker
                                    773 
                                    774 ; KEYWORD ADDRESS TABLE
                                    775 
      000455 3A 0A                  776 WORDTB: .WORD   PEND
      000457 37 09                  777         .WORD   FOR
      000459 12 0E                  778         .WORD   NEXT
      00045B 87 0B                  779         .WORD   DATA
      00045D 19 0D                  780         .WORD   INPUT
      00045F 4E 10                  781         .WORD   DIM
      000461 48 0D                  782         .WORD   READ
      000463 9E 0B                  783         .WORD   LET
      000465 44 0B                  784         .WORD   GOTO
      000467 27 0B                  785         .WORD   RUN
      000469 16 0C                  786         .WORD   IF
      00046B 00 0A                  787         .WORD   RESTOR
      00046D 33 0B                  788         .WORD   GOSUB
      00046F 62 0B                  789         .WORD   RETURN
      000471 89 0B                  790         .WORD   REM
      000473 38 0A                  791         .WORD   STOP
      000475 87 15                  792         .WORD   POUT
      000477 F8 0B                  793         .WORD   ON
      000479 79 0A                  794         .WORD   NULL
      00047B 8D 15                  795         .WORD   WAIT
      00047D 2C 12                  796         .WORD   DEF
      00047F D6 15                  797         .WORD   POKE
      000481 1E 1D                  798         .WORD   DOKE
      000483 89 0B                  799         .WORD   REM
      000485 04 1D                  800         .WORD   LINES
      000487 F7 1C                  801         .WORD   CLS
      000489 FC 1C                  802         .WORD   WIDTH
      00048B 35 1E                  803         .WORD   MONITR
      00048D 54 23                  804         .WORD   PSET
      00048F 57 23                  805         .WORD   RESET
      000491 3A 0C                  806         .WORD   PRINT
      000493 66 0A                  807         .WORD   CONT
      000495 AC 08                  808         .WORD   LIST
      000497 E1 0A                  809         .WORD   CLEAR
      000499 89 0B                  810         .WORD   REM
      00049B 89 0B                  811         .WORD   REM
      00049D A4 06                  812         .WORD   NEW
                                    813 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 16.
Hexadecimal [24-Bits]



                                    814 ; RESERVED WORD TOKEN VALUES
                                    815 
                           000080   816 ZEND    .EQU    0x80            ; END
                           000081   817 ZFOR    .EQU    0x81            ; FOR
                           000083   818 ZDATA   .EQU    0x83            ; DATA
                           000088   819 ZGOTO   .EQU    0x88            ; GOTO
                           00008C   820 ZGOSUB  .EQU    0x8C            ; GOSUB
                           00008E   821 ZREM    .EQU    0x8E            ; REM
                           00009E   822 ZPRINT  .EQU    0x9E            ; PRINT
                           0000A4   823 ZNEW    .EQU    0xA4            ; NEW
                                    824 
                           0000A5   825 ZTAB    .EQU    0xA5            ; TAB
                           0000A6   826 ZTO     .EQU    0xA6            ; TO
                           0000A7   827 ZFN     .EQU    0xA7            ; FN
                           0000A8   828 ZSPC    .EQU    0xA8            ; SPC
                           0000A9   829 ZTHEN   .EQU    0xA9            ; THEN
                           0000AA   830 ZNOT    .EQU    0xAA            ; NOT
                           0000AB   831 ZSTEP   .EQU    0xAB            ; STEP
                                    832 
                           0000AC   833 ZPLUS   .EQU    0xAC            ; +
                           0000AD   834 ZMINUS  .EQU    0xAD            ; -
                           0000AE   835 ZTIMES  .EQU    0xAE            ; *
                           0000AF   836 ZDIV    .EQU    0xAF            ; /
                           0000B2   837 ZOR     .EQU    0xB2            ; OR
                           0000B3   838 ZGTR    .EQU    0xB3            ; >
                           0000B4   839 ZEQUAL  .EQU    0xB4            ; M
                           0000B5   840 ZLTH    .EQU    0xB5            ; <
                           0000B6   841 ZSGN    .EQU    0xB6            ; SGN
                           0000C7   842 ZPOINT  .EQU    0xC7            ; POINT
                           0000CF   843 ZLEFT   .EQU    0xCD +2         ; LEFT$
                                    844 
                                    845 ; ARITHMETIC PRECEDENCE TABLE
                                    846 
      00049F 79                     847 PRITAB: .BYTE   0x79            ; Precedence value
      0004A0 C0 19                  848         .WORD   PADD            ; FPREG = <last> + FPREG
                                    849 
      0004A2 79                     850         .BYTE   0x79            ; Precedence value
      0004A3 F4 15                  851         .WORD   PSUB            ; FPREG = <last> - FPREG
                                    852 
      0004A5 7C                     853         .BYTE   0x7C            ; Precedence value
      0004A6 32 17                  854         .WORD   MULT            ; PPREG = <last> * FPREG
                                    855 
      0004A8 7C                     856         .BYTE   0x7C            ; Precedence value
      0004A9 93 17                  857         .WORD   DIV             ; FPREG = <last> / FPREG
                                    858 
      0004AB 7F                     859         .BYTE   0x7F            ; Precedence value
      0004AC E1 1A                  860         .WORD   POWER           ; FPREG = <last> ^ FPREG
                                    861 
      0004AE 50                     862         .BYTE   0x50            ; Precedence value
      0004AF A7 0F                  863         .WORD   PAND            ; FPREG = <last> AND FPREG
                                    864 
      0004B1 46                     865         .BYTE   0x46            ; Precedence value
      0004B2 A6 0F                  866         .WORD   POR             ; FPREG = <last> OR FPREG
                                    867 
                                    868 ; BASIC ERROR CODE LIST
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 17.
Hexadecimal [24-Bits]



                                    869 
      0004B4 4E                     870 ERRORS: .BYTE   "NF"            ; NEXT without FOR
      0004B5 53                     871         .BYTE   "SN"            ; Syntax error
      0004B6 52                     872         .BYTE   "RG"            ; RETURN without GOSUB
      0004B7 4F                     873         .BYTE   "OD"            ; Out of DATA
      0004B8 46                     874         .BYTE   "FC"            ; Illegal function call
      0004B9 4F                     875         .BYTE   "OV"            ; Overflow error
      0004BA 4F                     876         .BYTE   "OM"            ; Out of memory
      0004BB 55                     877         .BYTE   "UL"            ; Undefined line
      0004BC 42                     878         .BYTE   "BS"            ; Bad subscript
      0004BD 44                     879         .BYTE   "DD"            ; Re-DIMensioned array
      0004BE 2F                     880         .BYTE   "/0"            ; Division by zero
      0004BF 49                     881         .BYTE   "ID"            ; Illegal direct
      0004C0 54                     882         .BYTE   "TM"            ; Type mis-match
      0004C1 4F                     883         .BYTE   "OS"            ; Out of string space
      0004C2 4C                     884         .BYTE   "LS"            ; String too long
      0004C3 53                     885         .BYTE   "ST"            ; String formula too complex
      0004C4 43                     886         .BYTE   "CN"            ; Can't CONTinue
      0004C5 55                     887         .BYTE   "UF"            ; Undefined FN function
      0004C6 4D                     888         .BYTE   "MO"            ; Missing operand
      0004C7 48                     889         .BYTE   "HX"            ; HEX error
      0004C8 42                     890         .BYTE   "BN"            ; BIN error
                                    891 
                                    892 ; INITIALISATION TABLE -------------------------------------------------------
                                    893 
      0004C9 C3 A4 02         [10]  894 INITAB: JP      WARMST          ; Warm start jump
      0004CC C3 B7 0A         [10]  895         JP      FCERR           ; "USR (X)" jump (Set to Error)
      0004CF D3 00            [11]  896         OUT     (0),A           ; "OUT p,n" skeleton
      0004D1 C9               [10]  897         RET
      0004D2 D6 00            [ 7]  898         SUB     #0              ; Division support routine
      0004D4 6F               [ 4]  899         LD      L,A
      0004D5 7C               [ 4]  900         LD      A,H
      0004D6 DE 00            [ 7]  901         SBC     A,#0
      0004D8 67               [ 4]  902         LD      H,A
      0004D9 78               [ 4]  903         LD      A,B
      0004DA DE 00            [ 7]  904         SBC     A,#0
      0004DC 47               [ 4]  905         LD      B,A
      0004DD 3E 00            [ 7]  906         LD      A,#0
      0004DF C9               [10]  907         RET
      0004E0 00 00 00               908         .BYTE   0,0,0                   ; Random number seed table used by RND
      0004E3 35 4A CA 99            909         .BYTE   0x35,0x4A,0xCA,0x99     ;-2.65145E+07
      0004E7 39 1C 76 98            910         .BYTE   0x39,0x1C,0x76,0x98     ; 1.61291E+07
      0004EB 22 95 B3 98            911         .BYTE   0x22,0x95,0xB3,0x98     ;-1.17691E+07
      0004EF 0A DD 47 98            912         .BYTE   0x0A,0xDD,0x47,0x98     ; 1.30983E+07
      0004F3 53 D1 99 99            913         .BYTE   0x53,0xD1,0x99,0x99     ;-2-01612E+07
      0004F7 0A 1A 9F 98            914         .BYTE   0x0A,0x1A,0x9F,0x98     ;-1.04269E+07
      0004FB 65 BC CD 98            915         .BYTE   0x65,0xBC,0xCD,0x98     ;-1.34831E+07
      0004FF D6 77 3E 98            916         .BYTE   0xD6,0x77,0x3E,0x98     ; 1.24825E+07
      000503 52 C7 4F 80            917         .BYTE   0x52,0xC7,0x4F,0x80     ; Last random number
      000507 DB 00            [11]  918         IN      A,(0)           ; INP (x) skeleton
      000509 C9               [10]  919         RET
      00050A 01                     920         .BYTE   1               ; POS (x) number (1)
      00050B FF                     921         .BYTE   255             ; Terminal width (255 = no auto CRLF)
      00050C 1C                     922         .BYTE   28              ; Width for commas (3 columns)
      00050D 00                     923         .BYTE   0               ; No nulls after input bytes
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 18.
Hexadecimal [24-Bits]



      00050E 00                     924         .BYTE   0               ; Output enabled (^O off)
      00050F 14 00                  925         .WORD   20              ; Initial lines counter
      000511 14 00                  926         .WORD   20              ; Initial lines number
      000513 00 00                  927         .WORD   0               ; Array load/save check sum
      000515 00                     928         .BYTE   0               ; Break not by NMI
      000516 00                     929         .BYTE   0               ; Break flag
      000517 C3 DD 07         [10]  930         JP      TTYLIN          ; Input reflection (set to TTY)
      00051A C3 00 00         [10]  931         JP      0x0000          ; POINT reflection unused
      00051D C3 00 00         [10]  932         JP      0x0000          ; SET reflection
      000520 C3 00 00         [10]  933         JP      0x0000         	; RESET reflection
      000523 5D 24                  934         .WORD   STLOOK          ; Temp string space
      000525 FE FF                  935         .WORD   -2              ; Current line number (cold)
      000527 FA 23                  936         .WORD   PROGST+1        ; Start of program text
      000529                        937 INITBE:                         
                                    938 
                                    939 ; END OF INITIALISATION TABLE ---------------------------------------------------
                                    940 
      000529 20 45 72 72 6F 72      941 ERRMSG: .ascii  " Error"
      00052F 00                     942         .byte   0
      000530 20 69 6E 20            943 INMSG:  .ascii  " in "
      000534 00                     944 ZERBYT: .byte   0               ; A zero byte
      000535 4F 6B                  945 OKMSG:  .ascii  "Ok"
      000537 0D 0A 00 00            946         .byte   CR,LF,0,0
      00053B 42 72 65 61 6B         947 BRKMSG: .ascii  "Break"
      000540 00                     948         .byte   0
                                    949 
      000541 21 04 00         [10]  950 BAKSTK: LD      HL,#4           ; Look for "FOR" block with
      000544 39               [11]  951         ADD     HL,SP           ; same index as specified
      000545 7E               [ 7]  952 LOKFOR: LD      A,(HL)          ; Get block ID
      000546 23               [ 6]  953         INC     HL              ; Point to index address
      000547 FE 81            [ 7]  954         CP      #ZFOR            ; Is it a "FOR" token
      000549 C0               [11]  955         RET     NZ              ; No - exit
      00054A 4E               [ 7]  956         LD      C,(HL)          ; BC = Address of "FOR" index
      00054B 23               [ 6]  957         INC     HL
      00054C 46               [ 7]  958         LD      B,(HL)
      00054D 23               [ 6]  959         INC     HL              ; Point to sign of STEP
      00054E E5               [11]  960         PUSH    HL              ; Save pointer to sign
      00054F 69               [ 4]  961         LD      L,C             ; HL = address of "FOR" index
      000550 60               [ 4]  962         LD      H,B
      000551 7A               [ 4]  963         LD      A,D             ; See if an index was specified
      000552 B3               [ 4]  964         OR      E               ; DE = 0 if no index specified
      000553 EB               [ 4]  965         EX      DE,HL           ; Specified index into HL
      000554 CA 5B 05         [10]  966         JP      Z,INDFND        ; Skip if no index given
      000557 EB               [ 4]  967         EX      DE,HL           ; Index back into DE
      000558 CD 60 08         [17]  968         CALL    CPDEHL          ; Compare index with one given
      00055B 01 0D 00         [10]  969 INDFND: LD      BC,#16-3        ; Offset to next block
      00055E E1               [10]  970         POP     HL              ; Restore pointer to sign
      00055F C8               [11]  971         RET     Z               ; Return if block found
      000560 09               [11]  972         ADD     HL,BC           ; Point to next block
      000561 C3 45 05         [10]  973         JP      LOKFOR          ; Keep on looking
                                    974 
      000564 CD 7E 05         [17]  975 MOVUP:  CALL    ENFMEM          ; See if enough memory
      000567 C5               [11]  976 MOVSTR: PUSH    BC              ; Save end of source
      000568 E3               [19]  977         EX      (SP),HL         ; Swap source and dest" end
      000569 C1               [10]  978         POP     BC              ; Get end of destination
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 19.
Hexadecimal [24-Bits]



      00056A CD 60 08         [17]  979 MOVLP:  CALL    CPDEHL          ; See if list moved
      00056D 7E               [ 7]  980         LD      A,(HL)          ; Get byte
      00056E 02               [ 7]  981         LD      (BC),A          ; Move it
      00056F C8               [11]  982         RET     Z               ; Exit if all done
      000570 0B               [ 6]  983         DEC     BC              ; Next byte to move to
      000571 2B               [ 6]  984         DEC     HL              ; Next byte to move
      000572 C3 6A 05         [10]  985         JP      MOVLP           ; Loop until all bytes moved
                                    986 
      000575 E5               [11]  987 CHKSTK: PUSH    HL              ; Save code string address
      000576 2A DA 23         [16]  988         LD      HL,(ARREND)     ; Lowest free memory
      000579 06 00            [ 7]  989         LD      B,#0            ; BC = Number of levels to test
      00057B 09               [11]  990         ADD     HL,BC           ; 2 Bytes for each level
      00057C 09               [11]  991         ADD     HL,BC
      00057D 3E                     992         .BYTE   0x3E            ; Skip "PUSH HL"
      00057E E5               [11]  993 ENFMEM: PUSH    HL              ; Save code string address
      00057F 3E D0            [ 7]  994         LD      A,#0xD0;LOW -48 ; 48 Bytes minimum RAM
      000581 95               [ 4]  995         SUB     L
      000582 6F               [ 4]  996         LD      L,A
      000583 3E FF            [ 7]  997         LD      A,#0xFF; HIGH (-48) ; 48 Bytes minimum RAM
      000585 9C               [ 4]  998         SBC     A,H
      000586 DA 8D 05         [10]  999         JP      C,OMERR         ; Not enough - ?OM Error
      000589 67               [ 4] 1000         LD      H,A
      00058A 39               [11] 1001         ADD     HL,SP           ; Test if stack is overflowed
      00058B E1               [10] 1002         POP     HL              ; Restore code string address
      00058C D8               [11] 1003         RET     C               ; Return if enough mmory
      00058D 1E 0C            [ 7] 1004 OMERR:  LD      E,#OM           ; ?OM Error
      00058F C3 AC 05         [10] 1005         JP      ERROR
                                   1006 
      000592 2A C9 23         [16] 1007 DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
      000595 22 5C 23         [16] 1008         LD      (LINEAT),HL     ; Save as current line
      000598 1E 02            [ 7] 1009 SNERR:  LD      E,#SN           ; ?SN Error
      00059A 01                    1010         .BYTE   0x01            ; Skip "LD E,DZ"
      00059B 1E 14            [ 7] 1011 DZERR:  LD      E,#DZ           ; ?/0 Error
      00059D 01                    1012         .BYTE   0x01            ; Skip "LD E,NF"
      00059E 1E 00            [ 7] 1013 NFERR:  LD      E,#NF           ; ?NF Error
      0005A0 01                    1014         .BYTE   0x01            ; Skip "LD E,DD"
      0005A1 1E 12            [ 7] 1015 DDERR:  LD      E,#DD           ; ?DD Error
      0005A3 01                    1016         .BYTE   0x01            ; Skip "LD E,UF"
      0005A4 1E 22            [ 7] 1017 UFERR:  LD      E,#UF           ; ?UF Error
      0005A6 01                    1018         .BYTE   0x01            ; Skip "LD E,OV
      0005A7 1E 0A            [ 7] 1019 OVERR:  LD      E,#OV           ; ?OV Error
      0005A9 01                    1020         .BYTE   0x01            ; Skip "LD E,TM"
      0005AA 1E 18            [ 7] 1021 TMERR:  LD      E,#TM           ; ?TM Error
                                   1022 
      0005AC CD CA 06         [17] 1023 ERROR:  CALL    CLREG           ; Clear registers and stack
      0005AF 32 45 23         [13] 1024         LD      (CTLOFG),A      ; Enable output (A is 0)
      0005B2 CD 8B 0C         [17] 1025         CALL    STTLIN          ; Start new line
      0005B5 21 B4 04         [10] 1026         LD      HL,#ERRORS      ; Point to error codes
      0005B8 57               [ 4] 1027         LD      D,A             ; D = 0 (A is 0)
      0005B9 3E 3F            [ 7] 1028         LD      A,#'?'
      0005BB CD 71 08         [17] 1029         CALL    OUTC            ; Output '?'
      0005BE 19               [11] 1030         ADD     HL,DE           ; Offset to correct error code
      0005BF 7E               [ 7] 1031         LD      A,(HL)          ; First character
      0005C0 CD 71 08         [17] 1032         CALL    OUTC            ; Output it
      0005C3 CD F0 09         [17] 1033         CALL    GETCHR          ; Get next character
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 20.
Hexadecimal [24-Bits]



      0005C6 CD 71 08         [17] 1034         CALL    OUTC            ; Output it
      0005C9 21 29 05         [10] 1035         LD      HL,#ERRMSG      ; "Error" message
      0005CC CD 36 13         [17] 1036 ERRIN:  CALL    PRS             ; Output message
      0005CF 2A 5C 23         [16] 1037         LD      HL,(LINEAT)     ; Get line of error
      0005D2 11 FE FF         [10] 1038         LD      DE,#-2          ; Cold start error if -2
      0005D5 CD 60 08         [17] 1039         CALL    CPDEHL          ; See if cold start error
      0005D8 CA 11 02         [10] 1040         JP      Z,CSTART        ; Cold start error - Restart
      0005DB 7C               [ 4] 1041         LD      A,H             ; Was it a direct error?
      0005DC A5               [ 4] 1042         AND     L               ; Line = -1 if direct error
      0005DD 3C               [ 4] 1043         INC     A
      0005DE C4 D1 19         [17] 1044         CALL    NZ,LINEIN       ; No - output line of error
      0005E1 3E                    1045         .BYTE   0x3E            ; Skip "POP BC"
      0005E2 C1               [10] 1046 POPNOK: POP     BC              ; Drop address in input buffer
                                   1047 
      0005E3 AF               [ 4] 1048 PRNTOK: XOR     A               ; Output "Ok" and get command
      0005E4 32 45 23         [13] 1049         LD      (CTLOFG),A      ; Enable output
      0005E7 CD 8B 0C         [17] 1050         CALL    STTLIN          ; Start new line
      0005EA 21 35 05         [10] 1051         LD      HL,#OKMSG       ; "Ok" message
      0005ED CD 36 13         [17] 1052         CALL    PRS             ; Output "Ok"
      0005F0 21 FF FF         [10] 1053 GETCMD: LD      HL,#-1          ; Flag direct mode
      0005F3 22 5C 23         [16] 1054         LD      (LINEAT),HL     ; Save as current line
      0005F6 CD DD 07         [17] 1055         CALL    GETLIN          ; Get an input line
      0005F9 DA F0 05         [10] 1056         JP      C,GETCMD        ; Get line again if break
      0005FC CD F0 09         [17] 1057         CALL    GETCHR          ; Get first character
      0005FF 3C               [ 4] 1058         INC     A               ; Test if end of line
      000600 3D               [ 4] 1059         DEC     A               ; Without affecting Carry
      000601 CA F0 05         [10] 1060         JP      Z,GETCMD        ; Nothing entered - Get another
      000604 F5               [11] 1061         PUSH    AF              ; Save Carry status
      000605 CD BC 0A         [17] 1062         CALL    ATOH            ; Get line number into DE
      000608 D5               [11] 1063         PUSH    DE              ; Save line number
      000609 CD F4 06         [17] 1064         CALL    CRUNCH          ; Tokenise rest of line
      00060C 47               [ 4] 1065         LD      B,A             ; Length of tokenised line
      00060D D1               [10] 1066         POP     DE              ; Restore line number
      00060E F1               [10] 1067         POP     AF              ; Restore Carry
      00060F D2 D0 09         [10] 1068         JP      NC,EXCUTE       ; No line number - Direct mode
      000612 D5               [11] 1069         PUSH    DE              ; Save line number
      000613 C5               [11] 1070         PUSH    BC              ; Save length of tokenised line
      000614 AF               [ 4] 1071         XOR     A
      000615 32 CC 23         [13] 1072         LD      (LSTBIN),A      ; Clear last byte input
      000618 CD F0 09         [17] 1073         CALL    GETCHR          ; Get next character
      00061B B7               [ 4] 1074         OR      A               ; Set flags
      00061C F5               [11] 1075         PUSH    AF              ; And save them
      00061D CD 84 06         [17] 1076         CALL    SRCHLN          ; Search for line number in DE
      000620 DA 29 06         [10] 1077         JP      C,LINFND        ; Jump if line found
      000623 F1               [10] 1078         POP     AF              ; Get status
      000624 F5               [11] 1079         PUSH    AF              ; And re-save
      000625 CA 5D 0B         [10] 1080         JP      Z,ULERR         ; Nothing after number - Error
      000628 B7               [ 4] 1081         OR      A               ; Clear Carry
      000629 C5               [11] 1082 LINFND: PUSH    BC              ; Save address of line in prog
      00062A D2 40 06         [10] 1083         JP      NC,INEWLN       ; Line not found - Insert new
      00062D EB               [ 4] 1084         EX      DE,HL           ; Next line address in DE
      00062E 2A D6 23         [16] 1085         LD      HL,(PROGND)     ; End of program
      000631 1A               [ 7] 1086 SFTPRG: LD      A,(DE)          ; Shift rest of program down
      000632 02               [ 7] 1087         LD      (BC),A
      000633 03               [ 6] 1088         INC     BC              ; Next destination
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 21.
Hexadecimal [24-Bits]



      000634 13               [ 6] 1089         INC     DE              ; Next source
      000635 CD 60 08         [17] 1090         CALL    CPDEHL          ; All done?
      000638 C2 31 06         [10] 1091         JP      NZ,SFTPRG       ; More to do
      00063B 60               [ 4] 1092         LD      H,B             ; HL - New end of program
      00063C 69               [ 4] 1093         LD      L,C
      00063D 22 D6 23         [16] 1094         LD      (PROGND),HL     ; Update end of program
                                   1095 
      000640 D1               [10] 1096 INEWLN: POP     DE              ; Get address of line,
      000641 F1               [10] 1097         POP     AF              ; Get status
      000642 CA 67 06         [10] 1098         JP      Z,SETPTR        ; No text - Set up pointers
      000645 2A D6 23         [16] 1099         LD      HL,(PROGND)     ; Get end of program
      000648 E3               [19] 1100         EX      (SP),HL         ; Get length of input line
      000649 C1               [10] 1101         POP     BC              ; End of program to BC
      00064A 09               [11] 1102         ADD     HL,BC           ; Find new end
      00064B E5               [11] 1103         PUSH    HL              ; Save new end
      00064C CD 64 05         [17] 1104         CALL    MOVUP           ; Make space for line
      00064F E1               [10] 1105         POP     HL              ; Restore new end
      000650 22 D6 23         [16] 1106         LD      (PROGND),HL     ; Update end of program pointer
      000653 EB               [ 4] 1107         EX      DE,HL           ; Get line to move up in HL
      000654 74               [ 7] 1108         LD      (HL),H          ; Save MSB
      000655 D1               [10] 1109         POP     DE              ; Get new line number
      000656 23               [ 6] 1110         INC     HL              ; Skip pointer
      000657 23               [ 6] 1111         INC     HL
      000658 73               [ 7] 1112         LD      (HL),E          ; Save LSB of line number
      000659 23               [ 6] 1113         INC     HL
      00065A 72               [ 7] 1114         LD      (HL),D          ; Save MSB of line number
      00065B 23               [ 6] 1115         INC     HL              ; To first byte in line
      00065C 11 61 23         [10] 1116         LD      DE,#BUFFER      ; Copy buffer to program
      00065F 1A               [ 7] 1117 MOVBUF: LD      A,(DE)          ; Get source
      000660 77               [ 7] 1118         LD      (HL),A          ; Save destinations
      000661 23               [ 6] 1119         INC     HL              ; Next source
      000662 13               [ 6] 1120         INC     DE              ; Next destination
      000663 B7               [ 4] 1121         OR      A               ; Done?
      000664 C2 5F 06         [10] 1122         JP      NZ,MOVBUF       ; No - Repeat
      000667 CD B0 06         [17] 1123 SETPTR: CALL    RUNFST          ; Set line pointers
      00066A 23               [ 6] 1124         INC     HL              ; To LSB of pointer
      00066B EB               [ 4] 1125         EX      DE,HL           ; Address to DE
      00066C 62               [ 4] 1126 PTRLP:  LD      H,D             ; Address to HL
      00066D 6B               [ 4] 1127         LD      L,E
      00066E 7E               [ 7] 1128         LD      A,(HL)          ; Get LSB of pointer
      00066F 23               [ 6] 1129         INC     HL              ; To MSB of pointer
      000670 B6               [ 7] 1130         OR      (HL)            ; Compare with MSB pointer
      000671 CA F0 05         [10] 1131         JP      Z,GETCMD        ; Get command line if end
      000674 23               [ 6] 1132         INC     HL              ; To LSB of line number
      000675 23               [ 6] 1133         INC     HL              ; Skip line number
      000676 23               [ 6] 1134         INC     HL              ; Point to first byte in line
      000677 AF               [ 4] 1135         XOR     A               ; Looking for 00 byte
      000678 BE               [ 7] 1136 FNDEND: CP      (HL)            ; Found end of line?
      000679 23               [ 6] 1137         INC     HL              ; Move to next byte
      00067A C2 78 06         [10] 1138         JP      NZ,FNDEND       ; No - Keep looking
      00067D EB               [ 4] 1139         EX      DE,HL           ; Next line address to HL
      00067E 73               [ 7] 1140         LD      (HL),E          ; Save LSB of pointer
      00067F 23               [ 6] 1141         INC     HL
      000680 72               [ 7] 1142         LD      (HL),D          ; Save MSB of pointer
      000681 C3 6C 06         [10] 1143         JP      PTRLP           ; Do next line
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 22.
Hexadecimal [24-Bits]



                                   1144 
      000684 2A 5E 23         [16] 1145 SRCHLN: LD      HL,(BASTXT)     ; Start of program text
      000687 44               [ 4] 1146 SRCHLP: LD      B,H             ; BC = Address to look at
      000688 4D               [ 4] 1147         LD      C,L
      000689 7E               [ 7] 1148         LD      A,(HL)          ; Get address of next line
      00068A 23               [ 6] 1149         INC     HL
      00068B B6               [ 7] 1150         OR      (HL)            ; End of program found?
      00068C 2B               [ 6] 1151         DEC     HL
      00068D C8               [11] 1152         RET     Z               ; Yes - Line not found
      00068E 23               [ 6] 1153         INC     HL
      00068F 23               [ 6] 1154         INC     HL
      000690 7E               [ 7] 1155         LD      A,(HL)          ; Get LSB of line number
      000691 23               [ 6] 1156         INC     HL
      000692 66               [ 7] 1157         LD      H,(HL)          ; Get MSB of line number
      000693 6F               [ 4] 1158         LD      L,A
      000694 CD 60 08         [17] 1159         CALL    CPDEHL          ; Compare with line in DE
      000697 60               [ 4] 1160         LD      H,B             ; HL = Start of this line
      000698 69               [ 4] 1161         LD      L,C
      000699 7E               [ 7] 1162         LD      A,(HL)          ; Get LSB of next line address
      00069A 23               [ 6] 1163         INC     HL
      00069B 66               [ 7] 1164         LD      H,(HL)          ; Get MSB of next line address
      00069C 6F               [ 4] 1165         LD      L,A             ; Next line to HL
      00069D 3F               [ 4] 1166         CCF
      00069E C8               [11] 1167         RET     Z               ; Lines found - Exit
      00069F 3F               [ 4] 1168         CCF
      0006A0 D0               [11] 1169         RET     NC              ; Line not found,at line after
      0006A1 C3 87 06         [10] 1170         JP      SRCHLP          ; Keep looking
                                   1171 
      0006A4 C0               [11] 1172 NEW:    RET     NZ              ; Return if any more on line
      0006A5 2A 5E 23         [16] 1173 CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
      0006A8 AF               [ 4] 1174         XOR     A               ; Set program area to empty
      0006A9 77               [ 7] 1175         LD      (HL),A          ; Save LSB = 00
      0006AA 23               [ 6] 1176         INC     HL
      0006AB 77               [ 7] 1177         LD      (HL),A          ; Save MSB = 00
      0006AC 23               [ 6] 1178         INC     HL
      0006AD 22 D6 23         [16] 1179         LD      (PROGND),HL     ; Set program end
                                   1180 
      0006B0 2A 5E 23         [16] 1181 RUNFST: LD      HL,(BASTXT)     ; Clear all variables
      0006B3 2B               [ 6] 1182         DEC     HL
                                   1183 
      0006B4 22 CE 23         [16] 1184 INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
      0006B7 2A AF 23         [16] 1185         LD      HL,(LSTRAM)     ; Get end of RAM
      0006BA 22 C3 23         [16] 1186         LD      (STRBOT),HL     ; Clear string space
      0006BD AF               [ 4] 1187         XOR     A
      0006BE CD 00 0A         [17] 1188         CALL    RESTOR          ; Reset DATA pointers
      0006C1 2A D6 23         [16] 1189         LD      HL,(PROGND)     ; Get end of program
      0006C4 22 D8 23         [16] 1190         LD      (VAREND),HL     ; Clear variables
      0006C7 22 DA 23         [16] 1191         LD      (ARREND),HL     ; Clear arrays
                                   1192 
      0006CA C1               [10] 1193 CLREG:  POP     BC              ; Save return address
      0006CB 2A 5A 23         [16] 1194         LD      HL,(STRSPC)     ; Get end of working RAN
      0006CE F9               [ 6] 1195         LD      SP,HL           ; Set stack
      0006CF 21 B3 23         [10] 1196         LD      HL,#TMSTPL      ; Temporary string pool
      0006D2 22 B1 23         [16] 1197         LD      (TMSTPT),HL     ; Reset temporary string ptr
      0006D5 AF               [ 4] 1198         XOR     A               ; A = 00
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 23.
Hexadecimal [24-Bits]



      0006D6 6F               [ 4] 1199         LD      L,A             ; HL = 0000
      0006D7 67               [ 4] 1200         LD      H,A
      0006D8 22 D4 23         [16] 1201         LD      (CONTAD),HL     ; No CONTinue
      0006DB 32 CB 23         [13] 1202         LD      (FORFLG),A      ; Clear FOR flag
      0006DE 22 DE 23         [16] 1203         LD      (FNRGNM),HL     ; Clear FN argument
      0006E1 E5               [11] 1204         PUSH    HL              ; HL = 0000
      0006E2 C5               [11] 1205         PUSH    BC              ; Put back return
      0006E3 2A CE 23         [16] 1206 DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
      0006E6 C9               [10] 1207         RET                     ; Return to execution driver
                                   1208 
      0006E7 3E 3F            [ 7] 1209 PROMPT: LD      A,#'?'          ; '?'
      0006E9 CD 71 08         [17] 1210         CALL    OUTC            ; Output character
      0006EC 3E 20            [ 7] 1211         LD      A,#' '          ; Space
      0006EE CD 71 08         [17] 1212         CALL    OUTC            ; Output character
      0006F1 C3 4E 23         [10] 1213         JP      RINPUT          ; Get input line
                                   1214 
      0006F4 AF               [ 4] 1215 CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
      0006F5 32 AE 23         [13] 1216         LD      (DATFLG),A      ; Reset literal flag
      0006F8 0E 05            [ 7] 1217         LD      C,#2+3          ; 2 byte number and 3 nulls
      0006FA 11 61 23         [10] 1218         LD      DE,#BUFFER      ; Start of input buffer
      0006FD 7E               [ 7] 1219 CRNCLP: LD      A,(HL)          ; Get byte
      0006FE FE 20            [ 7] 1220         CP      #' '            ; Is it a space?
      000700 CA 7C 07         [10] 1221         JP      Z,MOVDIR        ; Yes - Copy direct
      000703 47               [ 4] 1222         LD      B,A             ; Save character
      000704 FE 22            [ 7] 1223         CP      #'"'            ; Is it a quote?
      000706 CA 9C 07         [10] 1224         JP      Z,CPYLIT        ; Yes - Copy literal string
      000709 B7               [ 4] 1225         OR      A               ; Is it end of buffer?
      00070A CA A3 07         [10] 1226         JP      Z,ENDBUF        ; Yes - End buffer
      00070D 3A AE 23         [13] 1227         LD      A,(DATFLG)      ; Get data type
      000710 B7               [ 4] 1228         OR      A               ; Literal?
      000711 7E               [ 7] 1229         LD      A,(HL)          ; Get byte to copy
      000712 C2 7C 07         [10] 1230         JP      NZ,MOVDIR       ; Literal - Copy direct
      000715 FE 3F            [ 7] 1231         CP      #'?'            ; Is it '?' short for PRINT
      000717 3E 9E            [ 7] 1232         LD      A,#ZPRINT       ; "PRINT" token
      000719 CA 7C 07         [10] 1233         JP      Z,MOVDIR        ; Yes - replace it
      00071C 7E               [ 7] 1234         LD      A,(HL)          ; Get byte again
      00071D FE 30            [ 7] 1235         CP      #'0'            ; Is it less than '0'
      00071F DA 27 07         [10] 1236         JP      C,FNDWRD        ; Yes - Look for reserved words
      000722 FE 3C            [ 7] 1237         CP      #60; ";"+1      ; Is it "0123456789:;" ?
      000724 DA 7C 07         [10] 1238         JP      C,MOVDIR        ; Yes - copy it direct
      000727 D5               [11] 1239 FNDWRD: PUSH    DE              ; Look for reserved words
      000728 11 35 03         [10] 1240         LD      DE,#WORDS-1     ; Point to table
      00072B C5               [11] 1241         PUSH    BC              ; Save count
      00072C 01 78 07         [10] 1242         LD      BC,#RETNAD      ; Where to return to
      00072F C5               [11] 1243         PUSH    BC              ; Save return address
      000730 06 7F            [ 7] 1244         LD      B,#ZEND-1       ; First token value -1
      000732 7E               [ 7] 1245         LD      A,(HL)          ; Get byte
      000733 FE 61            [ 7] 1246         CP      #'a'            ; Less than 'a' ?
      000735 DA 40 07         [10] 1247         JP      C,SEARCH        ; Yes - search for words
      000738 FE 7B            [ 7] 1248         CP      #'z'+1          ; Greater than 'z' ?
      00073A D2 40 07         [10] 1249         JP      NC,SEARCH       ; Yes - search for words
      00073D E6 5F            [ 7] 1250         AND     #0b01011111     ; Force upper case
      00073F 77               [ 7] 1251         LD      (HL),A          ; Replace byte
      000740 4E               [ 7] 1252 SEARCH: LD      C,(HL)          ; Search for a word
      000741 EB               [ 4] 1253         EX      DE,HL
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 24.
Hexadecimal [24-Bits]



      000742 23               [ 6] 1254 GETNXT: INC     HL              ; Get next reserved word
      000743 B6               [ 7] 1255         OR      (HL)            ; Start of word?
      000744 F2 42 07         [10] 1256         JP      P,GETNXT        ; No - move on
      000747 04               [ 4] 1257         INC     B               ; Increment token value
      000748 7E               [ 7] 1258         LD      A, (HL)         ; Get byte from table
      000749 E6 7F            [ 7] 1259         AND     #0b01111111     ; Strip bit 7
      00074B C8               [11] 1260         RET     Z               ; Return if end of list
      00074C B9               [ 4] 1261         CP      C               ; Same character as in buffer?
      00074D C2 42 07         [10] 1262         JP      NZ,GETNXT       ; No - get next word
      000750 EB               [ 4] 1263         EX      DE,HL
      000751 E5               [11] 1264         PUSH    HL              ; Save start of word
                                   1265 
      000752 13               [ 6] 1266 NXTBYT: INC     DE              ; Look through rest of word
      000753 1A               [ 7] 1267         LD      A,(DE)          ; Get byte from table
      000754 B7               [ 4] 1268         OR      A               ; End of word ?
      000755 FA 74 07         [10] 1269         JP      M,MATCH         ; Yes - Match found
      000758 4F               [ 4] 1270         LD      C,A             ; Save it
      000759 78               [ 4] 1271         LD      A,B             ; Get token value
      00075A FE 88            [ 7] 1272         CP      #ZGOTO          ; Is it "GOTO" token ?
      00075C C2 63 07         [10] 1273         JP      NZ,NOSPC        ; No - Don't allow spaces
      00075F CD F0 09         [17] 1274         CALL    GETCHR          ; Get next character
      000762 2B               [ 6] 1275         DEC     HL              ; Cancel increment from GETCHR
      000763 23               [ 6] 1276 NOSPC:  INC     HL              ; Next byte
      000764 7E               [ 7] 1277         LD      A,(HL)          ; Get byte
      000765 FE 61            [ 7] 1278         CP      #'a'            ; Less than 'a' ?
      000767 DA 6C 07         [10] 1279         JP      C,NOCHNG        ; Yes - don't change
      00076A E6 5F            [ 7] 1280         AND     #0b01011111     ; Make upper case
      00076C B9               [ 4] 1281 NOCHNG: CP      C               ; Same as in buffer ?
      00076D CA 52 07         [10] 1282         JP      Z,NXTBYT        ; Yes - keep testing
      000770 E1               [10] 1283         POP     HL              ; Get back start of word
      000771 C3 40 07         [10] 1284         JP      SEARCH          ; Look at next word
                                   1285 
      000774 48               [ 4] 1286 MATCH:  LD      C,B             ; Word found - Save token value
      000775 F1               [10] 1287         POP     AF              ; Throw away return
      000776 EB               [ 4] 1288         EX      DE,HL
      000777 C9               [10] 1289         RET                     ; Return to "RETNAD"
      000778 EB               [ 4] 1290 RETNAD: EX      DE,HL           ; Get address in string
      000779 79               [ 4] 1291         LD      A,C             ; Get token value
      00077A C1               [10] 1292         POP     BC              ; Restore buffer length
      00077B D1               [10] 1293         POP     DE              ; Get destination address
      00077C 23               [ 6] 1294 MOVDIR: INC     HL              ; Next source in buffer
      00077D 12               [ 7] 1295         LD      (DE),A          ; Put byte in buffer
      00077E 13               [ 6] 1296         INC     DE              ; Move up buffer
      00077F 0C               [ 4] 1297         INC     C               ; Increment length of buffer
      000780 D6 3A            [ 7] 1298         SUB     #':'            ; End of statement?
      000782 CA 8A 07         [10] 1299         JP      Z,SETLIT        ; Jump if multi-statement line
      000785 FE 49            [ 7] 1300         CP      #ZDATA-0x3A     ; Is it DATA statement ?
      000787 C2 8D 07         [10] 1301         JP      NZ,TSTREM       ; No - see if REM
      00078A 32 AE 23         [13] 1302 SETLIT: LD      (DATFLG),A      ; Set literal flag
      00078D D6 54            [ 7] 1303 TSTREM: SUB     #ZREM-0x3A      ; Is it REM?
      00078F C2 FD 06         [10] 1304         JP      NZ,CRNCLP       ; No - Leave flag
      000792 47               [ 4] 1305         LD      B,A             ; Copy rest of buffer
      000793 7E               [ 7] 1306 NXTCHR: LD      A,(HL)          ; Get byte
      000794 B7               [ 4] 1307         OR      A               ; End of line ?
      000795 CA A3 07         [10] 1308         JP      Z,ENDBUF        ; Yes - Terminate buffer
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 25.
Hexadecimal [24-Bits]



      000798 B8               [ 4] 1309         CP      B               ; End of statement ?
      000799 CA 7C 07         [10] 1310         JP      Z,MOVDIR        ; Yes - Get next one
      00079C 23               [ 6] 1311 CPYLIT: INC     HL              ; Move up source string
      00079D 12               [ 7] 1312         LD      (DE),A          ; Save in destination
      00079E 0C               [ 4] 1313         INC     C               ; Increment length
      00079F 13               [ 6] 1314         INC     DE              ; Move up destination
      0007A0 C3 93 07         [10] 1315         JP      NXTCHR          ; Repeat
                                   1316 
      0007A3 21 60 23         [10] 1317 ENDBUF: LD      HL,#BUFFER-1    ; Point to start of buffer
      0007A6 12               [ 7] 1318         LD      (DE),A          ; Mark end of buffer (A = 00)
      0007A7 13               [ 6] 1319         INC     DE
      0007A8 12               [ 7] 1320         LD      (DE),A          ; A = 00
      0007A9 13               [ 6] 1321         INC     DE
      0007AA 12               [ 7] 1322         LD      (DE),A          ; A = 00
      0007AB C9               [10] 1323         RET
                                   1324 
      0007AC 3A 44 23         [13] 1325 DODEL:  LD      A,(NULFLG)      ; Get null flag status
      0007AF B7               [ 4] 1326         OR      A               ; Is it zero?
      0007B0 3E 00            [ 7] 1327         LD      A,#0            ; Zero A - Leave flags
      0007B2 32 44 23         [13] 1328         LD      (NULFLG),A      ; Zero null flag
      0007B5 C2 C0 07         [10] 1329         JP      NZ,ECHDEL       ; Set - Echo it
      0007B8 05               [ 4] 1330         DEC     B               ; Decrement length
      0007B9 CA DD 07         [10] 1331         JP      Z,GETLIN        ; Get line again if empty
      0007BC CD 71 08         [17] 1332         CALL    OUTC            ; Output null character
      0007BF 3E                    1333         .BYTE   0x3E            ; Skip "DEC B"
      0007C0 05               [ 4] 1334 ECHDEL: DEC     B               ; Count bytes in buffer
      0007C1 2B               [ 6] 1335         DEC     HL              ; Back space buffer
      0007C2 CA D4 07         [10] 1336         JP      Z,OTKLN         ; No buffer - Try again
      0007C5 7E               [ 7] 1337         LD      A,(HL)          ; Get deleted byte
      0007C6 CD 71 08         [17] 1338         CALL    OUTC            ; Echo it
      0007C9 C3 E6 07         [10] 1339         JP      MORINP          ; Get more input
                                   1340 
      0007CC 05               [ 4] 1341 DELCHR: DEC     B               ; Count bytes in buffer
      0007CD 2B               [ 6] 1342         DEC     HL              ; Back space buffer
      0007CE CD 71 08         [17] 1343         CALL    OUTC            ; Output character in A
      0007D1 C2 E6 07         [10] 1344         JP      NZ,MORINP       ; Not end - Get more
      0007D4 CD 71 08         [17] 1345 OTKLN:  CALL    OUTC            ; Output character in A
      0007D7 CD 98 0C         [17] 1346 KILIN:  CALL    PRNTCRLF        ; Output CRLF
      0007DA C3 DD 07         [10] 1347         JP      TTYLIN          ; Get line again
                                   1348 
      0007DD                       1349 GETLIN:
      0007DD 21 61 23         [10] 1350 TTYLIN: LD      HL,#BUFFER      ; Get a line by character
      0007E0 06 01            [ 7] 1351         LD      B,#1            ; Set buffer as empty
      0007E2 AF               [ 4] 1352         XOR     A
      0007E3 32 44 23         [13] 1353         LD      (NULFLG),A      ; Clear null flag
      0007E6 CD 9B 08         [17] 1354 MORINP: CALL    CLOTST          ; Get character and test ^O
      0007E9 4F               [ 4] 1355         LD      C,A             ; Save character in C
      0007EA FE 7F            [ 7] 1356         CP      #DEL            ; Delete character?
      0007EC CA AC 07         [10] 1357         JP      Z,DODEL         ; Yes - Process it
      0007EF 3A 44 23         [13] 1358         LD      A,(NULFLG)      ; Get null flag
      0007F2 B7               [ 4] 1359         OR      A               ; Test null flag status
      0007F3 CA FF 07         [10] 1360         JP      Z,PROCES        ; Reset - Process character
      0007F6 3E 00            [ 7] 1361         LD      A,#0            ; Set a null
      0007F8 CD 71 08         [17] 1362         CALL    OUTC            ; Output null
      0007FB AF               [ 4] 1363         XOR     A               ; Clear A
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 26.
Hexadecimal [24-Bits]



      0007FC 32 44 23         [13] 1364         LD      (NULFLG),A      ; Reset null flag
      0007FF 79               [ 4] 1365 PROCES: LD      A,C             ; Get character
      000800 FE 07            [ 7] 1366         CP      #CTRLG          ; Bell?
      000802 CA 43 08         [10] 1367         JP      Z,PUTCTL        ; Yes - Save it
      000805 FE 03            [ 7] 1368         CP      #CTRLC          ; Is it control "C"?
      000807 CC 98 0C         [17] 1369         CALL    Z,PRNTCRLF      ; Yes - Output CRLF
      00080A 37               [ 4] 1370         SCF                     ; Flag break
      00080B C8               [11] 1371         RET     Z               ; Return if control "C"
      00080C FE 0D            [ 7] 1372         CP      #CR             ; Is it enter?
      00080E CA 93 0C         [10] 1373         JP      Z,ENDINP        ; Yes - Terminate input
      000811 FE 15            [ 7] 1374         CP      #CTRLU          ; Is it control "U"?
      000813 CA D7 07         [10] 1375         JP      Z,KILIN         ; Yes - Get another line
      000816 FE 40            [ 7] 1376         CP      #'@'            ; Is it "kill line"?
      000818 CA D4 07         [10] 1377         JP      Z,OTKLN         ; Yes - Kill line
      00081B FE 5F            [ 7] 1378         CP      #'_'            ; Is it delete?
      00081D CA CC 07         [10] 1379         JP      Z,DELCHR        ; Yes - Delete character
      000820 FE 08            [ 7] 1380         CP      #BKSP           ; Is it backspace?
      000822 CA CC 07         [10] 1381         JP      Z,DELCHR        ; Yes - Delete character
      000825 FE 12            [ 7] 1382         CP      #CTRLR          ; Is it control "R"?
      000827 C2 3E 08         [10] 1383         JP      NZ,PUTBUF       ; No - Put in buffer
      00082A C5               [11] 1384         PUSH    BC              ; Save buffer length
      00082B D5               [11] 1385         PUSH    DE              ; Save DE
      00082C E5               [11] 1386         PUSH    HL              ; Save buffer address
      00082D 36 00            [10] 1387         LD      (HL),#0         ; Mark end of buffer
      00082F CD 49 1E         [17] 1388         CALL    OUTNCR          ; Output and do CRLF
      000832 21 61 23         [10] 1389         LD      HL,#BUFFER      ; Point to buffer start
      000835 CD 36 13         [17] 1390         CALL    PRS             ; Output buffer
      000838 E1               [10] 1391         POP     HL              ; Restore buffer address
      000839 D1               [10] 1392         POP     DE              ; Restore DE
      00083A C1               [10] 1393         POP     BC              ; Restore buffer length
      00083B C3 E6 07         [10] 1394         JP      MORINP          ; Get another character
                                   1395 
      00083E FE 20            [ 7] 1396 PUTBUF: CP      #' '            ; Is it a control code?
      000840 DA E6 07         [10] 1397         JP      C,MORINP        ; Yes - Ignore
      000843 78               [ 4] 1398 PUTCTL: LD      A,B             ; Get number of bytes in buffer
      000844 FE 49            [ 7] 1399         CP      #72+1           ; Test for line overflow
      000846 3E 07            [ 7] 1400         LD      A,#CTRLG        ; Set a bell
      000848 D2 58 08         [10] 1401         JP      NC,OUTNBS       ; Ring bell if buffer full
      00084B 79               [ 4] 1402         LD      A,C             ; Get character
      00084C 71               [ 7] 1403         LD      (HL),C          ; Save in buffer
      00084D 32 CC 23         [13] 1404         LD      (LSTBIN),A      ; Save last input byte
      000850 23               [ 6] 1405         INC     HL              ; Move up buffer
      000851 04               [ 4] 1406         INC     B               ; Increment length
      000852 CD 71 08         [17] 1407 OUTIT:  CALL    OUTC            ; Output the character entered
      000855 C3 E6 07         [10] 1408         JP      MORINP          ; Get another character
                                   1409 
      000858 CD 71 08         [17] 1410 OUTNBS: CALL    OUTC            ; Output bell and back over it
      00085B 3E 08            [ 7] 1411         LD      A,#BKSP         ; Set back space
      00085D C3 52 08         [10] 1412         JP      OUTIT           ; Output it and get more
                                   1413 
      000860 7C               [ 4] 1414 CPDEHL: LD      A,H             ; Get H
      000861 92               [ 4] 1415         SUB     D               ; Compare with D
      000862 C0               [11] 1416         RET     NZ              ; Different - Exit
      000863 7D               [ 4] 1417         LD      A,L             ; Get L
      000864 93               [ 4] 1418         SUB     E               ; Compare with E
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 27.
Hexadecimal [24-Bits]



      000865 C9               [10] 1419         RET                     ; Return status
                                   1420 
      000866 7E               [ 7] 1421 CHKSYN: LD      A,(HL)          ; Check syntax of character
      000867 E3               [19] 1422         EX      (SP),HL         ; Address of test byte
      000868 BE               [ 7] 1423         CP      (HL)            ; Same as in code string?
      000869 23               [ 6] 1424         INC     HL              ; Return address
      00086A E3               [19] 1425         EX      (SP),HL         ; Put it back
      00086B CA F0 09         [10] 1426         JP      Z,GETCHR        ; Yes - Get next character
      00086E C3 98 05         [10] 1427         JP      SNERR           ; Different - ?SN Error
                                   1428 
      000871 F5               [11] 1429 OUTC:   PUSH    AF              ; Save character
      000872 3A 45 23         [13] 1430         LD      A,(CTLOFG)      ; Get control "O" flag
      000875 B7               [ 4] 1431         OR      A               ; Is it set?
      000876 C2 6B 13         [10] 1432         JP      NZ,POPAF        ; Yes - don't output
      000879 F1               [10] 1433         POP     AF              ; Restore character
      00087A C5               [11] 1434         PUSH    BC              ; Save buffer length
      00087B F5               [11] 1435         PUSH    AF              ; Save character
      00087C FE 20            [ 7] 1436         CP      #' '            ; Is it a control code?
      00087E DA 95 08         [10] 1437         JP      C,DINPOS        ; Yes - Don't INC POS(X)
      000881 3A 42 23         [13] 1438         LD      A,(LWIDTH)      ; Get line width
      000884 47               [ 4] 1439         LD      B,A             ; To B
      000885 3A AB 23         [13] 1440         LD      A,(CURPOS)      ; Get cursor position
      000888 04               [ 4] 1441         INC     B               ; Width 255?
      000889 CA 91 08         [10] 1442         JP      Z,INCLEN        ; Yes - No width limit
      00088C 05               [ 4] 1443         DEC     B               ; Restore width
      00088D B8               [ 4] 1444         CP      B               ; At end of line?
      00088E CC 98 0C         [17] 1445         CALL    Z,PRNTCRLF      ; Yes - output CRLF
      000891 3C               [ 4] 1446 INCLEN: INC     A               ; Move on one character
      000892 32 AB 23         [13] 1447         LD      (CURPOS),A      ; Save new position
      000895 F1               [10] 1448 DINPOS: POP     AF              ; Restore character
      000896 C1               [10] 1449         POP     BC              ; Restore buffer length
      000897 CD 31 1E         [17] 1450         CALL    MONOUT          ; Send it
      00089A C9               [10] 1451         RET
                                   1452 
      00089B CD F5 1C         [17] 1453 CLOTST: CALL    GETINP          ; Get input character
      00089E E6 7F            [ 7] 1454         AND     #0b01111111     ; Strip bit 7
      0008A0 FE 0F            [ 7] 1455         CP      #CTRLO          ; Is it control "O"?
      0008A2 C0               [11] 1456         RET     NZ              ; No don't flip flag
      0008A3 3A 45 23         [13] 1457         LD      A,(CTLOFG)      ; Get flag
      0008A6 2F               [ 4] 1458         CPL                     ; Flip it
      0008A7 32 45 23         [13] 1459         LD      (CTLOFG),A      ; Put it back
      0008AA AF               [ 4] 1460         XOR     A               ; Null character
      0008AB C9               [10] 1461         RET
                                   1462 
      0008AC CD BC 0A         [17] 1463 LIST:   CALL    ATOH            ; ASCII number to DE
      0008AF C0               [11] 1464         RET     NZ              ; Return if anything extra
      0008B0 C1               [10] 1465         POP     BC              ; Rubbish - Not needed
      0008B1 CD 84 06         [17] 1466         CALL    SRCHLN          ; Search for line number in DE
      0008B4 C5               [11] 1467         PUSH    BC              ; Save address of line
      0008B5 CD 02 09         [17] 1468         CALL    SETLIN          ; Set up lines counter
      0008B8 E1               [10] 1469 LISTLP: POP     HL              ; Restore address of line
      0008B9 4E               [ 7] 1470         LD      C,(HL)          ; Get LSB of next line
      0008BA 23               [ 6] 1471         INC     HL
      0008BB 46               [ 7] 1472         LD      B,(HL)          ; Get MSB of next line
      0008BC 23               [ 6] 1473         INC     HL
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 28.
Hexadecimal [24-Bits]



      0008BD 78               [ 4] 1474         LD      A,B             ; BC = 0 (End of program)?
      0008BE B1               [ 4] 1475         OR      C
      0008BF CA E3 05         [10] 1476         JP      Z,PRNTOK        ; Yes - Go to command mode
      0008C2 CD 0B 09         [17] 1477         CALL    COUNT           ; Count lines
      0008C5 CD 1B 0A         [17] 1478         CALL    TSTBRK          ; Test for break key
      0008C8 C5               [11] 1479         PUSH    BC              ; Save address of next line
      0008C9 CD 98 0C         [17] 1480         CALL    PRNTCRLF        ; Output CRLF
      0008CC 5E               [ 7] 1481         LD      E,(HL)          ; Get LSB of line number
      0008CD 23               [ 6] 1482         INC     HL
      0008CE 56               [ 7] 1483         LD      D,(HL)          ; Get MSB of line number
      0008CF 23               [ 6] 1484         INC     HL
      0008D0 E5               [11] 1485         PUSH    HL              ; Save address of line start
      0008D1 EB               [ 4] 1486         EX      DE,HL           ; Line number to HL
      0008D2 CD D9 19         [17] 1487         CALL    PRNTHL          ; Output line number in decimal
      0008D5 3E 20            [ 7] 1488         LD      A,#' '          ; Space after line number
      0008D7 E1               [10] 1489         POP     HL              ; Restore start of line address
      0008D8 CD 71 08         [17] 1490 LSTLP2: CALL    OUTC            ; Output character in A
      0008DB 7E               [ 7] 1491 LSTLP3: LD      A,(HL)          ; Get next byte in line
      0008DC B7               [ 4] 1492         OR      A               ; End of line?
      0008DD 23               [ 6] 1493         INC     HL              ; To next byte in line
      0008DE CA B8 08         [10] 1494         JP      Z,LISTLP        ; Yes - get next line
      0008E1 F2 D8 08         [10] 1495         JP      P,LSTLP2        ; No token - output it
      0008E4 D6 7F            [ 7] 1496         SUB     #ZEND-1         ; Find and output word
      0008E6 4F               [ 4] 1497         LD      C,A             ; Token offset+1 to C
      0008E7 11 36 03         [10] 1498         LD      DE,#WORDS       ; Reserved word list
      0008EA 1A               [ 7] 1499 FNDTOK: LD      A,(DE)          ; Get character in list
      0008EB 13               [ 6] 1500         INC     DE              ; Move on to next
      0008EC B7               [ 4] 1501         OR      A               ; Is it start of word?
      0008ED F2 EA 08         [10] 1502         JP      P,FNDTOK        ; No - Keep looking for word
      0008F0 0D               [ 4] 1503         DEC     C               ; Count words
      0008F1 C2 EA 08         [10] 1504         JP      NZ,FNDTOK       ; Not there - keep looking
      0008F4 E6 7F            [ 7] 1505 OUTWRD: AND     #0b01111111     ; Strip bit 7
      0008F6 CD 71 08         [17] 1506         CALL    OUTC            ; Output first character
      0008F9 1A               [ 7] 1507         LD      A,(DE)          ; Get next character
      0008FA 13               [ 6] 1508         INC     DE              ; Move on to next
      0008FB B7               [ 4] 1509         OR      A               ; Is it end of word?
      0008FC F2 F4 08         [10] 1510         JP      P,OUTWRD        ; No - output the rest
      0008FF C3 DB 08         [10] 1511         JP      LSTLP3          ; Next byte in line
                                   1512 
      000902 E5               [11] 1513 SETLIN: PUSH    HL              ; Set up LINES counter
      000903 2A 48 23         [16] 1514         LD      HL,(LINESN)     ; Get LINES number
      000906 22 46 23         [16] 1515         LD      (LINESC),HL     ; Save in LINES counter
      000909 E1               [10] 1516         POP     HL
      00090A C9               [10] 1517         RET
                                   1518 
      00090B E5               [11] 1519 COUNT:  PUSH    HL              ; Save code string address
      00090C D5               [11] 1520         PUSH    DE
      00090D 2A 46 23         [16] 1521         LD      HL,(LINESC)     ; Get LINES counter
      000910 11 FF FF         [10] 1522         LD      DE,#-1
      000913 ED 5A            [15] 1523         ADC     HL,DE           ; Decrement
      000915 22 46 23         [16] 1524         LD      (LINESC),HL     ; Put it back
      000918 D1               [10] 1525         POP     DE
      000919 E1               [10] 1526         POP     HL              ; Restore code string address
      00091A F0               [11] 1527         RET     P               ; Return if more lines to go
      00091B E5               [11] 1528         PUSH    HL              ; Save code string address
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 29.
Hexadecimal [24-Bits]



      00091C 2A 48 23         [16] 1529         LD      HL,(LINESN)     ; Get LINES number
      00091F 22 46 23         [16] 1530         LD      (LINESC),HL     ; Reset LINES counter
      000922 CD F5 1C         [17] 1531         CALL    GETINP          ; Get input character
      000925 FE 03            [ 7] 1532         CP      #CTRLC          ; Is it control "C"?
      000927 CA 2E 09         [10] 1533         JP      Z,RSLNBK        ; Yes - Reset LINES and break
      00092A E1               [10] 1534         POP     HL              ; Restore code string address
      00092B C3 0B 09         [10] 1535         JP      COUNT           ; Keep on counting
                                   1536 
      00092E 2A 48 23         [16] 1537 RSLNBK: LD      HL,(LINESN)     ; Get LINES number
      000931 22 46 23         [16] 1538         LD      (LINESC),HL     ; Reset LINES counter
      000934 C3 A7 02         [10] 1539         JP      BRKRET          ; Go and output "Break"
                                   1540 
      000937 3E 64            [ 7] 1541 FOR:    LD      A,#0x64          ; Flag "FOR" assignment
      000939 32 CB 23         [13] 1542         LD      (FORFLG),A      ; Save "FOR" flag
      00093C CD 9E 0B         [17] 1543         CALL    LET             ; Set up initial index
      00093F C1               [10] 1544         POP     BC              ; Drop RETurn address
      000940 E5               [11] 1545         PUSH    HL              ; Save code string address
      000941 CD 87 0B         [17] 1546         CALL    DATA            ; Get next statement address
      000944 22 C7 23         [16] 1547         LD      (LOOPST),HL     ; Save it for start of loop
      000947 21 02 00         [10] 1548         LD      HL,#2           ; Offset for "FOR" block
      00094A 39               [11] 1549         ADD     HL,SP           ; Point to it
      00094B CD 45 05         [17] 1550 FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
      00094E D1               [10] 1551         POP     DE              ; Get code string address
      00094F C2 67 09         [10] 1552         JP      NZ,FORFND       ; No nesting found
      000952 09               [11] 1553         ADD     HL,BC           ; Move into "FOR" block
      000953 D5               [11] 1554         PUSH    DE              ; Save code string address
      000954 2B               [ 6] 1555         DEC     HL
      000955 56               [ 7] 1556         LD      D,(HL)          ; Get MSB of loop statement
      000956 2B               [ 6] 1557         DEC     HL
      000957 5E               [ 7] 1558         LD      E,(HL)          ; Get LSB of loop statement
      000958 23               [ 6] 1559         INC     HL
      000959 23               [ 6] 1560         INC     HL
      00095A E5               [11] 1561         PUSH    HL              ; Save block address
      00095B 2A C7 23         [16] 1562         LD      HL,(LOOPST)     ; Get address of loop statement
      00095E CD 60 08         [17] 1563         CALL    CPDEHL          ; Compare the FOR loops
      000961 E1               [10] 1564         POP     HL              ; Restore block address
      000962 C2 4B 09         [10] 1565         JP      NZ,FORSLP       ; Different FORs - Find another
      000965 D1               [10] 1566         POP     DE              ; Restore code string address
      000966 F9               [ 6] 1567         LD      SP,HL           ; Remove all nested loops
                                   1568 
      000967 EB               [ 4] 1569 FORFND: EX      DE,HL           ; Code string address to HL
      000968 0E 08            [ 7] 1570         LD      C,#8
      00096A CD 75 05         [17] 1571         CALL    CHKSTK          ; Check for 8 levels of stack
      00096D E5               [11] 1572         PUSH    HL              ; Save code string address
      00096E 2A C7 23         [16] 1573         LD      HL,(LOOPST)     ; Get first statement of loop
      000971 E3               [19] 1574         EX      (SP),HL         ; Save and restore code string
      000972 E5               [11] 1575         PUSH    HL              ; Re-save code string address
      000973 2A 5C 23         [16] 1576         LD      HL,(LINEAT)     ; Get current line number
      000976 E3               [19] 1577         EX      (SP),HL         ; Save and restore code string
      000977 CD 60 0E         [17] 1578         CALL    TSTNUM          ; Make sure it's a number
      00097A CD 66 08         [17] 1579         CALL    CHKSYN          ; Make sure "TO" is next
      00097D A6                    1580         .BYTE   ZTO          ; "TO" token
      00097E CD 5D 0E         [17] 1581         CALL    GETNUM          ; Get "TO" expression value
      000981 E5               [11] 1582         PUSH    HL              ; Save code string address
      000982 CD 8B 18         [17] 1583         CALL    BCDEFP          ; Move "TO" value to BCDE
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 30.
Hexadecimal [24-Bits]



      000985 E1               [10] 1584         POP     HL              ; Restore code string address
      000986 C5               [11] 1585         PUSH    BC              ; Save "TO" value in block
      000987 D5               [11] 1586         PUSH    DE
      000988 01 00 81         [10] 1587         LD      BC,#0x8100      ; BCDE - 1 (default STEP)
      00098B 51               [ 4] 1588         LD      D,C             ; C=0
      00098C 5A               [ 4] 1589         LD      E,D             ; D=0
      00098D 7E               [ 7] 1590         LD      A,(HL)          ; Get next byte in code string
      00098E FE AB            [ 7] 1591         CP      #ZSTEP          ; See if "STEP" is stated
      000990 3E 01            [ 7] 1592         LD      A,#1            ; Sign of step = 1
      000992 C2 A3 09         [10] 1593         JP      NZ,SAVSTP       ; No STEP given - Default to 1
      000995 CD F0 09         [17] 1594         CALL    GETCHR          ; Jump over "STEP" token
      000998 CD 5D 0E         [17] 1595         CALL    GETNUM          ; Get step value
      00099B E5               [11] 1596         PUSH    HL              ; Save code string address
      00099C CD 8B 18         [17] 1597         CALL    BCDEFP          ; Move STEP to BCDE
      00099F CD 3F 18         [17] 1598         CALL    TSTSGN          ; Test sign of FPREG
      0009A2 E1               [10] 1599         POP     HL              ; Restore code string address
      0009A3 C5               [11] 1600 SAVSTP: PUSH    BC              ; Save the STEP value in block
      0009A4 D5               [11] 1601         PUSH    DE
      0009A5 F5               [11] 1602         PUSH    AF              ; Save sign of STEP
      0009A6 33               [ 6] 1603         INC     SP              ; Don't save flags
      0009A7 E5               [11] 1604         PUSH    HL              ; Save code string address
      0009A8 2A CE 23         [16] 1605         LD      HL,(BRKLIN)     ; Get address of index variable
      0009AB E3               [19] 1606         EX      (SP),HL         ; Save and restore code string
      0009AC 06 81            [ 7] 1607 PUTFID: LD      B,#ZFOR         ; "FOR" block marker
      0009AE C5               [11] 1608         PUSH    BC              ; Save it
      0009AF 33               [ 6] 1609         INC     SP              ; Don't save C
                                   1610 
      0009B0 CD 1B 0A         [17] 1611 RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
      0009B3 22 CE 23         [16] 1612         LD      (BRKLIN),HL     ; Save code address for break
      0009B6 7E               [ 7] 1613         LD      A,(HL)          ; Get next byte in code string
      0009B7 FE 3A            [ 7] 1614         CP      #':'            ; Multi statement line?
      0009B9 CA D0 09         [10] 1615         JP      Z,EXCUTE        ; Yes - Execute it
      0009BC B7               [ 4] 1616         OR      A               ; End of line?
      0009BD C2 98 05         [10] 1617         JP      NZ,SNERR        ; No - Syntax error
      0009C0 23               [ 6] 1618         INC     HL              ; Point to address of next line
      0009C1 7E               [ 7] 1619         LD      A,(HL)          ; Get LSB of line pointer
      0009C2 23               [ 6] 1620         INC     HL
      0009C3 B6               [ 7] 1621         OR      (HL)            ; Is it zero (End of prog)?
      0009C4 CA 42 0A         [10] 1622         JP      Z,ENDPRG        ; Yes - Terminate execution
      0009C7 23               [ 6] 1623         INC     HL              ; Point to line number
      0009C8 5E               [ 7] 1624         LD      E,(HL)          ; Get LSB of line number
      0009C9 23               [ 6] 1625         INC     HL
      0009CA 56               [ 7] 1626         LD      D,(HL)          ; Get MSB of line number
      0009CB EB               [ 4] 1627         EX      DE,HL           ; Line number to HL
      0009CC 22 5C 23         [16] 1628         LD      (LINEAT),HL     ; Save as current line number
      0009CF EB               [ 4] 1629         EX      DE,HL           ; Line number back to DE
      0009D0 CD F0 09         [17] 1630 EXCUTE: CALL    GETCHR          ; Get key word
      0009D3 11 B0 09         [10] 1631         LD      DE,#RUNCNT      ; Where to RETurn to
      0009D6 D5               [11] 1632         PUSH    DE              ; Save for RETurn
      0009D7 C8               [11] 1633 IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
      0009D8 D6 80            [ 7] 1634 ONJMP:  SUB     #ZEND           ; Is it a token?
      0009DA DA 9E 0B         [10] 1635         JP      C,LET           ; No - try to assign it
      0009DD FE 25            [ 7] 1636         CP      #ZNEW+1-ZEND    ; END to NEW ?
      0009DF D2 98 05         [10] 1637         JP      NC,SNERR        ; Not a key word - ?SN Error
      0009E2 07               [ 4] 1638         RLCA                    ; Double it
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 31.
Hexadecimal [24-Bits]



      0009E3 4F               [ 4] 1639         LD      C,A             ; BC = Offset into table
      0009E4 06 00            [ 7] 1640         LD      B,#0
      0009E6 EB               [ 4] 1641         EX      DE,HL           ; Save code string address
      0009E7 21 55 04         [10] 1642         LD      HL,#WORDTB      ; Keyword address table
      0009EA 09               [11] 1643         ADD     HL,BC           ; Point to routine address
      0009EB 4E               [ 7] 1644         LD      C,(HL)          ; Get LSB of routine address
      0009EC 23               [ 6] 1645         INC     HL
      0009ED 46               [ 7] 1646         LD      B,(HL)          ; Get MSB of routine address
      0009EE C5               [11] 1647         PUSH    BC              ; Save routine address
      0009EF EB               [ 4] 1648         EX      DE,HL           ; Restore code string address
                                   1649 
      0009F0 23               [ 6] 1650 GETCHR: INC     HL              ; Point to next character
      0009F1 7E               [ 7] 1651         LD      A,(HL)          ; Get next code string byte
      0009F2 FE 3A            [ 7] 1652         CP      #':'            ; Z if ':'
      0009F4 D0               [11] 1653         RET     NC              ; NC if > "9"
      0009F5 FE 20            [ 7] 1654         CP      #' '
      0009F7 CA F0 09         [10] 1655         JP      Z,GETCHR        ; Skip over spaces
      0009FA FE 30            [ 7] 1656         CP      #'0'
      0009FC 3F               [ 4] 1657         CCF                     ; NC if < '0'
      0009FD 3C               [ 4] 1658         INC     A               ; Test for zero - Leave carry
      0009FE 3D               [ 4] 1659         DEC     A               ; Z if Null
      0009FF C9               [10] 1660         RET
                                   1661 
      000A00 EB               [ 4] 1662 RESTOR: EX      DE,HL           ; Save code string address
      000A01 2A 5E 23         [16] 1663         LD      HL,(BASTXT)     ; Point to start of program
      000A04 CA 15 0A         [10] 1664         JP      Z,RESTNL        ; Just RESTORE - reset pointer
      000A07 EB               [ 4] 1665         EX      DE,HL           ; Restore code string address
      000A08 CD BC 0A         [17] 1666         CALL    ATOH            ; Get line number to DE
      000A0B E5               [11] 1667         PUSH    HL              ; Save code string address
      000A0C CD 84 06         [17] 1668         CALL    SRCHLN          ; Search for line number in DE
      000A0F 60               [ 4] 1669         LD      H,B             ; HL = Address of line
      000A10 69               [ 4] 1670         LD      L,C
      000A11 D1               [10] 1671         POP     DE              ; Restore code string address
      000A12 D2 5D 0B         [10] 1672         JP      NC,ULERR        ; ?UL Error if not found
      000A15 2B               [ 6] 1673 RESTNL: DEC     HL              ; Byte before DATA statement
      000A16 22 DC 23         [16] 1674 UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
      000A19 EB               [ 4] 1675         EX      DE,HL           ; Restore code string address
      000A1A C9               [10] 1676         RET
                                   1677 
                                   1678 
      000A1B DF               [11] 1679 TSTBRK: RST     0x18            ; Check input status
      000A1C C8               [11] 1680         RET     Z               ; No key, go back
      000A1D D7               [11] 1681         RST     0x10            ; Get the key into A
      000A1E FE 1B            [ 7] 1682         CP      #ESC            ; Escape key?
      000A20 28 11            [12] 1683         JR      Z,BRK           ; Yes, break
      000A22 FE 03            [ 7] 1684         CP      #CTRLC          ; <Ctrl-C>
      000A24 28 0D            [12] 1685         JR      Z,BRK           ; Yes, break
      000A26 FE 13            [ 7] 1686         CP      #CTRLS          ; Stop scrolling?
      000A28 C0               [11] 1687         RET     NZ              ; Other key, ignore
                                   1688 
                                   1689 
      000A29 D7               [11] 1690 STALL:  RST     0x10            ; Wait for key
      000A2A FE 11            [ 7] 1691         CP      #CTRLQ          ; Resume scrolling?
      000A2C C8               [11] 1692         RET     Z               ; Release the chokehold
      000A2D FE 03            [ 7] 1693         CP      #CTRLC          ; Second break?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 32.
Hexadecimal [24-Bits]



      000A2F 28 07            [12] 1694         JR      Z,STOP          ; Break during hold exits prog
      000A31 18 F6            [12] 1695         JR      STALL           ; Loop until <Ctrl-Q> or <brk>
                                   1696 
      000A33 3E FF            [ 7] 1697 BRK:    LD      A,#0xFF         ; Set BRKFLG
      000A35 32 4D 23         [13] 1698         LD      (BRKFLG),A      ; Store it
                                   1699 
                                   1700 
      000A38 C0               [11] 1701 STOP:   RET     NZ              ; Exit if anything else
      000A39 F6                    1702         .BYTE   0xF6            ; Flag "STOP"
      000A3A C0               [11] 1703 PEND:   RET     NZ              ; Exit if anything else
      000A3B 22 CE 23         [16] 1704         LD      (BRKLIN),HL     ; Save point of break
      000A3E 21                    1705         .BYTE   0x21            ; Skip "OR 11111111B"
      000A3F F6 FF            [ 7] 1706 INPBRK: OR      #0b11111111     ; Flag "Break" wanted
      000A41 C1               [10] 1707         POP     BC              ; Return not needed and more
      000A42 2A 5C 23         [16] 1708 ENDPRG: LD      HL,(LINEAT)     ; Get current line number
      000A45 F5               [11] 1709         PUSH    AF              ; Save STOP / END status
      000A46 7D               [ 4] 1710         LD      A,L             ; Is it direct break?
      000A47 A4               [ 4] 1711         AND     H
      000A48 3C               [ 4] 1712         INC     A               ; Line is -1 if direct break
      000A49 CA 55 0A         [10] 1713         JP      Z,NOLIN         ; Yes - No line number
      000A4C 22 D2 23         [16] 1714         LD      (ERRLIN),HL     ; Save line of break
      000A4F 2A CE 23         [16] 1715         LD      HL,(BRKLIN)     ; Get point of break
      000A52 22 D4 23         [16] 1716         LD      (CONTAD),HL     ; Save point to CONTinue
      000A55 AF               [ 4] 1717 NOLIN:  XOR     A
      000A56 32 45 23         [13] 1718         LD      (CTLOFG),A      ; Enable output
      000A59 CD 8B 0C         [17] 1719         CALL    STTLIN          ; Start a new line
      000A5C F1               [10] 1720         POP     AF              ; Restore STOP / END status
      000A5D 21 3B 05         [10] 1721         LD      HL,#BRKMSG      ; "Break" message
      000A60 C2 CC 05         [10] 1722         JP      NZ,ERRIN        ; "in line" wanted?
      000A63 C3 E3 05         [10] 1723         JP      PRNTOK          ; Go to command mode
                                   1724 
      000A66 2A D4 23         [16] 1725 CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
      000A69 7C               [ 4] 1726         LD      A,H             ; Is it zero?
      000A6A B5               [ 4] 1727         OR      L
      000A6B 1E 20            [ 7] 1728         LD      E,#CN           ; ?CN Error
      000A6D CA AC 05         [10] 1729         JP      Z,ERROR         ; Yes - output "?CN Error"
      000A70 EB               [ 4] 1730         EX      DE,HL           ; Save code string address
      000A71 2A D2 23         [16] 1731         LD      HL,(ERRLIN)     ; Get line of last break
      000A74 22 5C 23         [16] 1732         LD      (LINEAT),HL     ; Set up current line number
      000A77 EB               [ 4] 1733         EX      DE,HL           ; Restore code string address
      000A78 C9               [10] 1734         RET                     ; CONTinue where left off
                                   1735 
      000A79 CD BE 15         [17] 1736 NULL:   CALL    GETINT          ; Get integer 0-255
      000A7C C0               [11] 1737         RET     NZ              ; Return if bad value
      000A7D 32 41 23         [13] 1738         LD      (NULLS),A       ; Set nulls number
      000A80 C9               [10] 1739         RET
                                   1740 
                                   1741 
      000A81 E5               [11] 1742 ACCSUM: PUSH    HL              ; Save address in array
      000A82 2A 4A 23         [16] 1743         LD      HL,(CHKSUM)     ; Get check sum
      000A85 06 00            [ 7] 1744         LD      B,#0            ; BC - Value of byte
      000A87 4F               [ 4] 1745         LD      C,A
      000A88 09               [11] 1746         ADD     HL,BC           ; Add byte to check sum
      000A89 22 4A 23         [16] 1747         LD      (CHKSUM),HL     ; Re-save check sum
      000A8C E1               [10] 1748         POP     HL              ; Restore address in array
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 33.
Hexadecimal [24-Bits]



      000A8D C9               [10] 1749         RET
                                   1750 
      000A8E 7E               [ 7] 1751 CHKLTR: LD      A,(HL)          ; Get byte
      000A8F FE 41            [ 7] 1752         CP      #'A'            ; < 'a' ?
      000A91 D8               [11] 1753         RET     C               ; Carry set if not letter
      000A92 FE 5B            [ 7] 1754         CP      #'Z'+1          ; > 'z' ?
      000A94 3F               [ 4] 1755         CCF
      000A95 C9               [10] 1756         RET                     ; Carry set if not letter
                                   1757 
      000A96 CD F0 09         [17] 1758 FPSINT: CALL    GETCHR          ; Get next character
      000A99 CD 5D 0E         [17] 1759 POSINT: CALL    GETNUM          ; Get integer 0 to 32767
      000A9C CD 3F 18         [17] 1760 DEPINT: CALL    TSTSGN          ; Test sign of FPREG
      000A9F FA B7 0A         [10] 1761         JP      M,FCERR         ; Negative - ?FC Error
      000AA2 3A E7 23         [13] 1762 DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
      000AA5 FE 90            [ 7] 1763         CP      #0x80+16        ; Exponent in range (16 bits)?
      000AA7 DA E7 18         [10] 1764         JP      C,FPINT         ; Yes - convert it
      000AAA 01 80 90         [10] 1765         LD      BC,#0x9080      ; BCDE = -32768
      000AAD 11 00 00         [10] 1766         LD      DE,#0x0000
      000AB0 E5               [11] 1767         PUSH    HL              ; Save code string address
      000AB1 CD BA 18         [17] 1768         CALL    CMPNUM          ; Compare FPREG with BCDE
      000AB4 E1               [10] 1769         POP     HL              ; Restore code string address
      000AB5 51               [ 4] 1770         LD      D,C             ; MSB to D
      000AB6 C8               [11] 1771         RET     Z               ; Return if in range
      000AB7 1E 08            [ 7] 1772 FCERR:  LD      E,#FC           ; ?FC Error
      000AB9 C3 AC 05         [10] 1773         JP      ERROR           ; Output error-
                                   1774 
      000ABC 2B               [ 6] 1775 ATOH:   DEC     HL              ; ASCII number to DE binary
      000ABD 11 00 00         [10] 1776 GETLN:  LD      DE,#0           ; Get number to DE
      000AC0 CD F0 09         [17] 1777 GTLNLP: CALL    GETCHR          ; Get next character
      000AC3 D0               [11] 1778         RET     NC              ; Exit if not a digit
      000AC4 E5               [11] 1779         PUSH    HL              ; Save code string address
      000AC5 F5               [11] 1780         PUSH    AF              ; Save digit
      000AC6 21 98 19         [10] 1781         LD      HL,#65529/10     ; Largest number 65529
      000AC9 CD 60 08         [17] 1782         CALL    CPDEHL          ; Number in range?
      000ACC DA 98 05         [10] 1783         JP      C,SNERR         ; No - ?SN Error
      000ACF 62               [ 4] 1784         LD      H,D             ; HL = Number
      000AD0 6B               [ 4] 1785         LD      L,E
      000AD1 19               [11] 1786         ADD     HL,DE           ; Times 2
      000AD2 29               [11] 1787         ADD     HL,HL           ; Times 4
      000AD3 19               [11] 1788         ADD     HL,DE           ; Times 5
      000AD4 29               [11] 1789         ADD     HL,HL           ; Times 10
      000AD5 F1               [10] 1790         POP     AF              ; Restore digit
      000AD6 D6 30            [ 7] 1791         SUB     #'0'             ; Make it 0 to 9
      000AD8 5F               [ 4] 1792         LD      E,A             ; DE = Value of digit
      000AD9 16 00            [ 7] 1793         LD      D,#0
      000ADB 19               [11] 1794         ADD     HL,DE           ; Add to number
      000ADC EB               [ 4] 1795         EX      DE,HL           ; Number to DE
      000ADD E1               [10] 1796         POP     HL              ; Restore code string address
      000ADE C3 C0 0A         [10] 1797         JP      GTLNLP          ; Go to next character
                                   1798 
      000AE1 CA B4 06         [10] 1799 CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
      000AE4 CD 99 0A         [17] 1800         CALL    POSINT          ; Get integer 0 to 32767 to DE
      000AE7 2B               [ 6] 1801         DEC     HL              ; Cancel increment
      000AE8 CD F0 09         [17] 1802         CALL    GETCHR          ; Get next character
      000AEB E5               [11] 1803         PUSH    HL              ; Save code string address
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 34.
Hexadecimal [24-Bits]



      000AEC 2A AF 23         [16] 1804         LD      HL,(LSTRAM)     ; Get end of RAM
      000AEF CA 04 0B         [10] 1805         JP      Z,STORED        ; No value given - Use stored
      000AF2 E1               [10] 1806         POP     HL              ; Restore code string address
      000AF3 CD 66 08         [17] 1807         CALL    CHKSYN          ; Check for comma
      000AF6 2C                    1808         .BYTE      ','
      000AF7 D5               [11] 1809         PUSH    DE              ; Save number
      000AF8 CD 99 0A         [17] 1810         CALL    POSINT          ; Get integer 0 to 32767
      000AFB 2B               [ 6] 1811         DEC     HL              ; Cancel increment
      000AFC CD F0 09         [17] 1812         CALL    GETCHR          ; Get next character
      000AFF C2 98 05         [10] 1813         JP      NZ,SNERR        ; ?SN Error if more on line
      000B02 E3               [19] 1814         EX      (SP),HL         ; Save code string address
      000B03 EB               [ 4] 1815         EX      DE,HL           ; Number to DE
      000B04 7D               [ 4] 1816 STORED: LD      A,L             ; Get LSB of new RAM top
      000B05 93               [ 4] 1817         SUB     E               ; Subtract LSB of string space
      000B06 5F               [ 4] 1818         LD      E,A             ; Save LSB
      000B07 7C               [ 4] 1819         LD      A,H             ; Get MSB of new RAM top
      000B08 9A               [ 4] 1820         SBC     A,D             ; Subtract MSB of string space
      000B09 57               [ 4] 1821         LD      D,A             ; Save MSB
      000B0A DA 8D 05         [10] 1822         JP      C,OMERR         ; ?OM Error if not enough mem
      000B0D E5               [11] 1823         PUSH    HL              ; Save RAM top
      000B0E 2A D6 23         [16] 1824         LD      HL,(PROGND)     ; Get program end
      000B11 01 28 00         [10] 1825         LD      BC,#40          ; 40 Bytes minimum working RAM
      000B14 09               [11] 1826         ADD     HL,BC           ; Get lowest address
      000B15 CD 60 08         [17] 1827         CALL    CPDEHL          ; Enough memory?
      000B18 D2 8D 05         [10] 1828         JP      NC,OMERR        ; No - ?OM Error
      000B1B EB               [ 4] 1829         EX      DE,HL           ; RAM top to HL
      000B1C 22 5A 23         [16] 1830         LD      (STRSPC),HL     ; Set new string space
      000B1F E1               [10] 1831         POP     HL              ; End of memory to use
      000B20 22 AF 23         [16] 1832         LD      (LSTRAM),HL     ; Set new top of RAM
      000B23 E1               [10] 1833         POP     HL              ; Restore code string address
      000B24 C3 B4 06         [10] 1834         JP      INTVAR          ; Initialise variables
                                   1835 
      000B27 CA B0 06         [10] 1836 RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
      000B2A CD B4 06         [17] 1837         CALL    INTVAR          ; Initialise variables
      000B2D 01 B0 09         [10] 1838         LD      BC,#RUNCNT      ; Execution driver loop
      000B30 C3 43 0B         [10] 1839         JP      RUNLIN          ; RUN from line number
                                   1840 
      000B33 0E 03            [ 7] 1841 GOSUB:  LD      C,#3            ; 3 Levels of stack needed
      000B35 CD 75 05         [17] 1842         CALL    CHKSTK          ; Check for 3 levels of stack
      000B38 C1               [10] 1843         POP     BC              ; Get return address
      000B39 E5               [11] 1844         PUSH    HL              ; Save code string for RETURN
      000B3A E5               [11] 1845         PUSH    HL              ; And for GOSUB routine
      000B3B 2A 5C 23         [16] 1846         LD      HL,(LINEAT)     ; Get current line
      000B3E E3               [19] 1847         EX      (SP),HL         ; Into stack - Code string out
      000B3F 3E 8C            [ 7] 1848         LD      A,#ZGOSUB       ; "GOSUB" token
      000B41 F5               [11] 1849         PUSH    AF              ; Save token
      000B42 33               [ 6] 1850         INC     SP              ; Don't save flags
                                   1851 
      000B43 C5               [11] 1852 RUNLIN: PUSH    BC              ; Save return address
      000B44 CD BC 0A         [17] 1853 GOTO:   CALL    ATOH            ; ASCII number to DE binary
      000B47 CD 89 0B         [17] 1854         CALL    REM             ; Get end of line
      000B4A E5               [11] 1855         PUSH    HL              ; Save end of line
      000B4B 2A 5C 23         [16] 1856         LD      HL,(LINEAT)     ; Get current line
      000B4E CD 60 08         [17] 1857         CALL    CPDEHL          ; Line after current?
      000B51 E1               [10] 1858         POP     HL              ; Restore end of line
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 35.
Hexadecimal [24-Bits]



      000B52 23               [ 6] 1859         INC     HL              ; Start of next line
      000B53 DC 87 06         [17] 1860         CALL    C,SRCHLP        ; Line is after current line
      000B56 D4 84 06         [17] 1861         CALL    NC,SRCHLN       ; Line is before current line
      000B59 60               [ 4] 1862         LD      H,B             ; Set up code string address
      000B5A 69               [ 4] 1863         LD      L,C
      000B5B 2B               [ 6] 1864         DEC     HL              ; Incremented after
      000B5C D8               [11] 1865         RET     C               ; Line found
      000B5D 1E 0E            [ 7] 1866 ULERR:  LD      E,#UL           ; ?UL Error
      000B5F C3 AC 05         [10] 1867         JP      ERROR           ; Output error message
                                   1868 
      000B62 C0               [11] 1869 RETURN: RET     NZ              ; Return if not just RETURN
      000B63 16 FF            [ 7] 1870         LD      D,#-1           ; Flag "GOSUB" search
      000B65 CD 41 05         [17] 1871         CALL    BAKSTK          ; Look "GOSUB" block
      000B68 F9               [ 6] 1872         LD      SP,HL           ; Kill all FORs in subroutine
      000B69 FE 8C            [ 7] 1873         CP      #ZGOSUB         ; Test for "GOSUB" token
      000B6B 1E 04            [ 7] 1874         LD      E,#RG           ; ?RG Error
      000B6D C2 AC 05         [10] 1875         JP      NZ,ERROR        ; Error if no "GOSUB" found
      000B70 E1               [10] 1876         POP     HL              ; Get RETURN line number
      000B71 22 5C 23         [16] 1877         LD      (LINEAT),HL     ; Save as current
      000B74 23               [ 6] 1878         INC     HL              ; Was it from direct statement?
      000B75 7C               [ 4] 1879         LD      A,H
      000B76 B5               [ 4] 1880         OR      L               ; Return to line
      000B77 C2 81 0B         [10] 1881         JP      NZ,RETLIN       ; No - Return to line
      000B7A 3A CC 23         [13] 1882         LD      A,(LSTBIN)      ; Any INPUT in subroutine?
      000B7D B7               [ 4] 1883         OR      A               ; If so buffer is corrupted
      000B7E C2 E2 05         [10] 1884         JP      NZ,POPNOK       ; Yes - Go to command mode
      000B81 21 B0 09         [10] 1885 RETLIN: LD      HL,#RUNCNT      ; Execution driver loop
      000B84 E3               [19] 1886         EX      (SP),HL         ; Into stack - Code string out
      000B85 3E                    1887         .BYTE      0x3E         ; Skip "POP HL"
      000B86 E1               [10] 1888 NXTDTA: POP     HL              ; Restore code string address
                                   1889 
      000B87 01 3A                 1890 DATA:   .BYTE   0x01,0x3A       ; ':' End of statement
      000B89 0E 00            [ 7] 1891 REM:    LD      C,#0            ; 00  End of statement
      000B8B 06 00            [ 7] 1892         LD      B,#0
      000B8D 79               [ 4] 1893 NXTSTL: LD      A,C             ; Statement and byte
      000B8E 48               [ 4] 1894         LD      C,B
      000B8F 47               [ 4] 1895         LD      B,A             ; Statement end byte
      000B90 7E               [ 7] 1896 NXTSTT: LD      A,(HL)          ; Get byte
      000B91 B7               [ 4] 1897         OR      A               ; End of line?
      000B92 C8               [11] 1898         RET     Z               ; Yes - Exit
      000B93 B8               [ 4] 1899         CP      B               ; End of statement?
      000B94 C8               [11] 1900         RET     Z               ; Yes - Exit
      000B95 23               [ 6] 1901         INC     HL              ; Next byte
      000B96 FE 22            [ 7] 1902         CP      #'"'            ; Literal string?
      000B98 CA 8D 0B         [10] 1903         JP      Z,NXTSTL        ; Yes - Look for another '"'
      000B9B C3 90 0B         [10] 1904         JP      NXTSTT          ; Keep looking
                                   1905 
      000B9E CD 53 10         [17] 1906 LET:    CALL    GETVAR          ; Get variable name
      000BA1 CD 66 08         [17] 1907         CALL    CHKSYN          ; Make sure "=" follows
      000BA4 B4                    1908         .BYTE      ZEQUAL          ; "=" token
      000BA5 D5               [11] 1909         PUSH    DE              ; Save address of variable
      000BA6 3A AD 23         [13] 1910         LD      A,(TYPE)        ; Get data type
      000BA9 F5               [11] 1911         PUSH    AF              ; Save type
      000BAA CD 6F 0E         [17] 1912         CALL    EVAL            ; Evaluate expression
      000BAD F1               [10] 1913         POP     AF              ; Restore type
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 36.
Hexadecimal [24-Bits]



      000BAE E3               [19] 1914         EX      (SP),HL         ; Save code - Get var addr
      000BAF 22 CE 23         [16] 1915         LD      (BRKLIN),HL     ; Save address of variable
      000BB2 1F               [ 4] 1916         RRA                     ; Adjust type
      000BB3 CD 62 0E         [17] 1917         CALL    CHKTYP          ; Check types are the same
      000BB6 CA F1 0B         [10] 1918         JP      Z,LETNUM        ; Numeric - Move value
      000BB9 E5               [11] 1919 LETSTR: PUSH    HL              ; Save address of string var
      000BBA 2A E4 23         [16] 1920         LD      HL,(FPREG)      ; Pointer to string entry
      000BBD E5               [11] 1921         PUSH    HL              ; Save it on stack
      000BBE 23               [ 6] 1922         INC     HL              ; Skip over length
      000BBF 23               [ 6] 1923         INC     HL
      000BC0 5E               [ 7] 1924         LD      E,(HL)          ; LSB of string address
      000BC1 23               [ 6] 1925         INC     HL
      000BC2 56               [ 7] 1926         LD      D,(HL)          ; MSB of string address
      000BC3 2A 5E 23         [16] 1927         LD      HL,(BASTXT)     ; Point to start of program
      000BC6 CD 60 08         [17] 1928         CALL    CPDEHL          ; Is string before program?
      000BC9 D2 E0 0B         [10] 1929         JP      NC,CRESTR       ; Yes - Create string entry
      000BCC 2A 5A 23         [16] 1930         LD      HL,(STRSPC)     ; Point to string space
      000BCF CD 60 08         [17] 1931         CALL    CPDEHL          ; Is string literal in program?
      000BD2 D1               [10] 1932         POP     DE              ; Restore address of string
      000BD3 D2 E8 0B         [10] 1933         JP      NC,MVSTPT       ; Yes - Set up pointer
      000BD6 21 BF 23         [10] 1934         LD      HL,#TMPSTR      ; Temporary string pool
      000BD9 CD 60 08         [17] 1935         CALL    CPDEHL          ; Is string in temporary pool?
      000BDC D2 E8 0B         [10] 1936         JP      NC,MVSTPT       ; No - Set up pointer
      000BDF 3E                    1937         .BYTE   0x3E            ; Skip "POP DE"
      000BE0 D1               [10] 1938 CRESTR: POP     DE              ; Restore address of string
      000BE1 CD 97 14         [17] 1939         CALL    BAKTMP          ; Back to last tmp-str entry
      000BE4 EB               [ 4] 1940         EX      DE,HL           ; Address of string entry
      000BE5 CD D0 12         [17] 1941         CALL    SAVSTR          ; Save string in string area
      000BE8 CD 97 14         [17] 1942 MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
      000BEB E1               [10] 1943         POP     HL              ; Get string pointer
      000BEC CD 9A 18         [17] 1944         CALL    DETHL4          ; Move string pointer to var
      000BEF E1               [10] 1945         POP     HL              ; Restore code string address
      000BF0 C9               [10] 1946         RET
                                   1947 
      000BF1 E5               [11] 1948 LETNUM: PUSH    HL              ; Save address of variable
      000BF2 CD 97 18         [17] 1949         CALL    FPTHL           ; Move value to variable
      000BF5 D1               [10] 1950         POP     DE              ; Restore address of variable
      000BF6 E1               [10] 1951         POP     HL              ; Restore code string address
      000BF7 C9               [10] 1952         RET
                                   1953 
      000BF8 CD BE 15         [17] 1954 ON:     CALL    GETINT          ; Get integer 0-255
      000BFB 7E               [ 7] 1955         LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
      000BFC 47               [ 4] 1956         LD      B,A             ; Save in B
      000BFD FE 8C            [ 7] 1957         CP      #ZGOSUB         ; "GOSUB" token?
      000BFF CA 07 0C         [10] 1958         JP      Z,ONGO          ; Yes - Find line number
      000C02 CD 66 08         [17] 1959         CALL    CHKSYN          ; Make sure it's "GOTO"
      000C05 88                    1960         .BYTE   ZGOTO           ; "GOTO" token
      000C06 2B               [ 6] 1961         DEC     HL              ; Cancel increment
      000C07 4B               [ 4] 1962 ONGO:   LD      C,E             ; Integer of branch value
      000C08 0D               [ 4] 1963 ONGOLP: DEC     C               ; Count branches
      000C09 78               [ 4] 1964         LD      A,B             ; Get "GOTO" or "GOSUB" token
      000C0A CA D8 09         [10] 1965         JP      Z,ONJMP         ; Go to that line if right one
      000C0D CD BD 0A         [17] 1966         CALL    GETLN           ; Get line number to DE
      000C10 FE 2C            [ 7] 1967         CP      #','            ; Another line number?
      000C12 C0               [11] 1968         RET     NZ              ; No - Drop through
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 37.
Hexadecimal [24-Bits]



      000C13 C3 08 0C         [10] 1969         JP      ONGOLP          ; Yes - loop
                                   1970 
      000C16 CD 6F 0E         [17] 1971 IF:     CALL    EVAL            ; Evaluate expression
      000C19 7E               [ 7] 1972         LD      A,(HL)          ; Get token
      000C1A FE 88            [ 7] 1973         CP      #ZGOTO          ; "GOTO" token?
      000C1C CA 24 0C         [10] 1974         JP      Z,IFGO          ; Yes - Get line
      000C1F CD 66 08         [17] 1975         CALL    CHKSYN          ; Make sure it's "THEN"
      000C22 A9                    1976         .BYTE      ZTHEN           ; "THEN" token
      000C23 2B               [ 6] 1977         DEC     HL              ; Cancel increment
      000C24 CD 60 0E         [17] 1978 IFGO:   CALL    TSTNUM          ; Make sure it's numeric
      000C27 CD 3F 18         [17] 1979         CALL    TSTSGN          ; Test state of expression
      000C2A CA 89 0B         [10] 1980         JP      Z,REM           ; False - Drop through
      000C2D CD F0 09         [17] 1981         CALL    GETCHR          ; Get next character
      000C30 DA 44 0B         [10] 1982         JP      C,GOTO          ; Number - GOTO that line
      000C33 C3 D7 09         [10] 1983         JP      IFJMP           ; Otherwise do statement
                                   1984 
      000C36 2B               [ 6] 1985 MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
      000C37 CD F0 09         [17] 1986         CALL    GETCHR          ; Get next character
      000C3A CA 98 0C         [10] 1987 PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
      000C3D C8               [11] 1988 PRNTLP: RET     Z               ; End of list - Exit
      000C3E FE A5            [ 7] 1989         CP      #ZTAB           ; "TAB(" token?
      000C40 CA CB 0C         [10] 1990         JP      Z,DOTAB         ; Yes - Do TAB routine
      000C43 FE A8            [ 7] 1991         CP      #ZSPC           ; "SPC(" token?
      000C45 CA CB 0C         [10] 1992         JP      Z,DOTAB         ; Yes - Do SPC routine
      000C48 E5               [11] 1993         PUSH    HL              ; Save code string address
      000C49 FE 2C            [ 7] 1994         CP      #','            ; Comma?
      000C4B CA B4 0C         [10] 1995         JP      Z,DOCOM         ; Yes - Move to next zone
      000C4E FE 3B            [ 7] 1996         CP      #59 ;";"        ; Semi-colon?
      000C50 CA EE 0C         [10] 1997         JP      Z,NEXITM        ; Do semi-colon routine
      000C53 C1               [10] 1998         POP     BC              ; Code string address to BC
      000C54 CD 6F 0E         [17] 1999         CALL    EVAL            ; Evaluate expression
      000C57 E5               [11] 2000         PUSH    HL              ; Save code string address
      000C58 3A AD 23         [13] 2001         LD      A,(TYPE)        ; Get variable type
      000C5B B7               [ 4] 2002         OR      A               ; Is it a string variable?
      000C5C C2 84 0C         [10] 2003         JP      NZ,PRNTST       ; Yes - Output string contents
      000C5F CD E4 19         [17] 2004         CALL    NUMASC          ; Convert number to text
      000C62 CD F4 12         [17] 2005         CALL    CRTST           ; Create temporary string
      000C65 36 20            [10] 2006         LD      (HL),#' '       ; Followed by a space
      000C67 2A E4 23         [16] 2007         LD      HL,(FPREG)      ; Get length of output
      000C6A 34               [11] 2008         INC     (HL)            ; Plus 1 for the space
      000C6B 2A E4 23         [16] 2009         LD      HL,(FPREG)      ; < Not needed >
      000C6E 3A 42 23         [13] 2010         LD      A,(LWIDTH)      ; Get width of line
      000C71 47               [ 4] 2011         LD      B,A             ; To B
      000C72 04               [ 4] 2012         INC     B               ; Width 255 (No limit)?
      000C73 CA 80 0C         [10] 2013         JP      Z,PRNTNB        ; Yes - Output number string
      000C76 04               [ 4] 2014         INC     B               ; Adjust it
      000C77 3A AB 23         [13] 2015         LD      A,(CURPOS)      ; Get cursor position
      000C7A 86               [ 7] 2016         ADD     A,(HL)          ; Add length of string
      000C7B 3D               [ 4] 2017         DEC     A               ; Adjust it
      000C7C B8               [ 4] 2018         CP      B               ; Will output fit on this line?
      000C7D D4 98 0C         [17] 2019         CALL    NC,PRNTCRLF     ; No - CRLF first
      000C80 CD 39 13         [17] 2020 PRNTNB: CALL    PRS1            ; Output string at (HL)
      000C83 AF               [ 4] 2021         XOR     A               ; Skip CALL by setting 'z' flag
      000C84 C4 39 13         [17] 2022 PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
      000C87 E1               [10] 2023         POP     HL              ; Restore code string address
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 38.
Hexadecimal [24-Bits]



      000C88 C3 36 0C         [10] 2024         JP      MRPRNT          ; See if more to PRINT
                                   2025 
      000C8B 3A AB 23         [13] 2026 STTLIN: LD      A,(CURPOS)      ; Make sure on new line
      000C8E B7               [ 4] 2027         OR      A               ; Already at start?
      000C8F C8               [11] 2028         RET     Z               ; Yes - Do nothing
      000C90 C3 98 0C         [10] 2029         JP      PRNTCRLF        ; Start a new line
                                   2030 
      000C93 36 00            [10] 2031 ENDINP: LD      (HL),#0         ; Mark end of buffer
      000C95 21 60 23         [10] 2032         LD      HL,#BUFFER-1    ; Point to buffer
      000C98 3E 0D            [ 7] 2033 PRNTCRLF: LD    A,#CR           ; Load a CR
      000C9A CD 71 08         [17] 2034         CALL    OUTC            ; Output character
      000C9D 3E 0A            [ 7] 2035         LD      A,#LF           ; Load a LF
      000C9F CD 71 08         [17] 2036         CALL    OUTC            ; Output character
      000CA2 AF               [ 4] 2037 DONULL: XOR     A               ; Set to position 0
      000CA3 32 AB 23         [13] 2038         LD      (CURPOS),A      ; Store it
      000CA6 3A 41 23         [13] 2039         LD      A,(NULLS)       ; Get number of nulls
      000CA9 3D               [ 4] 2040 NULLP:  DEC     A               ; Count them
      000CAA C8               [11] 2041         RET     Z               ; Return if done
      000CAB F5               [11] 2042         PUSH    AF              ; Save count
      000CAC AF               [ 4] 2043         XOR     A               ; Load a null
      000CAD CD 71 08         [17] 2044         CALL    OUTC            ; Output it
      000CB0 F1               [10] 2045         POP     AF              ; Restore count
      000CB1 C3 A9 0C         [10] 2046         JP      NULLP           ; Keep counting
                                   2047 
      000CB4 3A 43 23         [13] 2048 DOCOM:  LD      A,(COMMAN)      ; Get comma width
      000CB7 47               [ 4] 2049         LD      B,A             ; Save in B
      000CB8 3A AB 23         [13] 2050         LD      A,(CURPOS)      ; Get current position
      000CBB B8               [ 4] 2051         CP      B               ; Within the limit?
      000CBC D4 98 0C         [17] 2052         CALL    NC,PRNTCRLF     ; No - output CRLF
      000CBF D2 EE 0C         [10] 2053         JP      NC,NEXITM       ; Get next item
      000CC2 D6 0E            [ 7] 2054 ZONELP: SUB     #14             ; Next zone of 14 characters
      000CC4 D2 C2 0C         [10] 2055         JP      NC,ZONELP       ; Repeat if more zones
      000CC7 2F               [ 4] 2056         CPL                     ; Number of spaces to output
      000CC8 C3 E3 0C         [10] 2057         JP      ASPCS           ; Output them
                                   2058 
      000CCB F5               [11] 2059 DOTAB:  PUSH    AF              ; Save token
      000CCC CD BB 15         [17] 2060         CALL    FNDNUM          ; Evaluate expression
      000CCF CD 66 08         [17] 2061         CALL    CHKSYN          ; Make sure ")" follows
      000CD2 29                    2062         .BYTE   ")"
      000CD3 2B               [ 6] 2063         DEC     HL              ; Back space on to ")"
      000CD4 F1               [10] 2064         POP     AF              ; Restore token
      000CD5 D6 A8            [ 7] 2065         SUB     #ZSPC           ; Was it "SPC(" ?
      000CD7 E5               [11] 2066         PUSH    HL              ; Save code string address
      000CD8 CA DE 0C         [10] 2067         JP      Z,DOSPC         ; Yes - Do 'E' spaces
      000CDB 3A AB 23         [13] 2068         LD      A,(CURPOS)      ; Get current position
      000CDE 2F               [ 4] 2069 DOSPC:  CPL                     ; Number of spaces to print to
      000CDF 83               [ 4] 2070         ADD     A,E             ; Total number to print
      000CE0 D2 EE 0C         [10] 2071         JP      NC,NEXITM       ; TAB < Current POS(X)
      000CE3 3C               [ 4] 2072 ASPCS:  INC     A               ; Output A spaces
      000CE4 47               [ 4] 2073         LD      B,A             ; Save number to print
      000CE5 3E 20            [ 7] 2074         LD      A,#' '          ; Space
      000CE7 CD 71 08         [17] 2075 SPCLP:  CALL    OUTC            ; Output character in A
      000CEA 05               [ 4] 2076         DEC     B               ; Count them
      000CEB C2 E7 0C         [10] 2077         JP      NZ,SPCLP        ; Repeat if more
      000CEE E1               [10] 2078 NEXITM: POP     HL              ; Restore code string address
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 39.
Hexadecimal [24-Bits]



      000CEF CD F0 09         [17] 2079         CALL    GETCHR          ; Get next character
      000CF2 C3 3D 0C         [10] 2080         JP      PRNTLP          ; More to print
                                   2081 
      000CF5 3F 52 65 64 6F 20 66  2082 REDO:   .ASCII	"?Redo from start"
             72 6F 6D 20 73 74 61
             72 74
      000D05 0D 0A 00              2083         .DB	CR,LF,0
                                   2084 
      000D08 3A CD 23         [13] 2085 BADINP: LD      A,(READFG)      ; READ or INPUT?
      000D0B B7               [ 4] 2086         OR      A
      000D0C C2 92 05         [10] 2087         JP      NZ,DATSNR       ; READ - ?SN Error
      000D0F C1               [10] 2088         POP     BC              ; Throw away code string addr
      000D10 21 F5 0C         [10] 2089         LD      HL,#REDO        ; "Redo from start" message
      000D13 CD 36 13         [17] 2090         CALL    PRS             ; Output string
      000D16 C3 E3 06         [10] 2091         JP      DOAGN           ; Do last INPUT again
                                   2092 
      000D19 CD A1 12         [17] 2093 INPUT:  CALL    IDTEST          ; Test for illegal direct
      000D1C 7E               [ 7] 2094         LD      A,(HL)          ; Get character after "INPUT"
      000D1D FE 22            [ 7] 2095         CP      #'"'            ; Is there a prompt string?
      000D1F 3E 00            [ 7] 2096         LD      A,#0            ; Clear A and leave flags
      000D21 32 45 23         [13] 2097         LD      (CTLOFG),A      ; Enable output
      000D24 C2 33 0D         [10] 2098         JP      NZ,NOPMPT       ; No prompt - get input
      000D27 CD F5 12         [17] 2099         CALL    QTSTR           ; Get string terminated by '"'
      000D2A CD 66 08         [17] 2100         CALL    CHKSYN          ; Check for ';' after prompt
      000D2D 3B                    2101         .BYTE   ';'
      000D2E E5               [11] 2102         PUSH    HL              ; Save code string address
      000D2F CD 39 13         [17] 2103         CALL    PRS1            ; Output prompt string
      000D32 3E                    2104         .BYTE   0x3E            ; Skip "PUSH HL"
      000D33 E5               [11] 2105 NOPMPT: PUSH    HL              ; Save code string address
      000D34 CD E7 06         [17] 2106         CALL    PROMPT          ; Get input with "? " prompt
      000D37 C1               [10] 2107         POP     BC              ; Restore code string address
      000D38 DA 3F 0A         [10] 2108         JP      C,INPBRK        ; Break pressed - Exit
      000D3B 23               [ 6] 2109         INC     HL              ; Next byte
      000D3C 7E               [ 7] 2110         LD      A,(HL)          ; Get it
      000D3D B7               [ 4] 2111         OR      A               ; End of line?
      000D3E 2B               [ 6] 2112         DEC     HL              ; Back again
      000D3F C5               [11] 2113         PUSH    BC              ; Re-save code string address
      000D40 CA 86 0B         [10] 2114         JP      Z,NXTDTA        ; Yes - Find next DATA stmt
      000D43 36 2C            [10] 2115         LD      (HL),#','       ; Store comma as separator
      000D45 C3 4D 0D         [10] 2116         JP      NXTITM          ; Get next item
                                   2117 
      000D48 E5               [11] 2118 READ:   PUSH    HL              ; Save code string address
      000D49 2A DC 23         [16] 2119         LD      HL,(NXTDAT)     ; Next DATA statement
      000D4C F6                    2120         .BYTE   0xF6            ; Flag "READ"
      000D4D AF               [ 4] 2121 NXTITM: XOR     A               ; Flag "INPUT"
      000D4E 32 CD 23         [13] 2122         LD      (READFG),A      ; Save "READ"/"INPUT" flag
      000D51 E3               [19] 2123         EX      (SP),HL         ; Get code str' , Save pointer
      000D52 C3 59 0D         [10] 2124         JP      GTVLUS          ; Get values
                                   2125 
      000D55 CD 66 08         [17] 2126 NEDMOR: CALL    CHKSYN          ; Check for comma between items
      000D58 2C                    2127         .BYTE   ','
      000D59 CD 53 10         [17] 2128 GTVLUS: CALL    GETVAR          ; Get variable name
      000D5C E3               [19] 2129         EX      (SP),HL         ; Save code str" , Get pointer
      000D5D D5               [11] 2130         PUSH    DE              ; Save variable address
      000D5E 7E               [ 7] 2131         LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 40.
Hexadecimal [24-Bits]



      000D5F FE 2C            [ 7] 2132         CP      #','            ; Comma?
      000D61 CA 81 0D         [10] 2133         JP      Z,ANTVLU        ; Yes - Get another value
      000D64 3A CD 23         [13] 2134         LD      A,(READFG)      ; Is it READ?
      000D67 B7               [ 4] 2135         OR      A
      000D68 C2 EE 0D         [10] 2136         JP      NZ,FDTLP        ; Yes - Find next DATA stmt
      000D6B 3E 3F            [ 7] 2137         LD      A,#'?'          ; More INPUT needed
      000D6D CD 71 08         [17] 2138         CALL    OUTC            ; Output character
      000D70 CD E7 06         [17] 2139         CALL    PROMPT          ; Get INPUT with prompt
      000D73 D1               [10] 2140         POP     DE              ; Variable address
      000D74 C1               [10] 2141         POP     BC              ; Code string address
      000D75 DA 3F 0A         [10] 2142         JP      C,INPBRK        ; Break pressed
      000D78 23               [ 6] 2143         INC     HL              ; Point to next DATA byte
      000D79 7E               [ 7] 2144         LD      A,(HL)          ; Get byte
      000D7A B7               [ 4] 2145         OR      A               ; Is it zero (No input) ?
      000D7B 2B               [ 6] 2146         DEC     HL              ; Back space INPUT pointer
      000D7C C5               [11] 2147         PUSH    BC              ; Save code string address
      000D7D CA 86 0B         [10] 2148         JP      Z,NXTDTA        ; Find end of buffer
      000D80 D5               [11] 2149         PUSH    DE              ; Save variable address
      000D81 3A AD 23         [13] 2150 ANTVLU: LD      A,(TYPE)        ; Check data type
      000D84 B7               [ 4] 2151         OR      A               ; Is it numeric?
      000D85 CA AB 0D         [10] 2152         JP      Z,INPBIN        ; Yes - Convert to binary
      000D88 CD F0 09         [17] 2153         CALL    GETCHR          ; Get next character
      000D8B 57               [ 4] 2154         LD      D,A             ; Save input character
      000D8C 47               [ 4] 2155         LD      B,A             ; Again
      000D8D FE 22            [ 7] 2156         CP      #'"'            ; Start of literal sting?
      000D8F CA 9F 0D         [10] 2157         JP      Z,STRENT        ; Yes - Create string entry
      000D92 3A CD 23         [13] 2158         LD      A,(READFG)      ; "READ" or "INPUT" ?
      000D95 B7               [ 4] 2159         OR      A
      000D96 57               [ 4] 2160         LD      D,A             ; Save 00 if "INPUT"
      000D97 CA 9C 0D         [10] 2161         JP      Z,ITMSEP        ; "INPUT" - End with 00
      000D9A 16 3A            [ 7] 2162         LD      D,#':'          ; "DATA" - End with 00 or ':'
      000D9C 06 2C            [ 7] 2163 ITMSEP: LD      B,#','          ; Item separator
      000D9E 2B               [ 6] 2164         DEC     HL              ; Back space for DTSTR
      000D9F CD F8 12         [17] 2165 STRENT: CALL    DTSTR           ; Get string terminated by D
      000DA2 EB               [ 4] 2166         EX      DE,HL           ; String address to DE
      000DA3 21 B6 0D         [10] 2167         LD      HL,#LTSTND      ; Where to go after LETSTR
      000DA6 E3               [19] 2168         EX      (SP),HL         ; Save HL , get input pointer
      000DA7 D5               [11] 2169         PUSH    DE              ; Save address of string
      000DA8 C3 B9 0B         [10] 2170         JP      LETSTR          ; Assign string to variable
                                   2171 
      000DAB CD F0 09         [17] 2172 INPBIN: CALL    GETCHR          ; Get next character
      000DAE CD 46 19         [17] 2173         CALL    ASCTFP          ; Convert ASCII to FP number
      000DB1 E3               [19] 2174         EX      (SP),HL         ; Save input ptr, Get var addr
      000DB2 CD 97 18         [17] 2175         CALL    FPTHL           ; Move FPREG to variable
      000DB5 E1               [10] 2176         POP     HL              ; Restore input pointer
      000DB6 2B               [ 6] 2177 LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
      000DB7 CD F0 09         [17] 2178         CALL    GETCHR          ; Get next character
      000DBA CA C2 0D         [10] 2179         JP      Z,MORDT         ; End of line - More needed?
      000DBD FE 2C            [ 7] 2180         CP      #','            ; Another value?
      000DBF C2 08 0D         [10] 2181         JP      NZ,BADINP       ; No - Bad input
      000DC2 E3               [19] 2182 MORDT:  EX      (SP),HL         ; Get code string address
      000DC3 2B               [ 6] 2183         DEC     HL              ; DEC 'cos GETCHR INCs
      000DC4 CD F0 09         [17] 2184         CALL    GETCHR          ; Get next character
      000DC7 C2 55 0D         [10] 2185         JP      NZ,NEDMOR       ; More needed - Get it
      000DCA D1               [10] 2186         POP     DE              ; Restore DATA pointer
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 41.
Hexadecimal [24-Bits]



      000DCB 3A CD 23         [13] 2187         LD      A,(READFG)      ; "READ" or "INPUT" ?
      000DCE B7               [ 4] 2188         OR      A
      000DCF EB               [ 4] 2189         EX      DE,HL           ; DATA pointer to HL
      000DD0 C2 16 0A         [10] 2190         JP      NZ,UPDATA       ; Update DATA pointer if "READ"
      000DD3 D5               [11] 2191         PUSH    DE              ; Save code string address
      000DD4 B6               [ 7] 2192         OR      (HL)            ; More input given?
      000DD5 21 DD 0D         [10] 2193         LD      HL,#EXTIG       ; "?Extra ignored" message
      000DD8 C4 36 13         [17] 2194         CALL    NZ,PRS          ; Output string if extra given
      000DDB E1               [10] 2195         POP     HL              ; Restore code string address
      000DDC C9               [10] 2196         RET
                                   2197 
      000DDD 3F 45 78 74 72 61 20  2198 EXTIG:  .ASCII	"?Extra ignored"
             69 67 6E 6F 72 65 64
      000DEB 0D 0A 00              2199 	.DB	CR,LF,0
                                   2200 
      000DEE CD 87 0B         [17] 2201 FDTLP:  CALL    DATA            ; Get next statement
      000DF1 B7               [ 4] 2202         OR      A               ; End of line?
      000DF2 C2 07 0E         [10] 2203         JP      NZ,FANDT        ; No - See if DATA statement
      000DF5 23               [ 6] 2204         INC     HL
      000DF6 7E               [ 7] 2205         LD      A,(HL)          ; End of program?
      000DF7 23               [ 6] 2206         INC     HL
      000DF8 B6               [ 7] 2207         OR      (HL)            ; 00 00 Ends program
      000DF9 1E 06            [ 7] 2208         LD      E,#OD           ; ?OD Error
      000DFB CA AC 05         [10] 2209         JP      Z,ERROR         ; Yes - Out of DATA
      000DFE 23               [ 6] 2210         INC     HL
      000DFF 5E               [ 7] 2211         LD      E,(HL)          ; LSB of line number
      000E00 23               [ 6] 2212         INC     HL
      000E01 56               [ 7] 2213         LD      D,(HL)          ; MSB of line number
      000E02 EB               [ 4] 2214         EX      DE,HL
      000E03 22 C9 23         [16] 2215         LD      (DATLIN),HL     ; Set line of current DATA item
      000E06 EB               [ 4] 2216         EX      DE,HL
      000E07 CD F0 09         [17] 2217 FANDT:  CALL    GETCHR          ; Get next character
      000E0A FE 83            [ 7] 2218         CP      #ZDATA          ; "DATA" token
      000E0C C2 EE 0D         [10] 2219         JP      NZ,FDTLP        ; No "DATA" - Keep looking
      000E0F C3 81 0D         [10] 2220         JP      ANTVLU          ; Found - Convert input
                                   2221 
      000E12 11 00 00         [10] 2222 NEXT:   LD      DE,#0           ; In case no index given
      000E15 C4 53 10         [17] 2223 NEXT1:  CALL    NZ,GETVAR       ; Get index address
      000E18 22 CE 23         [16] 2224         LD      (BRKLIN),HL     ; Save code string address
      000E1B CD 41 05         [17] 2225         CALL    BAKSTK          ; Look for "FOR" block
      000E1E C2 9E 05         [10] 2226         JP      NZ,NFERR        ; No "FOR" - ?NF Error
      000E21 F9               [ 6] 2227         LD      SP,HL           ; Clear nested loops
      000E22 D5               [11] 2228         PUSH    DE              ; Save index address
      000E23 7E               [ 7] 2229         LD      A,(HL)          ; Get sign of STEP
      000E24 23               [ 6] 2230         INC     HL
      000E25 F5               [11] 2231         PUSH    AF              ; Save sign of STEP
      000E26 D5               [11] 2232         PUSH    DE              ; Save index address
      000E27 CD 7D 18         [17] 2233         CALL    PHLTFP          ; Move index value to FPREG
      000E2A E3               [19] 2234         EX      (SP),HL         ; Save address of TO value
      000E2B E5               [11] 2235         PUSH    HL              ; Save address of index
      000E2C CD EA 15         [17] 2236         CALL    ADDPHL          ; Add STEP to index value
      000E2F E1               [10] 2237         POP     HL              ; Restore address of index
      000E30 CD 97 18         [17] 2238         CALL    FPTHL           ; Move value to index variable
      000E33 E1               [10] 2239         POP     HL              ; Restore address of TO value
      000E34 CD 8E 18         [17] 2240         CALL    LOADFP          ; Move TO value to BCDE
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 42.
Hexadecimal [24-Bits]



      000E37 E5               [11] 2241         PUSH    HL              ; Save address of line of FOR
      000E38 CD BA 18         [17] 2242         CALL    CMPNUM          ; Compare index with TO value
      000E3B E1               [10] 2243         POP     HL              ; Restore address of line num
      000E3C C1               [10] 2244         POP     BC              ; Address of sign of STEP
      000E3D 90               [ 4] 2245         SUB     B               ; Compare with expected sign
      000E3E CD 8E 18         [17] 2246         CALL    LOADFP          ; BC = Loop stmt,DE = Line num
      000E41 CA 4D 0E         [10] 2247         JP      Z,KILFOR        ; Loop finished - Terminate it
      000E44 EB               [ 4] 2248         EX      DE,HL           ; Loop statement line number
      000E45 22 5C 23         [16] 2249         LD      (LINEAT),HL     ; Set loop line number
      000E48 69               [ 4] 2250         LD      L,C             ; Set code string to loop
      000E49 60               [ 4] 2251         LD      H,B
      000E4A C3 AC 09         [10] 2252         JP      PUTFID          ; Put back "FOR" and continue
                                   2253 
      000E4D F9               [ 6] 2254 KILFOR: LD      SP,HL           ; Remove "FOR" block
      000E4E 2A CE 23         [16] 2255         LD      HL,(BRKLIN)     ; Code string after "NEXT"
      000E51 7E               [ 7] 2256         LD      A,(HL)          ; Get next byte in code string
      000E52 FE 2C            [ 7] 2257         CP      #','            ; More NEXTs ?
      000E54 C2 B0 09         [10] 2258         JP      NZ,RUNCNT       ; No - Do next statement
      000E57 CD F0 09         [17] 2259         CALL    GETCHR          ; Position to index name
      000E5A CD 15 0E         [17] 2260         CALL    NEXT1           ; Re-enter NEXT routine
                                   2261 ; < will not RETurn to here , Exit to RUNCNT or Loop >
                                   2262 
      000E5D CD 6F 0E         [17] 2263 GETNUM: CALL    EVAL            ; Get a numeric expression
      000E60 F6                    2264 TSTNUM: .BYTE	0xF6            ; Clear carry (numeric)
      000E61 37               [ 4] 2265 TSTSTR: SCF                     ; Set carry (string)
      000E62 3A AD 23         [13] 2266 CHKTYP: LD      A,(TYPE)        ; Check types match
      000E65 8F               [ 4] 2267         ADC     A,A             ; Expected + actual
      000E66 B7               [ 4] 2268         OR      A               ; Clear carry , set parity
      000E67 E8               [11] 2269         RET     PE              ; Even parity - Types match
      000E68 C3 AA 05         [10] 2270         JP      TMERR           ; Different types - Error
                                   2271 
      000E6B CD 66 08         [17] 2272 OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
      000E6E 28                    2273         .BYTE   "("
      000E6F 2B               [ 6] 2274 EVAL:   DEC     HL              ; Evaluate expression & save
      000E70 16 00            [ 7] 2275         LD      D,#0            ; Precedence value
      000E72 D5               [11] 2276 EVAL1:  PUSH    DE              ; Save precedence
      000E73 0E 01            [ 7] 2277         LD      C,#1
      000E75 CD 75 05         [17] 2278         CALL    CHKSTK          ; Check for 1 level of stack
      000E78 CD E6 0E         [17] 2279         CALL    OPRND           ; Get next expression value
      000E7B 22 D0 23         [16] 2280 EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
      000E7E 2A D0 23         [16] 2281 EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
      000E81 C1               [10] 2282         POP     BC              ; Precedence value and operator
      000E82 78               [ 4] 2283         LD      A,B             ; Get precedence value
      000E83 FE 78            [ 7] 2284         CP      #0x78           ; "AND" or "OR" ?
      000E85 D4 60 0E         [17] 2285         CALL    NC,TSTNUM       ; No - Make sure it's a number
      000E88 7E               [ 7] 2286         LD      A,(HL)          ; Get next operator / function
      000E89 16 00            [ 7] 2287         LD      D,#0            ; Clear Last relation
      000E8B D6 B3            [ 7] 2288 RLTLP:  SUB     #ZGTR           ; ">" Token
      000E8D DA A7 0E         [10] 2289         JP      C,FOPRND        ; + - * / ^ AND OR - Test it
      000E90 FE 03            [ 7] 2290         CP      #ZLTH+1-ZGTR    ; < = >
      000E92 D2 A7 0E         [10] 2291         JP      NC,FOPRND       ; Function - Call it
      000E95 FE 01            [ 7] 2292         CP      #ZEQUAL-ZGTR    ; "="
      000E97 17               [ 4] 2293         RLA                     ; <- Test for legal
      000E98 AA               [ 4] 2294         XOR     D               ; <- combinations of < = >
      000E99 BA               [ 4] 2295         CP      D               ; <- by combining last token
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 43.
Hexadecimal [24-Bits]



      000E9A 57               [ 4] 2296         LD      D,A             ; <- with current one
      000E9B DA 98 05         [10] 2297         JP      C,SNERR         ; Error if "<<' '==" or ">>"
      000E9E 22 C5 23         [16] 2298         LD      (CUROPR),HL     ; Save address of current token
      000EA1 CD F0 09         [17] 2299         CALL    GETCHR          ; Get next character
      000EA4 C3 8B 0E         [10] 2300         JP      RLTLP           ; Treat the two as one
                                   2301 
      000EA7 7A               [ 4] 2302 FOPRND: LD      A,D             ; < = > found ?
      000EA8 B7               [ 4] 2303         OR      A
      000EA9 C2 CE 0F         [10] 2304         JP      NZ,TSTRED       ; Yes - Test for reduction
      000EAC 7E               [ 7] 2305         LD      A,(HL)          ; Get operator token
      000EAD 22 C5 23         [16] 2306         LD      (CUROPR),HL     ; Save operator address
      000EB0 D6 AC            [ 7] 2307         SUB     #ZPLUS          ; Operator or function?
      000EB2 D8               [11] 2308         RET     C               ; Neither - Exit
      000EB3 FE 07            [ 7] 2309         CP      #ZOR+1-ZPLUS    ; Is it + - * / ^ AND OR ?
      000EB5 D0               [11] 2310         RET     NC              ; No - Exit
      000EB6 5F               [ 4] 2311         LD      E,A             ; Coded operator
      000EB7 3A AD 23         [13] 2312         LD      A,(TYPE)        ; Get data type
      000EBA 3D               [ 4] 2313         DEC     A               ; FF = numeric , 00 = string
      000EBB B3               [ 4] 2314         OR      E               ; Combine with coded operator
      000EBC 7B               [ 4] 2315         LD      A,E             ; Get coded operator
      000EBD CA 2C 14         [10] 2316         JP      Z,CONCAT        ; String concatenation
      000EC0 07               [ 4] 2317         RLCA                    ; Times 2
      000EC1 83               [ 4] 2318         ADD     A,E             ; Times 3
      000EC2 5F               [ 4] 2319         LD      E,A             ; To DE (D is 0)
      000EC3 21 9F 04         [10] 2320         LD      HL,#PRITAB      ; Precedence table
      000EC6 19               [11] 2321         ADD     HL,DE           ; To the operator concerned
      000EC7 78               [ 4] 2322         LD      A,B             ; Last operator precedence
      000EC8 56               [ 7] 2323         LD      D,(HL)          ; Get evaluation precedence
      000EC9 BA               [ 4] 2324         CP      D               ; Compare with eval precedence
      000ECA D0               [11] 2325         RET     NC              ; Exit if higher precedence
      000ECB 23               [ 6] 2326         INC     HL              ; Point to routine address
      000ECC CD 60 0E         [17] 2327         CALL    TSTNUM          ; Make sure it's a number
                                   2328 
      000ECF C5               [11] 2329 STKTHS: PUSH    BC              ; Save last precedence & token
      000ED0 01 7E 0E         [10] 2330         LD      BC,#EVAL3       ; Where to go on prec' break
      000ED3 C5               [11] 2331         PUSH    BC              ; Save on stack for return
      000ED4 43               [ 4] 2332         LD      B,E             ; Save operator
      000ED5 4A               [ 4] 2333         LD      C,D             ; Save precedence
      000ED6 CD 70 18         [17] 2334         CALL    STAKFP          ; Move value to stack
      000ED9 58               [ 4] 2335         LD      E,B             ; Restore operator
      000EDA 51               [ 4] 2336         LD      D,C             ; Restore precedence
      000EDB 4E               [ 7] 2337         LD      C,(HL)          ; Get LSB of routine address
      000EDC 23               [ 6] 2338         INC     HL
      000EDD 46               [ 7] 2339         LD      B,(HL)          ; Get MSB of routine address
      000EDE 23               [ 6] 2340         INC     HL
      000EDF C5               [11] 2341         PUSH    BC              ; Save routine address
      000EE0 2A C5 23         [16] 2342         LD      HL,(CUROPR)     ; Address of current operator
      000EE3 C3 72 0E         [10] 2343         JP      EVAL1           ; Loop until prec' break
                                   2344 
      000EE6 AF               [ 4] 2345 OPRND:  XOR     A               ; Get operand routine
      000EE7 32 AD 23         [13] 2346         LD      (TYPE),A        ; Set numeric expected
      000EEA CD F0 09         [17] 2347         CALL    GETCHR          ; Get next character
      000EED 1E 24            [ 7] 2348         LD      E,#MO           ; ?MO Error
      000EEF CA AC 05         [10] 2349         JP      Z,ERROR         ; No operand - Error
      000EF2 DA 46 19         [10] 2350         JP      C,ASCTFP        ; Number - Get value
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 44.
Hexadecimal [24-Bits]



      000EF5 CD 8E 0A         [17] 2351         CALL    CHKLTR          ; See if a letter
      000EF8 D2 4D 0F         [10] 2352         JP      NC,CONVAR       ; Letter - Find variable
      000EFB FE 26            [ 7] 2353         CP	#'&'		; &H = HEX, &B = BINARY
      000EFD 20 12            [12] 2354         JR	NZ, NOTAMP
      000EFF CD F0 09         [17] 2355         CALL    GETCHR          ; Get next character
      000F02 FE 48            [ 7] 2356         CP      #'H'            ; Hex number indicated? [function added]
      000F04 CA 8A 1D         [10] 2357         JP      Z,HEXTFP        ; Convert Hex to FPREG
      000F07 FE 42            [ 7] 2358         CP      #'B'            ; Binary number indicated? [function added]
      000F09 CA FA 1D         [10] 2359         JP      Z,BINTFP        ; Convert Bin to FPREG
      000F0C 1E 02            [ 7] 2360         LD      E,#SN           ; If neither then a ?SN Error
      000F0E CA AC 05         [10] 2361         JP      Z,ERROR         ; 
      000F11 FE AC            [ 7] 2362 NOTAMP: CP      #ZPLUS          ; '+' Token ?
      000F13 CA E6 0E         [10] 2363         JP      Z,OPRND         ; Yes - Look for operand
      000F16 FE 2E            [ 7] 2364         CP      #'.'            ; '.' ?
      000F18 CA 46 19         [10] 2365         JP      Z,ASCTFP        ; Yes - Create FP number
      000F1B FE AD            [ 7] 2366         CP      #ZMINUS         ; '-' Token ?
      000F1D CA 3C 0F         [10] 2367         JP      Z,MINUS         ; Yes - Do minus
      000F20 FE 22            [ 7] 2368         CP      #'"'            ; Literal string ?
      000F22 CA F5 12         [10] 2369         JP      Z,QTSTR         ; Get string terminated by '"'
      000F25 FE AA            [ 7] 2370         CP      #ZNOT           ; "NOT" Token ?
      000F27 CA 2E 10         [10] 2371         JP      Z,EVNOT         ; Yes - Eval NOT expression
      000F2A FE A7            [ 7] 2372         CP      #ZFN            ; "FN" Token ?
      000F2C CA 59 12         [10] 2373         JP      Z,DOFN          ; Yes - Do FN routine
      000F2F D6 B6            [ 7] 2374         SUB     #ZSGN           ; Is it a function?
      000F31 D2 5E 0F         [10] 2375         JP      NC,FNOFST       ; Yes - Evaluate function
      000F34 CD 6B 0E         [17] 2376 EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
      000F37 CD 66 08         [17] 2377         CALL    CHKSYN          ; Make sure ")" follows
      000F3A 29                    2378         .BYTE   ")"
      000F3B C9               [10] 2379         RET
                                   2380 
      000F3C 16 7D            [ 7] 2381 MINUS:  LD      D,#0x7D         ; '-' precedence
      000F3E CD 72 0E         [17] 2382         CALL    EVAL1           ; Evaluate until prec' break
      000F41 2A D0 23         [16] 2383         LD      HL,(NXTOPR)     ; Get next operator address
      000F44 E5               [11] 2384         PUSH    HL              ; Save next operator address
      000F45 CD 68 18         [17] 2385         CALL    INVSGN          ; Negate value
      000F48 CD 60 0E         [17] 2386 RETNUM: CALL    TSTNUM          ; Make sure it's a number
      000F4B E1               [10] 2387         POP     HL              ; Restore next operator address
      000F4C C9               [10] 2388         RET
                                   2389 
      000F4D CD 53 10         [17] 2390 CONVAR: CALL    GETVAR          ; Get variable address to DE
      000F50 E5               [11] 2391 FRMEVL: PUSH    HL              ; Save code string address
      000F51 EB               [ 4] 2392         EX      DE,HL           ; Variable address to HL
      000F52 22 E4 23         [16] 2393         LD      (FPREG),HL      ; Save address of variable
      000F55 3A AD 23         [13] 2394         LD      A,(TYPE)        ; Get type
      000F58 B7               [ 4] 2395         OR      A               ; Numeric?
      000F59 CC 7D 18         [17] 2396         CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
      000F5C E1               [10] 2397         POP     HL              ; Restore code string address
      000F5D C9               [10] 2398         RET
                                   2399 
      000F5E 06 00            [ 7] 2400 FNOFST: LD      B,#0            ; Get address of function
      000F60 07               [ 4] 2401         RLCA                    ; Double function offset
      000F61 4F               [ 4] 2402         LD      C,A             ; BC = Offset in function table
      000F62 C5               [11] 2403         PUSH    BC              ; Save adjusted token value
      000F63 CD F0 09         [17] 2404         CALL    GETCHR          ; Get next character
      000F66 79               [ 4] 2405         LD      A,C             ; Get adjusted token value
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 45.
Hexadecimal [24-Bits]



      000F67 FE 31            [ 7] 2406         CP      #2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
      000F69 DA 85 0F         [10] 2407         JP      C,FNVAL         ; No - Do function
      000F6C CD 6B 0E         [17] 2408         CALL    OPNPAR          ; Evaluate expression  (X,...
      000F6F CD 66 08         [17] 2409         CALL    CHKSYN          ; Make sure ',' follows
      000F72 2C                    2410         .BYTE      ','
      000F73 CD 61 0E         [17] 2411         CALL    TSTSTR          ; Make sure it's a string
      000F76 EB               [ 4] 2412         EX      DE,HL           ; Save code string address
      000F77 2A E4 23         [16] 2413         LD      HL,(FPREG)      ; Get address of string
      000F7A E3               [19] 2414         EX      (SP),HL         ; Save address of string
      000F7B E5               [11] 2415         PUSH    HL              ; Save adjusted token value
      000F7C EB               [ 4] 2416         EX      DE,HL           ; Restore code string address
      000F7D CD BE 15         [17] 2417         CALL    GETINT          ; Get integer 0-255
      000F80 EB               [ 4] 2418         EX      DE,HL           ; Save code string address
      000F81 E3               [19] 2419         EX      (SP),HL         ; Save integer,HL = adj' token
      000F82 C3 8D 0F         [10] 2420         JP      GOFUNC          ; Jump to string function
                                   2421 
      000F85 CD 34 0F         [17] 2422 FNVAL:  CALL    EVLPAR          ; Evaluate expression
      000F88 E3               [19] 2423         EX      (SP),HL         ; HL = Adjusted token value
      000F89 11 48 0F         [10] 2424         LD      DE,#RETNUM      ; Return number from function
      000F8C D5               [11] 2425         PUSH    DE              ; Save on stack
      000F8D 01 FE 02         [10] 2426 GOFUNC: LD      BC,#FNCTAB      ; Function routine addresses
      000F90 09               [11] 2427         ADD     HL,BC           ; Point to right address
      000F91 4E               [ 7] 2428         LD      C,(HL)          ; Get LSB of address
      000F92 23               [ 6] 2429         INC     HL              ;
      000F93 66               [ 7] 2430         LD      H,(HL)          ; Get MSB of address
      000F94 69               [ 4] 2431         LD      L,C             ; Address to HL
      000F95 E9               [ 4] 2432         JP      (HL)            ; Jump to function
                                   2433 
      000F96 15               [ 4] 2434 SGNEXP: DEC     D               ; Dee to flag negative exponent
      000F97 FE AD            [ 7] 2435         CP      #ZMINUS         ; '-' token ?
      000F99 C8               [11] 2436         RET     Z               ; Yes - Return
      000F9A FE 2D            [ 7] 2437         CP      #'-'            ; '-' ASCII ?
      000F9C C8               [11] 2438         RET     Z               ; Yes - Return
      000F9D 14               [ 4] 2439         INC     D               ; Inc to flag positive exponent
      000F9E FE 2B            [ 7] 2440         CP      #'+'            ; '+' ASCII ?
      000FA0 C8               [11] 2441         RET     Z               ; Yes - Return
      000FA1 FE AC            [ 7] 2442         CP      #ZPLUS          ; '+' token ?
      000FA3 C8               [11] 2443         RET     Z               ; Yes - Return
      000FA4 2B               [ 6] 2444         DEC     HL              ; DEC 'cos GETCHR INCs
      000FA5 C9               [10] 2445         RET                     ; Return "NZ"
                                   2446 
      000FA6 F6                    2447 POR:    .BYTE   0xF6            ; Flag "OR"
      000FA7 AF               [ 4] 2448 PAND:   XOR     A               ; Flag "AND"
      000FA8 F5               [11] 2449         PUSH    AF              ; Save "AND" / "OR" flag
      000FA9 CD 60 0E         [17] 2450         CALL    TSTNUM          ; Make sure it's a number
      000FAC CD A2 0A         [17] 2451         CALL    DEINT           ; Get integer -32768 to 32767
      000FAF F1               [10] 2452         POP     AF              ; Restore "AND" / "OR" flag
      000FB0 EB               [ 4] 2453         EX      DE,HL           ; <- Get last
      000FB1 C1               [10] 2454         POP     BC              ; <-  value
      000FB2 E3               [19] 2455         EX      (SP),HL         ; <-  from
      000FB3 EB               [ 4] 2456         EX      DE,HL           ; <-  stack
      000FB4 CD 80 18         [17] 2457         CALL    FPBCDE          ; Move last value to FPREG
      000FB7 F5               [11] 2458         PUSH    AF              ; Save "AND" / "OR" flag
      000FB8 CD A2 0A         [17] 2459         CALL    DEINT           ; Get integer -32768 to 32767
      000FBB F1               [10] 2460         POP     AF              ; Restore "AND" / "OR" flag
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 46.
Hexadecimal [24-Bits]



      000FBC C1               [10] 2461         POP     BC              ; Get value
      000FBD 79               [ 4] 2462         LD      A,C             ; Get LSB
      000FBE 21 17 12         [10] 2463         LD      HL,#ACPASS      ; Address of save AC as current
      000FC1 C2 C9 0F         [10] 2464         JP      NZ,POR1         ; Jump if OR
      000FC4 A3               [ 4] 2465         AND     E               ; "AND" LSBs
      000FC5 4F               [ 4] 2466         LD      C,A             ; Save LSB
      000FC6 78               [ 4] 2467         LD      A,B             ; Get MBS
      000FC7 A2               [ 4] 2468         AND     D               ; "AND" MSBs
      000FC8 E9               [ 4] 2469         JP      (HL)            ; Save AC as current (ACPASS)
                                   2470 
      000FC9 B3               [ 4] 2471 POR1:   OR      E               ; "OR" LSBs
      000FCA 4F               [ 4] 2472         LD      C,A             ; Save LSB
      000FCB 78               [ 4] 2473         LD      A,B             ; Get MSB
      000FCC B2               [ 4] 2474         OR      D               ; "OR" MSBs
      000FCD E9               [ 4] 2475         JP      (HL)            ; Save AC as current (ACPASS)
                                   2476 
      000FCE 21 E0 0F         [10] 2477 TSTRED: LD      HL,#CMPLOG      ; Logical compare routine
      000FD1 3A AD 23         [13] 2478         LD      A,(TYPE)        ; Get data type
      000FD4 1F               [ 4] 2479         RRA                     ; Carry set = string
      000FD5 7A               [ 4] 2480         LD      A,D             ; Get last precedence value
      000FD6 17               [ 4] 2481         RLA                     ; Times 2 plus carry
      000FD7 5F               [ 4] 2482         LD      E,A             ; To E
      000FD8 16 64            [ 7] 2483         LD      D,#0x64         ; Relational precedence
      000FDA 78               [ 4] 2484         LD      A,B             ; Get current precedence
      000FDB BA               [ 4] 2485         CP      D               ; Compare with last
      000FDC D0               [11] 2486         RET     NC              ; Eval if last was rel' or log'
      000FDD C3 CF 0E         [10] 2487         JP      STKTHS          ; Stack this one and get next
                                   2488 
      000FE0 E2 0F                 2489 CMPLOG: .WORD   CMPLG1          ; Compare two values / strings
      000FE2 79               [ 4] 2490 CMPLG1: LD      A,C             ; Get data type
      000FE3 B7               [ 4] 2491         OR      A
      000FE4 1F               [ 4] 2492         RRA
      000FE5 C1               [10] 2493         POP     BC              ; Get last expression to BCDE
      000FE6 D1               [10] 2494         POP     DE
      000FE7 F5               [11] 2495         PUSH    AF              ; Save status
      000FE8 CD 62 0E         [17] 2496         CALL    CHKTYP          ; Check that types match
      000FEB 21 24 10         [10] 2497         LD      HL,#CMPRES      ; Result to comparison
      000FEE E5               [11] 2498         PUSH    HL              ; Save for RETurn
      000FEF CA BA 18         [10] 2499         JP      Z,CMPNUM        ; Compare values if numeric
      000FF2 AF               [ 4] 2500         XOR     A               ; Compare two strings
      000FF3 32 AD 23         [13] 2501         LD      (TYPE),A        ; Set type to numeric
      000FF6 D5               [11] 2502         PUSH    DE              ; Save string name
      000FF7 CD 79 14         [17] 2503         CALL    GSTRCU          ; Get current string
      000FFA 7E               [ 7] 2504         LD      A,(HL)          ; Get length of string
      000FFB 23               [ 6] 2505         INC     HL
      000FFC 23               [ 6] 2506         INC     HL
      000FFD 4E               [ 7] 2507         LD      C,(HL)          ; Get LSB of address
      000FFE 23               [ 6] 2508         INC     HL
      000FFF 46               [ 7] 2509         LD      B,(HL)          ; Get MSB of address
      001000 D1               [10] 2510         POP     DE              ; Restore string name
      001001 C5               [11] 2511         PUSH    BC              ; Save address of string
      001002 F5               [11] 2512         PUSH    AF              ; Save length of string
      001003 CD 7D 14         [17] 2513         CALL    GSTRDE          ; Get second string
      001006 CD 8E 18         [17] 2514         CALL    LOADFP          ; Get address of second string
      001009 F1               [10] 2515         POP     AF              ; Restore length of string 1
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 47.
Hexadecimal [24-Bits]



      00100A 57               [ 4] 2516         LD      D,A             ; Length to D
      00100B E1               [10] 2517         POP     HL              ; Restore address of string 1
      00100C 7B               [ 4] 2518 CMPSTR: LD      A,E             ; Bytes of string 2 to do
      00100D B2               [ 4] 2519         OR      D               ; Bytes of string 1 to do
      00100E C8               [11] 2520         RET     Z               ; Exit if all bytes compared
      00100F 7A               [ 4] 2521         LD      A,D             ; Get bytes of string 1 to do
      001010 D6 01            [ 7] 2522         SUB     #1
      001012 D8               [11] 2523         RET     C               ; Exit if end of string 1
      001013 AF               [ 4] 2524         XOR     A
      001014 BB               [ 4] 2525         CP      E               ; Bytes of string 2 to do
      001015 3C               [ 4] 2526         INC     A
      001016 D0               [11] 2527         RET     NC              ; Exit if end of string 2
      001017 15               [ 4] 2528         DEC     D               ; Count bytes in string 1
      001018 1D               [ 4] 2529         DEC     E               ; Count bytes in string 2
      001019 0A               [ 7] 2530         LD      A,(BC)          ; Byte in string 2
      00101A BE               [ 7] 2531         CP      (HL)            ; Compare to byte in string 1
      00101B 23               [ 6] 2532         INC     HL              ; Move up string 1
      00101C 03               [ 6] 2533         INC     BC              ; Move up string 2
      00101D CA 0C 10         [10] 2534         JP      Z,CMPSTR        ; Same - Try next bytes
      001020 3F               [ 4] 2535         CCF                     ; Flag difference (">" or "<")
      001021 C3 4A 18         [10] 2536         JP      FLGDIF          ; "<" gives -1 , ">" gives +1
                                   2537 
      001024 3C               [ 4] 2538 CMPRES: INC     A               ; Increment current value
      001025 8F               [ 4] 2539         ADC     A,A             ; Double plus carry
      001026 C1               [10] 2540         POP     BC              ; Get other value
      001027 A0               [ 4] 2541         AND     B               ; Combine them
      001028 C6 FF            [ 7] 2542         ADD     A,#-1           ; Carry set if different
      00102A 9F               [ 4] 2543         SBC     A,A             ; 00 - Equal , FF - Different
      00102B C3 51 18         [10] 2544         JP      FLGREL          ; Set current value & continue
                                   2545 
      00102E 16 5A            [ 7] 2546 EVNOT:  LD      D,#0x5A         ; Precedence value for "NOT"
      001030 CD 72 0E         [17] 2547         CALL    EVAL1           ; Eval until precedence break
      001033 CD 60 0E         [17] 2548         CALL    TSTNUM          ; Make sure it's a number
      001036 CD A2 0A         [17] 2549         CALL    DEINT           ; Get integer -32768 - 32767
      001039 7B               [ 4] 2550         LD      A,E             ; Get LSB
      00103A 2F               [ 4] 2551         CPL                     ; Invert LSB
      00103B 4F               [ 4] 2552         LD      C,A             ; Save "NOT" of LSB
      00103C 7A               [ 4] 2553         LD      A,D             ; Get MSB
      00103D 2F               [ 4] 2554         CPL                     ; Invert MSB
      00103E CD 17 12         [17] 2555         CALL    ACPASS          ; Save AC as current
      001041 C1               [10] 2556         POP     BC              ; Clean up stack
      001042 C3 7E 0E         [10] 2557         JP      EVAL3           ; Continue evaluation
                                   2558 
      001045 2B               [ 6] 2559 DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
      001046 CD F0 09         [17] 2560         CALL    GETCHR          ; Get next character
      001049 C8               [11] 2561         RET     Z               ; End of DIM statement
      00104A CD 66 08         [17] 2562         CALL    CHKSYN          ; Make sure ',' follows
      00104D 2C                    2563         .BYTE      ','
      00104E 01 45 10         [10] 2564 DIM:    LD      BC,#DIMRET      ; Return to "DIMRET"
      001051 C5               [11] 2565         PUSH    BC              ; Save on stack
      001052 F6                    2566         .BYTE      0xF6         ; Flag "Create" variable
      001053 AF               [ 4] 2567 GETVAR: XOR     A               ; Find variable address,to DE
      001054 32 AC 23         [13] 2568         LD      (LCRFLG),A      ; Set locate / create flag
      001057 46               [ 7] 2569         LD      B,(HL)          ; Get First byte of name
      001058 CD 8E 0A         [17] 2570 GTFNAM: CALL    CHKLTR          ; See if a letter
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 48.
Hexadecimal [24-Bits]



      00105B DA 98 05         [10] 2571         JP      C,SNERR         ; ?SN Error if not a letter
      00105E AF               [ 4] 2572         XOR     A
      00105F 4F               [ 4] 2573         LD      C,A             ; Clear second byte of name
      001060 32 AD 23         [13] 2574         LD      (TYPE),A        ; Set type to numeric
      001063 CD F0 09         [17] 2575         CALL    GETCHR          ; Get next character
      001066 DA 6F 10         [10] 2576         JP      C,SVNAM2        ; Numeric - Save in name
      001069 CD 8E 0A         [17] 2577         CALL    CHKLTR          ; See if a letter
      00106C DA 7C 10         [10] 2578         JP      C,CHARTY        ; Not a letter - Check type
      00106F 4F               [ 4] 2579 SVNAM2: LD      C,A             ; Save second byte of name
      001070 CD F0 09         [17] 2580 ENDNAM: CALL    GETCHR          ; Get next character
      001073 DA 70 10         [10] 2581         JP      C,ENDNAM        ; Numeric - Get another
      001076 CD 8E 0A         [17] 2582         CALL    CHKLTR          ; See if a letter
      001079 D2 70 10         [10] 2583         JP      NC,ENDNAM       ; Letter - Get another
      00107C D6 24            [ 7] 2584 CHARTY: SUB     #'$'            ; String variable?
      00107E C2 8B 10         [10] 2585         JP      NZ,NOTSTR       ; No - Numeric variable
      001081 3C               [ 4] 2586         INC     A               ; A = 1 (string type)
      001082 32 AD 23         [13] 2587         LD      (TYPE),A        ; Set type to string
      001085 0F               [ 4] 2588         RRCA                    ; A = 80H , Flag for string
      001086 81               [ 4] 2589         ADD     A,C             ; 2nd byte of name has bit 7 on
      001087 4F               [ 4] 2590         LD      C,A             ; Resave second byte on name
      001088 CD F0 09         [17] 2591         CALL    GETCHR          ; Get next character
      00108B 3A CB 23         [13] 2592 NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
      00108E 3D               [ 4] 2593         DEC     A
      00108F CA 38 11         [10] 2594         JP      Z,ARLDSV        ; Yes - Get array name
      001092 F2 9B 10         [10] 2595         JP      P,NSCFOR        ; No array with "FOR" or "FN"
      001095 7E               [ 7] 2596         LD      A,(HL)          ; Get byte again
      001096 D6 28            [ 7] 2597         SUB     #'('            ; Subscripted variable?
      001098 CA 10 11         [10] 2598         JP      Z,SBSCPT        ; Yes - Sort out subscript
                                   2599 
      00109B AF               [ 4] 2600 NSCFOR: XOR     A               ; Simple variable
      00109C 32 CB 23         [13] 2601         LD      (FORFLG),A      ; Clear "FOR" flag
      00109F E5               [11] 2602         PUSH    HL              ; Save code string address
      0010A0 50               [ 4] 2603         LD      D,B             ; DE = Variable name to find
      0010A1 59               [ 4] 2604         LD      E,C
      0010A2 2A DE 23         [16] 2605         LD      HL,(FNRGNM)     ; FN argument name
      0010A5 CD 60 08         [17] 2606         CALL    CPDEHL          ; Is it the FN argument?
      0010A8 11 E0 23         [10] 2607         LD      DE,#FNARG       ; Point to argument value
      0010AB CA 80 17         [10] 2608         JP      Z,POPHRT        ; Yes - Return FN argument value
      0010AE 2A D8 23         [16] 2609         LD      HL,(VAREND)     ; End of variables
      0010B1 EB               [ 4] 2610         EX      DE,HL           ; Address of end of search
      0010B2 2A D6 23         [16] 2611         LD      HL,(PROGND)     ; Start of variables address
      0010B5 CD 60 08         [17] 2612 FNDVAR: CALL    CPDEHL          ; End of variable list table?
      0010B8 CA CE 10         [10] 2613         JP      Z,CFEVAL        ; Yes - Called from EVAL?
      0010BB 79               [ 4] 2614         LD      A,C             ; Get second byte of name
      0010BC 96               [ 7] 2615         SUB     (HL)            ; Compare with name in list
      0010BD 23               [ 6] 2616         INC     HL              ; Move on to first byte
      0010BE C2 C3 10         [10] 2617         JP      NZ,FNTHR        ; Different - Find another
      0010C1 78               [ 4] 2618         LD      A,B             ; Get first byte of name
      0010C2 96               [ 7] 2619         SUB     (HL)            ; Compare with name in list
      0010C3 23               [ 6] 2620 FNTHR:  INC     HL              ; Move on to LSB of value
      0010C4 CA 02 11         [10] 2621         JP      Z,RETADR        ; Found - Return address
      0010C7 23               [ 6] 2622         INC     HL              ; <- Skip
      0010C8 23               [ 6] 2623         INC     HL              ; <- over
      0010C9 23               [ 6] 2624         INC     HL              ; <- F.P.
      0010CA 23               [ 6] 2625         INC     HL              ; <- value
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 49.
Hexadecimal [24-Bits]



      0010CB C3 B5 10         [10] 2626         JP      FNDVAR          ; Keep looking
                                   2627 
      0010CE E1               [10] 2628 CFEVAL: POP     HL              ; Restore code string address
      0010CF E3               [19] 2629         EX      (SP),HL         ; Get return address
      0010D0 D5               [11] 2630         PUSH    DE              ; Save address of variable
      0010D1 11 50 0F         [10] 2631         LD      DE,#FRMEVL      ; Return address in EVAL
      0010D4 CD 60 08         [17] 2632         CALL    CPDEHL          ; Called from EVAL ?
      0010D7 D1               [10] 2633         POP     DE              ; Restore address of variable
      0010D8 CA 05 11         [10] 2634         JP      Z,RETNUL        ; Yes - Return null variable
      0010DB E3               [19] 2635         EX      (SP),HL         ; Put back return
      0010DC E5               [11] 2636         PUSH    HL              ; Save code string address
      0010DD C5               [11] 2637         PUSH    BC              ; Save variable name
      0010DE 01 06 00         [10] 2638         LD      BC,#6           ; 2 byte name plus 4 byte data
      0010E1 2A DA 23         [16] 2639         LD      HL,(ARREND)     ; End of arrays
      0010E4 E5               [11] 2640         PUSH    HL              ; Save end of arrays
      0010E5 09               [11] 2641         ADD     HL,BC           ; Move up 6 bytes
      0010E6 C1               [10] 2642         POP     BC              ; Source address in BC
      0010E7 E5               [11] 2643         PUSH    HL              ; Save new end address
      0010E8 CD 64 05         [17] 2644         CALL    MOVUP           ; Move arrays up
      0010EB E1               [10] 2645         POP     HL              ; Restore new end address
      0010EC 22 DA 23         [16] 2646         LD      (ARREND),HL     ; Set new end address
      0010EF 60               [ 4] 2647         LD      H,B             ; End of variables to HL
      0010F0 69               [ 4] 2648         LD      L,C
      0010F1 22 D8 23         [16] 2649         LD      (VAREND),HL     ; Set new end address
                                   2650 
      0010F4 2B               [ 6] 2651 ZEROLP: DEC     HL              ; Back through to zero variable
      0010F5 36 00            [10] 2652         LD      (HL),#0         ; Zero byte in variable
      0010F7 CD 60 08         [17] 2653         CALL    CPDEHL          ; Done them all?
      0010FA C2 F4 10         [10] 2654         JP      NZ,ZEROLP       ; No - Keep on going
      0010FD D1               [10] 2655         POP     DE              ; Get variable name
      0010FE 73               [ 7] 2656         LD      (HL),E          ; Store second character
      0010FF 23               [ 6] 2657         INC     HL
      001100 72               [ 7] 2658         LD      (HL),D          ; Store first character
      001101 23               [ 6] 2659         INC     HL
      001102 EB               [ 4] 2660 RETADR: EX      DE,HL           ; Address of variable in DE
      001103 E1               [10] 2661         POP     HL              ; Restore code string address
      001104 C9               [10] 2662         RET
                                   2663 
      001105 32 E7 23         [13] 2664 RETNUL: LD      (FPEXP),A       ; Set result to zero
      001108 21 34 05         [10] 2665         LD      HL,#ZERBYT      ; Also set a null string
      00110B 22 E4 23         [16] 2666         LD      (FPREG),HL      ; Save for EVAL
      00110E E1               [10] 2667         POP     HL              ; Restore code string address
      00110F C9               [10] 2668         RET
                                   2669 
      001110 E5               [11] 2670 SBSCPT: PUSH    HL              ; Save code string address
      001111 2A AC 23         [16] 2671         LD      HL,(LCRFLG)     ; Locate/Create and Type
      001114 E3               [19] 2672         EX      (SP),HL         ; Save and get code string
      001115 57               [ 4] 2673         LD      D,A             ; Zero number of dimensions
      001116 D5               [11] 2674 SCPTLP: PUSH    DE              ; Save number of dimensions
      001117 C5               [11] 2675         PUSH    BC              ; Save array name
      001118 CD 96 0A         [17] 2676         CALL    FPSINT          ; Get subscript (0-32767)
      00111B C1               [10] 2677         POP     BC              ; Restore array name
      00111C F1               [10] 2678         POP     AF              ; Get number of dimensions
      00111D EB               [ 4] 2679         EX      DE,HL
      00111E E3               [19] 2680         EX      (SP),HL         ; Save subscript value
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 50.
Hexadecimal [24-Bits]



      00111F E5               [11] 2681         PUSH    HL              ; Save LCRFLG and TYPE
      001120 EB               [ 4] 2682         EX      DE,HL
      001121 3C               [ 4] 2683         INC     A               ; Count dimensions
      001122 57               [ 4] 2684         LD      D,A             ; Save in D
      001123 7E               [ 7] 2685         LD      A,(HL)          ; Get next byte in code string
      001124 FE 2C            [ 7] 2686         CP      #','            ; Comma (more to come)?
      001126 CA 16 11         [10] 2687         JP      Z,SCPTLP        ; Yes - More subscripts
      001129 CD 66 08         [17] 2688         CALL    CHKSYN          ; Make sure ")" follows
      00112C 29                    2689         .BYTE      ")"
      00112D 22 D0 23         [16] 2690         LD      (NXTOPR),HL     ; Save code string address
      001130 E1               [10] 2691         POP     HL              ; Get LCRFLG and TYPE
      001131 22 AC 23         [16] 2692         LD      (LCRFLG),HL     ; Restore Locate/create & type
      001134 1E 00            [ 7] 2693         LD      E,#0            ; Flag not CSAVE* or CLOAD*
      001136 D5               [11] 2694         PUSH    DE              ; Save number of dimensions (D)
      001137 11                    2695         .BYTE      0x11         ; Skip "PUSH HL" and "PUSH AF'
                                   2696 
      001138 E5               [11] 2697 ARLDSV: PUSH    HL              ; Save code string address
      001139 F5               [11] 2698         PUSH    AF              ; A = 00 , Flags set = Z,N
      00113A 2A D8 23         [16] 2699         LD      HL,(VAREND)     ; Start of arrays
      00113D 3E                    2700         .BYTE      0x3E         ; Skip "ADD HL,DE"
      00113E 19               [11] 2701 FNDARY: ADD     HL,DE           ; Move to next array start
      00113F EB               [ 4] 2702         EX      DE,HL
      001140 2A DA 23         [16] 2703         LD      HL,(ARREND)     ; End of arrays
      001143 EB               [ 4] 2704         EX      DE,HL           ; Current array pointer
      001144 CD 60 08         [17] 2705         CALL    CPDEHL          ; End of arrays found?
      001147 CA 70 11         [10] 2706         JP      Z,CREARY        ; Yes - Create array
      00114A 7E               [ 7] 2707         LD      A,(HL)          ; Get second byte of name
      00114B B9               [ 4] 2708         CP      C               ; Compare with name given
      00114C 23               [ 6] 2709         INC     HL              ; Move on
      00114D C2 52 11         [10] 2710         JP      NZ,NXTARY       ; Different - Find next array
      001150 7E               [ 7] 2711         LD      A,(HL)          ; Get first byte of name
      001151 B8               [ 4] 2712         CP      B               ; Compare with name given
      001152 23               [ 6] 2713 NXTARY: INC     HL              ; Move on
      001153 5E               [ 7] 2714         LD      E,(HL)          ; Get LSB of next array address
      001154 23               [ 6] 2715         INC     HL
      001155 56               [ 7] 2716         LD      D,(HL)          ; Get MSB of next array address
      001156 23               [ 6] 2717         INC     HL
      001157 C2 3E 11         [10] 2718         JP      NZ,FNDARY       ; Not found - Keep looking
      00115A 3A AC 23         [13] 2719         LD      A,(LCRFLG)      ; Found Locate or Create it?
      00115D B7               [ 4] 2720         OR      A
      00115E C2 A1 05         [10] 2721         JP      NZ,DDERR        ; Create - ?DD Error
      001161 F1               [10] 2722         POP     AF              ; Locate - Get number of dim'ns
      001162 44               [ 4] 2723         LD      B,H             ; BC Points to array dim'ns
      001163 4D               [ 4] 2724         LD      C,L
      001164 CA 80 17         [10] 2725         JP      Z,POPHRT        ; Jump if array load/save
      001167 96               [ 7] 2726         SUB     (HL)            ; Same number of dimensions?
      001168 CA CE 11         [10] 2727         JP      Z,FINDEL        ; Yes - Find element
      00116B 1E 10            [ 7] 2728 BSERR:  LD      E,#BS           ; ?BS Error
      00116D C3 AC 05         [10] 2729         JP      ERROR           ; Output error
                                   2730 
      001170 11 04 00         [10] 2731 CREARY: LD      DE,#4           ; 4 Bytes per entry
      001173 F1               [10] 2732         POP     AF              ; Array to save or 0 dim'ns?
      001174 CA B7 0A         [10] 2733         JP      Z,FCERR         ; Yes - ?FC Error
      001177 71               [ 7] 2734         LD      (HL),C          ; Save second byte of name
      001178 23               [ 6] 2735         INC     HL
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 51.
Hexadecimal [24-Bits]



      001179 70               [ 7] 2736         LD      (HL),B          ; Save first byte of name
      00117A 23               [ 6] 2737         INC     HL
      00117B 4F               [ 4] 2738         LD      C,A             ; Number of dimensions to C
      00117C CD 75 05         [17] 2739         CALL    CHKSTK          ; Check if enough memory
      00117F 23               [ 6] 2740         INC     HL              ; Point to number of dimensions
      001180 23               [ 6] 2741         INC     HL
      001181 22 C5 23         [16] 2742         LD      (CUROPR),HL     ; Save address of pointer
      001184 71               [ 7] 2743         LD      (HL),C          ; Set number of dimensions
      001185 23               [ 6] 2744         INC     HL
      001186 3A AC 23         [13] 2745         LD      A,(LCRFLG)      ; Locate of Create?
      001189 17               [ 4] 2746         RLA                     ; Carry set = Create
      00118A 79               [ 4] 2747         LD      A,C             ; Get number of dimensions
      00118B 01 0B 00         [10] 2748 CRARLP: LD      BC,#10+1        ; Default dimension size 10
      00118E D2 93 11         [10] 2749         JP      NC,DEFSIZ       ; Locate - Set default size
      001191 C1               [10] 2750         POP     BC              ; Get specified dimension size
      001192 03               [ 6] 2751         INC     BC              ; Include zero element
      001193 71               [ 7] 2752 DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
      001194 23               [ 6] 2753         INC     HL
      001195 70               [ 7] 2754         LD      (HL),B          ; Save MSB of dimension size
      001196 23               [ 6] 2755         INC     HL
      001197 F5               [11] 2756         PUSH    AF              ; Save num' of dim'ns an status
      001198 E5               [11] 2757         PUSH    HL              ; Save address of dim'n size
      001199 CD 2B 19         [17] 2758         CALL    MLDEBC          ; Multiply DE by BC to find
      00119C EB               [ 4] 2759         EX      DE,HL           ; amount of mem needed (to DE)
      00119D E1               [10] 2760         POP     HL              ; Restore address of dimension
      00119E F1               [10] 2761         POP     AF              ; Restore number of dimensions
      00119F 3D               [ 4] 2762         DEC     A               ; Count them
      0011A0 C2 8B 11         [10] 2763         JP      NZ,CRARLP       ; Do next dimension if more
      0011A3 F5               [11] 2764         PUSH    AF              ; Save locate/create flag
      0011A4 42               [ 4] 2765         LD      B,D             ; MSB of memory needed
      0011A5 4B               [ 4] 2766         LD      C,E             ; LSB of memory needed
      0011A6 EB               [ 4] 2767         EX      DE,HL
      0011A7 19               [11] 2768         ADD     HL,DE           ; Add bytes to array start
      0011A8 DA 8D 05         [10] 2769         JP      C,OMERR         ; Too big - Error
      0011AB CD 7E 05         [17] 2770         CALL    ENFMEM          ; See if enough memory
      0011AE 22 DA 23         [16] 2771         LD      (ARREND),HL     ; Save new end of array
                                   2772 
      0011B1 2B               [ 6] 2773 ZERARY: DEC     HL              ; Back through array data
      0011B2 36 00            [10] 2774         LD      (HL),#0         ; Set array element to zero
      0011B4 CD 60 08         [17] 2775         CALL    CPDEHL          ; All elements zeroed?
      0011B7 C2 B1 11         [10] 2776         JP      NZ,ZERARY       ; No - Keep on going
      0011BA 03               [ 6] 2777         INC     BC              ; Number of bytes + 1
      0011BB 57               [ 4] 2778         LD      D,A             ; A=0
      0011BC 2A C5 23         [16] 2779         LD      HL,(CUROPR)     ; Get address of array
      0011BF 5E               [ 7] 2780         LD      E,(HL)          ; Number of dimensions
      0011C0 EB               [ 4] 2781         EX      DE,HL           ; To HL
      0011C1 29               [11] 2782         ADD     HL,HL           ; Two bytes per dimension size
      0011C2 09               [11] 2783         ADD     HL,BC           ; Add number of bytes
      0011C3 EB               [ 4] 2784         EX      DE,HL           ; Bytes needed to DE
      0011C4 2B               [ 6] 2785         DEC     HL
      0011C5 2B               [ 6] 2786         DEC     HL
      0011C6 73               [ 7] 2787         LD      (HL),E          ; Save LSB of bytes needed
      0011C7 23               [ 6] 2788         INC     HL
      0011C8 72               [ 7] 2789         LD      (HL),D          ; Save MSB of bytes needed
      0011C9 23               [ 6] 2790         INC     HL
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 52.
Hexadecimal [24-Bits]



      0011CA F1               [10] 2791         POP     AF              ; Locate / Create?
      0011CB DA F2 11         [10] 2792         JP      C,ENDDIM        ; A is 0 , End if create
      0011CE 47               [ 4] 2793 FINDEL: LD      B,A             ; Find array element
      0011CF 4F               [ 4] 2794         LD      C,A
      0011D0 7E               [ 7] 2795         LD      A,(HL)          ; Number of dimensions
      0011D1 23               [ 6] 2796         INC     HL
      0011D2 16                    2797         .BYTE      0x16         ; Skip "POP HL"
      0011D3 E1               [10] 2798 FNDELP: POP     HL              ; Address of next dim' size
      0011D4 5E               [ 7] 2799         LD      E,(HL)          ; Get LSB of dim'n size
      0011D5 23               [ 6] 2800         INC     HL
      0011D6 56               [ 7] 2801         LD      D,(HL)          ; Get MSB of dim'n size
      0011D7 23               [ 6] 2802         INC     HL
      0011D8 E3               [19] 2803         EX      (SP),HL         ; Save address - Get index
      0011D9 F5               [11] 2804         PUSH    AF              ; Save number of dim'ns
      0011DA CD 60 08         [17] 2805         CALL    CPDEHL          ; Dimension too large?
      0011DD D2 6B 11         [10] 2806         JP      NC,BSERR        ; Yes - ?BS Error
      0011E0 E5               [11] 2807         PUSH    HL              ; Save index
      0011E1 CD 2B 19         [17] 2808         CALL    MLDEBC          ; Multiply previous by size
      0011E4 D1               [10] 2809         POP     DE              ; Index supplied to DE
      0011E5 19               [11] 2810         ADD     HL,DE           ; Add index to pointer
      0011E6 F1               [10] 2811         POP     AF              ; Number of dimensions
      0011E7 3D               [ 4] 2812         DEC     A               ; Count them
      0011E8 44               [ 4] 2813         LD      B,H             ; MSB of pointer
      0011E9 4D               [ 4] 2814         LD      C,L             ; LSB of pointer
      0011EA C2 D3 11         [10] 2815         JP      NZ,FNDELP       ; More - Keep going
      0011ED 29               [11] 2816         ADD     HL,HL           ; 4 Bytes per element
      0011EE 29               [11] 2817         ADD     HL,HL
      0011EF C1               [10] 2818         POP     BC              ; Start of array
      0011F0 09               [11] 2819         ADD     HL,BC           ; Point to element
      0011F1 EB               [ 4] 2820         EX      DE,HL           ; Address of element to DE
      0011F2 2A D0 23         [16] 2821 ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
      0011F5 C9               [10] 2822         RET
                                   2823 
      0011F6 2A DA 23         [16] 2824 FRE:    LD      HL,(ARREND)     ; Start of free memory
      0011F9 EB               [ 4] 2825         EX      DE,HL           ; To DE
      0011FA 21 00 00         [10] 2826         LD      HL,#0           ; End of free memory
      0011FD 39               [11] 2827         ADD     HL,SP           ; Current stack value
      0011FE 3A AD 23         [13] 2828         LD      A,(TYPE)        ; Dummy argument type
      001201 B7               [ 4] 2829         OR      A
      001202 CA 12 12         [10] 2830         JP      Z,FRENUM        ; Numeric - Free variable space
      001205 CD 79 14         [17] 2831         CALL    GSTRCU          ; Current string to pool
      001208 CD 79 13         [17] 2832         CALL    GARBGE          ; Garbage collection
      00120B 2A 5A 23         [16] 2833         LD      HL,(STRSPC)     ; Bottom of string space in use
      00120E EB               [ 4] 2834         EX      DE,HL           ; To DE
      00120F 2A C3 23         [16] 2835         LD      HL,(STRBOT)     ; Bottom of string space
      001212 7D               [ 4] 2836 FRENUM: LD      A,L             ; Get LSB of end
      001213 93               [ 4] 2837         SUB     E               ; Subtract LSB of beginning
      001214 4F               [ 4] 2838         LD      C,A             ; Save difference if C
      001215 7C               [ 4] 2839         LD      A,H             ; Get MSB of end
      001216 9A               [ 4] 2840         SBC     A,D             ; Subtract MSB of beginning
      001217 41               [ 4] 2841 ACPASS: LD      B,C             ; Return integer AC
      001218 50               [ 4] 2842 ABPASS: LD      D,B             ; Return integer AB
      001219 1E 00            [ 7] 2843         LD      E,#0
      00121B 21 AD 23         [10] 2844         LD      HL,#TYPE        ; Point to type
      00121E 73               [ 7] 2845         LD      (HL),E          ; Set type to numeric
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 53.
Hexadecimal [24-Bits]



      00121F 06 90            [ 7] 2846         LD      B,#0x80+16       ; 16 bit integer
      001221 C3 56 18         [10] 2847         JP      RETINT          ; Return the integr
                                   2848 
      001224 3A AB 23         [13] 2849 POS:    LD      A,(CURPOS)      ; Get cursor position
      001227 47               [ 4] 2850 PASSA:  LD      B,A             ; Put A into AB
      001228 AF               [ 4] 2851         XOR     A               ; Zero A
      001229 C3 18 12         [10] 2852         JP      ABPASS          ; Return integer AB
                                   2853 
      00122C CD AF 12         [17] 2854 DEF:    CALL    CHEKFN          ; Get "FN" and name
      00122F CD A1 12         [17] 2855         CALL    IDTEST          ; Test for illegal direct
      001232 01 87 0B         [10] 2856         LD      BC,#DATA        ; To get next statement
      001235 C5               [11] 2857         PUSH    BC              ; Save address for RETurn
      001236 D5               [11] 2858         PUSH    DE              ; Save address of function ptr
      001237 CD 66 08         [17] 2859         CALL    CHKSYN          ; Make sure "(" follows
      00123A 28                    2860         .BYTE      "("
      00123B CD 53 10         [17] 2861         CALL    GETVAR          ; Get argument variable name
      00123E E5               [11] 2862         PUSH    HL              ; Save code string address
      00123F EB               [ 4] 2863         EX      DE,HL           ; Argument address to HL
      001240 2B               [ 6] 2864         DEC     HL
      001241 56               [ 7] 2865         LD      D,(HL)          ; Get first byte of arg name
      001242 2B               [ 6] 2866         DEC     HL
      001243 5E               [ 7] 2867         LD      E,(HL)          ; Get second byte of arg name
      001244 E1               [10] 2868         POP     HL              ; Restore code string address
      001245 CD 60 0E         [17] 2869         CALL    TSTNUM          ; Make sure numeric argument
      001248 CD 66 08         [17] 2870         CALL    CHKSYN          ; Make sure ")" follows
      00124B 29                    2871         .BYTE      ")"
      00124C CD 66 08         [17] 2872         CALL    CHKSYN          ; Make sure "=" follows
      00124F B4                    2873         .BYTE      ZEQUAL          ; "=" token
      001250 44               [ 4] 2874         LD      B,H             ; Code string address to BC
      001251 4D               [ 4] 2875         LD      C,L
      001252 E3               [19] 2876         EX      (SP),HL         ; Save code str , Get FN ptr
      001253 71               [ 7] 2877         LD      (HL),C          ; Save LSB of FN code string
      001254 23               [ 6] 2878         INC     HL
      001255 70               [ 7] 2879         LD      (HL),B          ; Save MSB of FN code string
      001256 C3 EE 12         [10] 2880         JP      SVSTAD          ; Save address and do function
                                   2881 
      001259 CD AF 12         [17] 2882 DOFN:   CALL    CHEKFN          ; Make sure FN follows
      00125C D5               [11] 2883         PUSH    DE              ; Save function pointer address
      00125D CD 34 0F         [17] 2884         CALL    EVLPAR          ; Evaluate expression in "()"
      001260 CD 60 0E         [17] 2885         CALL    TSTNUM          ; Make sure numeric result
      001263 E3               [19] 2886         EX      (SP),HL         ; Save code str , Get FN ptr
      001264 5E               [ 7] 2887         LD      E,(HL)          ; Get LSB of FN code string
      001265 23               [ 6] 2888         INC     HL
      001266 56               [ 7] 2889         LD      D,(HL)          ; Get MSB of FN code string
      001267 23               [ 6] 2890         INC     HL
      001268 7A               [ 4] 2891         LD      A,D             ; And function DEFined?
      001269 B3               [ 4] 2892         OR      E
      00126A CA A4 05         [10] 2893         JP      Z,UFERR         ; No - ?UF Error
      00126D 7E               [ 7] 2894         LD      A,(HL)          ; Get LSB of argument address
      00126E 23               [ 6] 2895         INC     HL
      00126F 66               [ 7] 2896         LD      H,(HL)          ; Get MSB of argument address
      001270 6F               [ 4] 2897         LD      L,A             ; HL = Arg variable address
      001271 E5               [11] 2898         PUSH    HL              ; Save it
      001272 2A DE 23         [16] 2899         LD      HL,(FNRGNM)     ; Get old argument name
      001275 E3               [19] 2900         EX      (SP),HL ;       ; Save old , Get new
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 54.
Hexadecimal [24-Bits]



      001276 22 DE 23         [16] 2901         LD      (FNRGNM),HL     ; Set new argument name
      001279 2A E2 23         [16] 2902         LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
      00127C E5               [11] 2903         PUSH    HL              ; Save it
      00127D 2A E0 23         [16] 2904         LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
      001280 E5               [11] 2905         PUSH    HL              ; Save it
      001281 21 E0 23         [10] 2906         LD      HL,#FNARG       ; HL = Value of argument
      001284 D5               [11] 2907         PUSH    DE              ; Save FN code string address
      001285 CD 97 18         [17] 2908         CALL    FPTHL           ; Move FPREG to argument
      001288 E1               [10] 2909         POP     HL              ; Get FN code string address
      001289 CD 5D 0E         [17] 2910         CALL    GETNUM          ; Get value from function
      00128C 2B               [ 6] 2911         DEC     HL              ; DEC 'cos GETCHR INCs
      00128D CD F0 09         [17] 2912         CALL    GETCHR          ; Get next character
      001290 C2 98 05         [10] 2913         JP      NZ,SNERR        ; Bad character in FN - Error
      001293 E1               [10] 2914         POP     HL              ; Get MSB,EXP of old arg
      001294 22 E0 23         [16] 2915         LD      (FNARG),HL      ; Restore it
      001297 E1               [10] 2916         POP     HL              ; Get LSB,NLSB of old arg
      001298 22 E2 23         [16] 2917         LD      (FNARG+2),HL    ; Restore it
      00129B E1               [10] 2918         POP     HL              ; Get name of old arg
      00129C 22 DE 23         [16] 2919         LD      (FNRGNM),HL     ; Restore it
      00129F E1               [10] 2920         POP     HL              ; Restore code string address
      0012A0 C9               [10] 2921         RET
                                   2922 
      0012A1 E5               [11] 2923 IDTEST: PUSH    HL              ; Save code string address
      0012A2 2A 5C 23         [16] 2924         LD      HL,(LINEAT)     ; Get current line number
      0012A5 23               [ 6] 2925         INC     HL              ; -1 means direct statement
      0012A6 7C               [ 4] 2926         LD      A,H
      0012A7 B5               [ 4] 2927         OR      L
      0012A8 E1               [10] 2928         POP     HL              ; Restore code string address
      0012A9 C0               [11] 2929         RET     NZ              ; Return if in program
      0012AA 1E 16            [ 7] 2930         LD      E,#ID           ; ?ID Error
      0012AC C3 AC 05         [10] 2931         JP      ERROR
                                   2932 
      0012AF CD 66 08         [17] 2933 CHEKFN: CALL    CHKSYN          ; Make sure FN follows
      0012B2 A7                    2934         .BYTE      ZFN             ; "FN" token
      0012B3 3E 80            [ 7] 2935         LD      A,#0x80
      0012B5 32 CB 23         [13] 2936         LD      (FORFLG),A      ; Flag FN name to find
      0012B8 B6               [ 7] 2937         OR      (HL)            ; FN name has bit 7 set
      0012B9 47               [ 4] 2938         LD      B,A             ; in first byte of name
      0012BA CD 58 10         [17] 2939         CALL    GTFNAM          ; Get FN name
      0012BD C3 60 0E         [10] 2940         JP      TSTNUM          ; Make sure numeric function
                                   2941 
      0012C0 CD 60 0E         [17] 2942 STR:    CALL    TSTNUM          ; Make sure it's a number
      0012C3 CD E4 19         [17] 2943         CALL    NUMASC          ; Turn number into text
      0012C6 CD F4 12         [17] 2944 STR1:   CALL    CRTST           ; Create string entry for it
      0012C9 CD 79 14         [17] 2945         CALL    GSTRCU          ; Current string to pool
      0012CC 01 D4 14         [10] 2946         LD      BC,#TOPOOL      ; Save in string pool
      0012CF C5               [11] 2947         PUSH    BC              ; Save address on stack
                                   2948 
      0012D0 7E               [ 7] 2949 SAVSTR: LD      A,(HL)          ; Get string length
      0012D1 23               [ 6] 2950         INC     HL
      0012D2 23               [ 6] 2951         INC     HL
      0012D3 E5               [11] 2952         PUSH    HL              ; Save pointer to string
      0012D4 CD 4F 13         [17] 2953         CALL    TESTR           ; See if enough string space
      0012D7 E1               [10] 2954         POP     HL              ; Restore pointer to string
      0012D8 4E               [ 7] 2955         LD      C,(HL)          ; Get LSB of address
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 55.
Hexadecimal [24-Bits]



      0012D9 23               [ 6] 2956         INC     HL
      0012DA 46               [ 7] 2957         LD      B,(HL)          ; Get MSB of address
      0012DB CD E8 12         [17] 2958         CALL    CRTMST          ; Create string entry
      0012DE E5               [11] 2959         PUSH    HL              ; Save pointer to MSB of addr
      0012DF 6F               [ 4] 2960         LD      L,A             ; Length of string
      0012E0 CD 6C 14         [17] 2961         CALL    TOSTRA          ; Move to string area
      0012E3 D1               [10] 2962         POP     DE              ; Restore pointer to MSB
      0012E4 C9               [10] 2963         RET
                                   2964 
      0012E5 CD 4F 13         [17] 2965 MKTMST: CALL    TESTR           ; See if enough string space
      0012E8 21 BF 23         [10] 2966 CRTMST: LD      HL,#TMPSTR      ; Temporary string
      0012EB E5               [11] 2967         PUSH    HL              ; Save it
      0012EC 77               [ 7] 2968         LD      (HL),A          ; Save length of string
      0012ED 23               [ 6] 2969         INC     HL
      0012EE 23               [ 6] 2970 SVSTAD: INC     HL
      0012EF 73               [ 7] 2971         LD      (HL),E          ; Save LSB of address
      0012F0 23               [ 6] 2972         INC     HL
      0012F1 72               [ 7] 2973         LD      (HL),D          ; Save MSB of address
      0012F2 E1               [10] 2974         POP     HL              ; Restore pointer
      0012F3 C9               [10] 2975         RET
                                   2976 
      0012F4 2B               [ 6] 2977 CRTST:  DEC     HL              ; DEC - INCed after
      0012F5 06 22            [ 7] 2978 QTSTR:  LD      B,#'"'          ; Terminating quote
      0012F7 50               [ 4] 2979         LD      D,B             ; Quote to D
      0012F8 E5               [11] 2980 DTSTR:  PUSH    HL              ; Save start
      0012F9 0E FF            [ 7] 2981         LD      C,#-1           ; Set counter to -1
      0012FB 23               [ 6] 2982 QTSTLP: INC     HL              ; Move on
      0012FC 7E               [ 7] 2983         LD      A,(HL)          ; Get byte
      0012FD 0C               [ 4] 2984         INC     C               ; Count bytes
      0012FE B7               [ 4] 2985         OR      A               ; End of line?
      0012FF CA 0A 13         [10] 2986         JP      Z,CRTSTE        ; Yes - Create string entry
      001302 BA               [ 4] 2987         CP      D               ; Terminator D found?
      001303 CA 0A 13         [10] 2988         JP      Z,CRTSTE        ; Yes - Create string entry
      001306 B8               [ 4] 2989         CP      B               ; Terminator B found?
      001307 C2 FB 12         [10] 2990         JP      NZ,QTSTLP       ; No - Keep looking
      00130A FE 22            [ 7] 2991 CRTSTE: CP      #'"'            ; End with '"'?
      00130C CC F0 09         [17] 2992         CALL    Z,GETCHR        ; Yes - Get next character
      00130F E3               [19] 2993         EX      (SP),HL         ; Starting quote
      001310 23               [ 6] 2994         INC     HL              ; First byte of string
      001311 EB               [ 4] 2995         EX      DE,HL           ; To DE
      001312 79               [ 4] 2996         LD      A,C             ; Get length
      001313 CD E8 12         [17] 2997         CALL    CRTMST          ; Create string entry
      001316 11 BF 23         [10] 2998 TSTOPL: LD      DE,#TMPSTR      ; Temporary string
      001319 2A B1 23         [16] 2999         LD      HL,(TMSTPT)     ; Temporary string pool pointer
      00131C 22 E4 23         [16] 3000         LD      (FPREG),HL      ; Save address of string ptr
      00131F 3E 01            [ 7] 3001         LD      A,#1
      001321 32 AD 23         [13] 3002         LD      (TYPE),A        ; Set type to string
      001324 CD 9A 18         [17] 3003         CALL    DETHL4          ; Move string to pool
      001327 CD 60 08         [17] 3004         CALL    CPDEHL          ; Out of string pool?
      00132A 22 B1 23         [16] 3005         LD      (TMSTPT),HL     ; Save new pointer
      00132D E1               [10] 3006         POP     HL              ; Restore code string address
      00132E 7E               [ 7] 3007         LD      A,(HL)          ; Get next code byte
      00132F C0               [11] 3008         RET     NZ              ; Return if pool OK
      001330 1E 1E            [ 7] 3009         LD      E,#ST           ; ?ST Error
      001332 C3 AC 05         [10] 3010         JP      ERROR           ; String pool overflow
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 56.
Hexadecimal [24-Bits]



                                   3011 
      001335 23               [ 6] 3012 PRNUMS: INC     HL              ; Skip leading space
      001336 CD F4 12         [17] 3013 PRS:    CALL    CRTST           ; Create string entry for it
      001339 CD 79 14         [17] 3014 PRS1:   CALL    GSTRCU          ; Current string to pool
      00133C CD 8E 18         [17] 3015         CALL    LOADFP          ; Move string block to BCDE
      00133F 1C               [ 4] 3016         INC     E               ; Length + 1
      001340 1D               [ 4] 3017 PRSLP:  DEC     E               ; Count characters
      001341 C8               [11] 3018         RET     Z               ; End of string
      001342 0A               [ 7] 3019         LD      A,(BC)          ; Get byte to output
      001343 CD 71 08         [17] 3020         CALL    OUTC            ; Output character in A
      001346 FE 0D            [ 7] 3021         CP      #CR             ; Return?
      001348 CC A2 0C         [17] 3022         CALL    Z,DONULL        ; Yes - Do nulls
      00134B 03               [ 6] 3023         INC     BC              ; Next byte in string
      00134C C3 40 13         [10] 3024         JP      PRSLP           ; More characters to output
                                   3025 
      00134F B7               [ 4] 3026 TESTR:  OR      A               ; Test if enough room
      001350 0E                    3027         .BYTE      0x0E         ; No garbage collection done
      001351 F1               [10] 3028 GRBDON: POP     AF              ; Garbage collection done
      001352 F5               [11] 3029         PUSH    AF              ; Save status
      001353 2A 5A 23         [16] 3030         LD      HL,(STRSPC)     ; Bottom of string space in use
      001356 EB               [ 4] 3031         EX      DE,HL           ; To DE
      001357 2A C3 23         [16] 3032         LD      HL,(STRBOT)     ; Bottom of string area
      00135A 2F               [ 4] 3033         CPL                     ; Negate length (Top down)
      00135B 4F               [ 4] 3034         LD      C,A             ; -Length to BC
      00135C 06 FF            [ 7] 3035         LD      B,#-1           ; BC = -ve length of string
      00135E 09               [11] 3036         ADD     HL,BC           ; Add to bottom of space in use
      00135F 23               [ 6] 3037         INC     HL              ; Plus one for 2's complement
      001360 CD 60 08         [17] 3038         CALL    CPDEHL          ; Below string RAM area?
      001363 DA 6D 13         [10] 3039         JP      C,TESTOS        ; Tidy up if not done else err
      001366 22 C3 23         [16] 3040         LD      (STRBOT),HL     ; Save new bottom of area
      001369 23               [ 6] 3041         INC     HL              ; Point to first byte of string
      00136A EB               [ 4] 3042         EX      DE,HL           ; Address to DE
      00136B F1               [10] 3043 POPAF:  POP     AF              ; Throw away status push
      00136C C9               [10] 3044         RET
                                   3045 
      00136D F1               [10] 3046 TESTOS: POP     AF              ; Garbage collect been done?
      00136E 1E 1A            [ 7] 3047         LD      E,#OS           ; ?OS Error
      001370 CA AC 05         [10] 3048         JP      Z,ERROR         ; Yes - Not enough string apace
      001373 BF               [ 4] 3049         CP      A               ; Flag garbage collect done
      001374 F5               [11] 3050         PUSH    AF              ; Save status
      001375 01 51 13         [10] 3051         LD      BC,#GRBDON      ; Garbage collection done
      001378 C5               [11] 3052         PUSH    BC              ; Save for RETurn
      001379 2A AF 23         [16] 3053 GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
      00137C 22 C3 23         [16] 3054 GARBLP: LD      (STRBOT),HL     ; Reset string pointer
      00137F 21 00 00         [10] 3055         LD      HL,#0
      001382 E5               [11] 3056         PUSH    HL              ; Flag no string found
      001383 2A 5A 23         [16] 3057         LD      HL,(STRSPC)     ; Get bottom of string space
      001386 E5               [11] 3058         PUSH    HL              ; Save bottom of string space
      001387 21 B3 23         [10] 3059         LD      HL,#TMSTPL      ; Temporary string pool
      00138A EB               [ 4] 3060 GRBLP:  EX      DE,HL
      00138B 2A B1 23         [16] 3061         LD      HL,(TMSTPT)     ; Temporary string pool pointer
      00138E EB               [ 4] 3062         EX      DE,HL
      00138F CD 60 08         [17] 3063         CALL    CPDEHL          ; Temporary string pool done?
      001392 01 8A 13         [10] 3064         LD      BC,#GRBLP       ; Loop until string pool done
      001395 C2 DE 13         [10] 3065         JP      NZ,STPOOL       ; No - See if in string area
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 57.
Hexadecimal [24-Bits]



      001398 2A D6 23         [16] 3066         LD      HL,(PROGND)     ; Start of simple variables
      00139B EB               [ 4] 3067 SMPVAR: EX      DE,HL
      00139C 2A D8 23         [16] 3068         LD      HL,(VAREND)     ; End of simple variables
      00139F EB               [ 4] 3069         EX      DE,HL
      0013A0 CD 60 08         [17] 3070         CALL    CPDEHL          ; All simple strings done?
      0013A3 CA B1 13         [10] 3071         JP      Z,ARRLP         ; Yes - Do string arrays
      0013A6 7E               [ 7] 3072         LD      A,(HL)          ; Get type of variable
      0013A7 23               [ 6] 3073         INC     HL
      0013A8 23               [ 6] 3074         INC     HL
      0013A9 B7               [ 4] 3075         OR      A               ; "S" flag set if string
      0013AA CD E1 13         [17] 3076         CALL    STRADD          ; See if string in string area
      0013AD C3 9B 13         [10] 3077         JP      SMPVAR          ; Loop until simple ones done
                                   3078 
      0013B0 C1               [10] 3079 GNXARY: POP     BC              ; Scrap address of this array
      0013B1 EB               [ 4] 3080 ARRLP:  EX      DE,HL
      0013B2 2A DA 23         [16] 3081         LD      HL,(ARREND)     ; End of string arrays
      0013B5 EB               [ 4] 3082         EX      DE,HL
      0013B6 CD 60 08         [17] 3083         CALL    CPDEHL          ; All string arrays done?
      0013B9 CA 07 14         [10] 3084         JP      Z,SCNEND        ; Yes - Move string if found
      0013BC CD 8E 18         [17] 3085         CALL    LOADFP          ; Get array name to BCDE
      0013BF 7B               [ 4] 3086         LD      A,E             ; Get type of array     
      0013C0 E5               [11] 3087         PUSH    HL              ; Save address of num of dim'ns
      0013C1 09               [11] 3088         ADD     HL,BC           ; Start of next array
      0013C2 B7               [ 4] 3089         OR      A               ; Test type of array
      0013C3 F2 B0 13         [10] 3090         JP      P,GNXARY        ; Numeric array - Ignore it
      0013C6 22 C5 23         [16] 3091         LD      (CUROPR),HL     ; Save address of next array
      0013C9 E1               [10] 3092         POP     HL              ; Get address of num of dim'ns
      0013CA 4E               [ 7] 3093         LD      C,(HL)          ; BC = Number of dimensions
      0013CB 06 00            [ 7] 3094         LD      B,#0
      0013CD 09               [11] 3095         ADD     HL,BC           ; Two bytes per dimension size
      0013CE 09               [11] 3096         ADD     HL,BC
      0013CF 23               [ 6] 3097         INC     HL              ; Plus one for number of dim'ns
      0013D0 EB               [ 4] 3098 GRBARY: EX      DE,HL
      0013D1 2A C5 23         [16] 3099         LD      HL,(CUROPR)     ; Get address of next array
      0013D4 EB               [ 4] 3100         EX      DE,HL
      0013D5 CD 60 08         [17] 3101         CALL    CPDEHL          ; Is this array finished?
      0013D8 CA B1 13         [10] 3102         JP      Z,ARRLP         ; Yes - Get next one
      0013DB 01 D0 13         [10] 3103         LD      BC,#GRBARY      ; Loop until array all done
      0013DE C5               [11] 3104 STPOOL: PUSH    BC              ; Save return address
      0013DF F6 80            [ 7] 3105         OR      #0x80           ; Flag string type
      0013E1 7E               [ 7] 3106 STRADD: LD      A,(HL)          ; Get string length
      0013E2 23               [ 6] 3107         INC     HL
      0013E3 23               [ 6] 3108         INC     HL
      0013E4 5E               [ 7] 3109         LD      E,(HL)          ; Get LSB of string address
      0013E5 23               [ 6] 3110         INC     HL
      0013E6 56               [ 7] 3111         LD      D,(HL)          ; Get MSB of string address
      0013E7 23               [ 6] 3112         INC     HL
      0013E8 F0               [11] 3113         RET     P               ; Not a string - Return
      0013E9 B7               [ 4] 3114         OR      A               ; Set flags on string length
      0013EA C8               [11] 3115         RET     Z               ; Null string - Return
      0013EB 44               [ 4] 3116         LD      B,H             ; Save variable pointer
      0013EC 4D               [ 4] 3117         LD      C,L
      0013ED 2A C3 23         [16] 3118         LD      HL,(STRBOT)     ; Bottom of new area
      0013F0 CD 60 08         [17] 3119         CALL    CPDEHL          ; String been done?
      0013F3 60               [ 4] 3120         LD      H,B             ; Restore variable pointer
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 58.
Hexadecimal [24-Bits]



      0013F4 69               [ 4] 3121         LD      L,C
      0013F5 D8               [11] 3122         RET     C               ; String done - Ignore
      0013F6 E1               [10] 3123         POP     HL              ; Return address
      0013F7 E3               [19] 3124         EX      (SP),HL         ; Lowest available string area
      0013F8 CD 60 08         [17] 3125         CALL    CPDEHL          ; String within string area?
      0013FB E3               [19] 3126         EX      (SP),HL         ; Lowest available string area
      0013FC E5               [11] 3127         PUSH    HL              ; Re-save return address
      0013FD 60               [ 4] 3128         LD      H,B             ; Restore variable pointer
      0013FE 69               [ 4] 3129         LD      L,C
      0013FF D0               [11] 3130         RET     NC              ; Outside string area - Ignore
      001400 C1               [10] 3131         POP     BC              ; Get return , Throw 2 away
      001401 F1               [10] 3132         POP     AF              ; 
      001402 F1               [10] 3133         POP     AF              ; 
      001403 E5               [11] 3134         PUSH    HL              ; Save variable pointer
      001404 D5               [11] 3135         PUSH    DE              ; Save address of current
      001405 C5               [11] 3136         PUSH    BC              ; Put back return address
      001406 C9               [10] 3137         RET                     ; Go to it
                                   3138 
      001407 D1               [10] 3139 SCNEND: POP     DE              ; Addresses of strings
      001408 E1               [10] 3140         POP     HL              ; 
      001409 7D               [ 4] 3141         LD      A,L             ; HL = 0 if no more to do
      00140A B4               [ 4] 3142         OR      H
      00140B C8               [11] 3143         RET     Z               ; No more to do - Return
      00140C 2B               [ 6] 3144         DEC     HL
      00140D 46               [ 7] 3145         LD      B,(HL)          ; MSB of address of string
      00140E 2B               [ 6] 3146         DEC     HL
      00140F 4E               [ 7] 3147         LD      C,(HL)          ; LSB of address of string
      001410 E5               [11] 3148         PUSH    HL              ; Save variable address
      001411 2B               [ 6] 3149         DEC     HL
      001412 2B               [ 6] 3150         DEC     HL
      001413 6E               [ 7] 3151         LD      L,(HL)          ; HL = Length of string
      001414 26 00            [ 7] 3152         LD      H,#0
      001416 09               [11] 3153         ADD     HL,BC           ; Address of end of string+1
      001417 50               [ 4] 3154         LD      D,B             ; String address to DE
      001418 59               [ 4] 3155         LD      E,C
      001419 2B               [ 6] 3156         DEC     HL              ; Last byte in string
      00141A 44               [ 4] 3157         LD      B,H             ; Address to BC
      00141B 4D               [ 4] 3158         LD      C,L
      00141C 2A C3 23         [16] 3159         LD      HL,(STRBOT)     ; Current bottom of string area
      00141F CD 67 05         [17] 3160         CALL    MOVSTR          ; Move string to new address
      001422 E1               [10] 3161         POP     HL              ; Restore variable address
      001423 71               [ 7] 3162         LD      (HL),C          ; Save new LSB of address
      001424 23               [ 6] 3163         INC     HL
      001425 70               [ 7] 3164         LD      (HL),B          ; Save new MSB of address
      001426 69               [ 4] 3165         LD      L,C             ; Next string area+1 to HL
      001427 60               [ 4] 3166         LD      H,B
      001428 2B               [ 6] 3167         DEC     HL              ; Next string area address
      001429 C3 7C 13         [10] 3168         JP      GARBLP          ; Look for more strings
                                   3169 
      00142C C5               [11] 3170 CONCAT: PUSH    BC              ; Save prec' opr & code string
      00142D E5               [11] 3171         PUSH    HL              ; 
      00142E 2A E4 23         [16] 3172         LD      HL,(FPREG)      ; Get first string
      001431 E3               [19] 3173         EX      (SP),HL         ; Save first string
      001432 CD E6 0E         [17] 3174         CALL    OPRND           ; Get second string
      001435 E3               [19] 3175         EX      (SP),HL         ; Restore first string
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 59.
Hexadecimal [24-Bits]



      001436 CD 61 0E         [17] 3176         CALL    TSTSTR          ; Make sure it's a string
      001439 7E               [ 7] 3177         LD      A,(HL)          ; Get length of second string
      00143A E5               [11] 3178         PUSH    HL              ; Save first string
      00143B 2A E4 23         [16] 3179         LD      HL,(FPREG)      ; Get second string
      00143E E5               [11] 3180         PUSH    HL              ; Save second string
      00143F 86               [ 7] 3181         ADD     A,(HL)          ; Add length of second string
      001440 1E 1C            [ 7] 3182         LD      E,#LS           ; ?LS Error
      001442 DA AC 05         [10] 3183         JP      C,ERROR         ; String too long - Error
      001445 CD E5 12         [17] 3184         CALL    MKTMST          ; Make temporary string
      001448 D1               [10] 3185         POP     DE              ; Get second string to DE
      001449 CD 7D 14         [17] 3186         CALL    GSTRDE          ; Move to string pool if needed
      00144C E3               [19] 3187         EX      (SP),HL         ; Get first string
      00144D CD 7C 14         [17] 3188         CALL    GSTRHL          ; Move to string pool if needed
      001450 E5               [11] 3189         PUSH    HL              ; Save first string
      001451 2A C1 23         [16] 3190         LD      HL,(TMPSTR+2)   ; Temporary string address
      001454 EB               [ 4] 3191         EX      DE,HL           ; To DE
      001455 CD 63 14         [17] 3192         CALL    SSTSA           ; First string to string area
      001458 CD 63 14         [17] 3193         CALL    SSTSA           ; Second string to string area
      00145B 21 7B 0E         [10] 3194         LD      HL,#EVAL2       ; Return to evaluation loop
      00145E E3               [19] 3195         EX      (SP),HL         ; Save return,get code string
      00145F E5               [11] 3196         PUSH    HL              ; Save code string address
      001460 C3 16 13         [10] 3197         JP      TSTOPL          ; To temporary string to pool
                                   3198 
      001463 E1               [10] 3199 SSTSA:  POP     HL              ; Return address
      001464 E3               [19] 3200         EX      (SP),HL         ; Get string block,save return
      001465 7E               [ 7] 3201         LD      A,(HL)          ; Get length of string
      001466 23               [ 6] 3202         INC     HL
      001467 23               [ 6] 3203         INC     HL
      001468 4E               [ 7] 3204         LD      C,(HL)          ; Get LSB of string address
      001469 23               [ 6] 3205         INC     HL
      00146A 46               [ 7] 3206         LD      B,(HL)          ; Get MSB of string address
      00146B 6F               [ 4] 3207         LD      L,A             ; Length to L
      00146C 2C               [ 4] 3208 TOSTRA: INC     L               ; INC - DECed after
      00146D 2D               [ 4] 3209 TSALP:  DEC     L               ; Count bytes moved
      00146E C8               [11] 3210         RET     Z               ; End of string - Return
      00146F 0A               [ 7] 3211         LD      A,(BC)          ; Get source
      001470 12               [ 7] 3212         LD      (DE),A          ; Save destination
      001471 03               [ 6] 3213         INC     BC              ; Next source
      001472 13               [ 6] 3214         INC     DE              ; Next destination
      001473 C3 6D 14         [10] 3215         JP      TSALP           ; Loop until string moved
                                   3216 
      001476 CD 61 0E         [17] 3217 GETSTR: CALL    TSTSTR          ; Make sure it's a string
      001479 2A E4 23         [16] 3218 GSTRCU: LD      HL,(FPREG)      ; Get current string
      00147C EB               [ 4] 3219 GSTRHL: EX      DE,HL           ; Save DE
      00147D CD 97 14         [17] 3220 GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
      001480 EB               [ 4] 3221         EX      DE,HL           ; Restore DE
      001481 C0               [11] 3222         RET     NZ              ; No - Return
      001482 D5               [11] 3223         PUSH    DE              ; Save string
      001483 50               [ 4] 3224         LD      D,B             ; String block address to DE
      001484 59               [ 4] 3225         LD      E,C
      001485 1B               [ 6] 3226         DEC     DE              ; Point to length
      001486 4E               [ 7] 3227         LD      C,(HL)          ; Get string length
      001487 2A C3 23         [16] 3228         LD      HL,(STRBOT)     ; Current bottom of string area
      00148A CD 60 08         [17] 3229         CALL    CPDEHL          ; Last one in string area?
      00148D C2 95 14         [10] 3230         JP      NZ,POPHL        ; No - Return
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 60.
Hexadecimal [24-Bits]



      001490 47               [ 4] 3231         LD      B,A             ; Clear B (A=0)
      001491 09               [11] 3232         ADD     HL,BC           ; Remove string from str' area
      001492 22 C3 23         [16] 3233         LD      (STRBOT),HL     ; Save new bottom of str' area
      001495 E1               [10] 3234 POPHL:  POP     HL              ; Restore string
      001496 C9               [10] 3235         RET
                                   3236 
      001497 2A B1 23         [16] 3237 BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
      00149A 2B               [ 6] 3238         DEC     HL              ; Back
      00149B 46               [ 7] 3239         LD      B,(HL)          ; Get MSB of address
      00149C 2B               [ 6] 3240         DEC     HL              ; Back
      00149D 4E               [ 7] 3241         LD      C,(HL)          ; Get LSB of address
      00149E 2B               [ 6] 3242         DEC     HL              ; Back
      00149F 2B               [ 6] 3243         DEC     HL              ; Back
      0014A0 CD 60 08         [17] 3244         CALL    CPDEHL          ; String last in string pool?
      0014A3 C0               [11] 3245         RET     NZ              ; Yes - Leave it
      0014A4 22 B1 23         [16] 3246         LD      (TMSTPT),HL     ; Save new string pool top
      0014A7 C9               [10] 3247         RET
                                   3248 
      0014A8 01 27 12         [10] 3249 LEN:    LD      BC,#PASSA       ; To return integer A
      0014AB C5               [11] 3250         PUSH    BC              ; Save address
      0014AC CD 76 14         [17] 3251 GETLEN: CALL    GETSTR          ; Get string and its length
      0014AF AF               [ 4] 3252         XOR     A
      0014B0 57               [ 4] 3253         LD      D,A             ; Clear D
      0014B1 32 AD 23         [13] 3254         LD      (TYPE),A        ; Set type to numeric
      0014B4 7E               [ 7] 3255         LD      A,(HL)          ; Get length of string
      0014B5 B7               [ 4] 3256         OR      A               ; Set status flags
      0014B6 C9               [10] 3257         RET
                                   3258 
      0014B7 01 27 12         [10] 3259 ASC:    LD      BC,#PASSA       ; To return integer A
      0014BA C5               [11] 3260         PUSH    BC              ; Save address
      0014BB CD AC 14         [17] 3261 GTFLNM: CALL    GETLEN          ; Get length of string
      0014BE CA B7 0A         [10] 3262         JP      Z,FCERR         ; Null string - Error
      0014C1 23               [ 6] 3263         INC     HL
      0014C2 23               [ 6] 3264         INC     HL
      0014C3 5E               [ 7] 3265         LD      E,(HL)          ; Get LSB of address
      0014C4 23               [ 6] 3266         INC     HL
      0014C5 56               [ 7] 3267         LD      D,(HL)          ; Get MSB of address
      0014C6 1A               [ 7] 3268         LD      A,(DE)          ; Get first byte of string
      0014C7 C9               [10] 3269         RET
                                   3270 
      0014C8 3E 01            [ 7] 3271 CHR:    LD      A,#1            ; One character string
      0014CA CD E5 12         [17] 3272         CALL    MKTMST          ; Make a temporary string
      0014CD CD C1 15         [17] 3273         CALL    MAKINT          ; Make it integer A
      0014D0 2A C1 23         [16] 3274         LD      HL,(TMPSTR+2)   ; Get address of string
      0014D3 73               [ 7] 3275         LD      (HL),E          ; Save character
      0014D4 C1               [10] 3276 TOPOOL: POP     BC              ; Clean up stack
      0014D5 C3 16 13         [10] 3277         JP      TSTOPL          ; Temporary string to pool
                                   3278 
      0014D8 CD 71 15         [17] 3279 LEFT:   CALL    LFRGNM          ; Get number and ending ")"
      0014DB AF               [ 4] 3280         XOR     A               ; Start at first byte in string
      0014DC E3               [19] 3281 RIGHT1: EX      (SP),HL         ; Save code string,Get string
      0014DD 4F               [ 4] 3282         LD      C,A             ; Starting position in string
      0014DE E5               [11] 3283 MID1:   PUSH    HL              ; Save string block address
      0014DF 7E               [ 7] 3284         LD      A,(HL)          ; Get length of string
      0014E0 B8               [ 4] 3285         CP      B               ; Compare with number given
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 61.
Hexadecimal [24-Bits]



      0014E1 DA E6 14         [10] 3286         JP      C,ALLFOL        ; All following bytes required
      0014E4 78               [ 4] 3287         LD      A,B             ; Get new length
      0014E5 11                    3288         .BYTE      0x11         ; Skip "LD C,0"
      0014E6 0E 00            [ 7] 3289 ALLFOL: LD      C,#0            ; First byte of string
      0014E8 C5               [11] 3290         PUSH    BC              ; Save position in string
      0014E9 CD 4F 13         [17] 3291         CALL    TESTR           ; See if enough string space
      0014EC C1               [10] 3292         POP     BC              ; Get position in string
      0014ED E1               [10] 3293         POP     HL              ; Restore string block address
      0014EE E5               [11] 3294         PUSH    HL              ; And re-save it
      0014EF 23               [ 6] 3295         INC     HL
      0014F0 23               [ 6] 3296         INC     HL
      0014F1 46               [ 7] 3297         LD      B,(HL)          ; Get LSB of address
      0014F2 23               [ 6] 3298         INC     HL
      0014F3 66               [ 7] 3299         LD      H,(HL)          ; Get MSB of address
      0014F4 68               [ 4] 3300         LD      L,B             ; HL = address of string
      0014F5 06 00            [ 7] 3301         LD      B,#0            ; BC = starting address
      0014F7 09               [11] 3302         ADD     HL,BC           ; Point to that byte
      0014F8 44               [ 4] 3303         LD      B,H             ; BC = source string
      0014F9 4D               [ 4] 3304         LD      C,L
      0014FA CD E8 12         [17] 3305         CALL    CRTMST          ; Create a string entry
      0014FD 6F               [ 4] 3306         LD      L,A             ; Length of new string
      0014FE CD 6C 14         [17] 3307         CALL    TOSTRA          ; Move string to string area
      001501 D1               [10] 3308         POP     DE              ; Clear stack
      001502 CD 7D 14         [17] 3309         CALL    GSTRDE          ; Move to string pool if needed
      001505 C3 16 13         [10] 3310         JP      TSTOPL          ; Temporary string to pool
                                   3311 
      001508 CD 71 15         [17] 3312 RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
      00150B D1               [10] 3313         POP     DE              ; Get string length
      00150C D5               [11] 3314         PUSH    DE              ; And re-save
      00150D 1A               [ 7] 3315         LD      A,(DE)          ; Get length
      00150E 90               [ 4] 3316         SUB     B               ; Move back N bytes
      00150F C3 DC 14         [10] 3317         JP      RIGHT1          ; Go and get sub-string
                                   3318 
      001512 EB               [ 4] 3319 MID:    EX      DE,HL           ; Get code string address
      001513 7E               [ 7] 3320         LD      A,(HL)          ; Get next byte ',' or ")"
      001514 CD 76 15         [17] 3321         CALL    MIDNUM          ; Get number supplied
      001517 04               [ 4] 3322         INC     B               ; Is it character zero?
      001518 05               [ 4] 3323         DEC     B
      001519 CA B7 0A         [10] 3324         JP      Z,FCERR         ; Yes - Error
      00151C C5               [11] 3325         PUSH    BC              ; Save starting position
      00151D 1E FF            [ 7] 3326         LD      E,#255          ; All of string
      00151F FE 29            [ 7] 3327         CP      #')'            ; Any length given?
      001521 CA 2B 15         [10] 3328         JP      Z,RSTSTR        ; No - Rest of string
      001524 CD 66 08         [17] 3329         CALL    CHKSYN          ; Make sure ',' follows
      001527 2C                    3330         .BYTE      ','
      001528 CD BE 15         [17] 3331         CALL    GETINT          ; Get integer 0-255
      00152B CD 66 08         [17] 3332 RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
      00152E 29                    3333         .BYTE      ")"
      00152F F1               [10] 3334         POP     AF              ; Restore starting position
      001530 E3               [19] 3335         EX      (SP),HL         ; Get string,8ave code string
      001531 01 DE 14         [10] 3336         LD      BC,#MID1        ; Continuation of MID$ routine
      001534 C5               [11] 3337         PUSH    BC              ; Save for return
      001535 3D               [ 4] 3338         DEC     A               ; Starting position-1
      001536 BE               [ 7] 3339         CP      (HL)            ; Compare with length
      001537 06 00            [ 7] 3340         LD      B,#0            ; Zero bytes length
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 62.
Hexadecimal [24-Bits]



      001539 D0               [11] 3341         RET     NC              ; Null string if start past end
      00153A 4F               [ 4] 3342         LD      C,A             ; Save starting position-1
      00153B 7E               [ 7] 3343         LD      A,(HL)          ; Get length of string
      00153C 91               [ 4] 3344         SUB     C               ; Subtract start
      00153D BB               [ 4] 3345         CP      E               ; Enough string for it?
      00153E 47               [ 4] 3346         LD      B,A             ; Save maximum length available
      00153F D8               [11] 3347         RET     C               ; Truncate string if needed
      001540 43               [ 4] 3348         LD      B,E             ; Set specified length
      001541 C9               [10] 3349         RET                     ; Go and create string
                                   3350 
      001542 CD AC 14         [17] 3351 VAL:    CALL    GETLEN          ; Get length of string
      001545 CA 5F 16         [10] 3352         JP      Z,RESZER        ; Result zero
      001548 5F               [ 4] 3353         LD      E,A             ; Save length
      001549 23               [ 6] 3354         INC     HL
      00154A 23               [ 6] 3355         INC     HL
      00154B 7E               [ 7] 3356         LD      A,(HL)          ; Get LSB of address
      00154C 23               [ 6] 3357         INC     HL
      00154D 66               [ 7] 3358         LD      H,(HL)          ; Get MSB of address
      00154E 6F               [ 4] 3359         LD      L,A             ; HL = String address
      00154F E5               [11] 3360         PUSH    HL              ; Save string address
      001550 19               [11] 3361         ADD     HL,DE
      001551 46               [ 7] 3362         LD      B,(HL)          ; Get end of string+1 byte
      001552 72               [ 7] 3363         LD      (HL),D          ; Zero it to terminate
      001553 E3               [19] 3364         EX      (SP),HL         ; Save string end,get start
      001554 C5               [11] 3365         PUSH    BC              ; Save end+1 byte
      001555 7E               [ 7] 3366         LD      A,(HL)          ; Get starting byte
      001556 FE 24            [ 7] 3367     CP	#'$'		; Hex number indicated? [function added]
      001558 C2 60 15         [10] 3368     JP	NZ,VAL1
      00155B CD 8A 1D         [17] 3369     CALL	HEXTFP		; Convert Hex to FPREG
      00155E 18 0D            [12] 3370     JR	VAL3
      001560 FE 25            [ 7] 3371 VAL1:	CP	#'%'		; Binary number indicated? [function added]
      001562 C2 6A 15         [10] 3372     JP	NZ,VAL2
      001565 CD FA 1D         [17] 3373     CALL	BINTFP		; Convert Bin to FPREG
      001568 18 03            [12] 3374     JR	VAL3
      00156A CD 46 19         [17] 3375 VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
      00156D C1               [10] 3376 VAL3:   POP     BC              ; Restore end+1 byte
      00156E E1               [10] 3377         POP     HL              ; Restore end+1 address
      00156F 70               [ 7] 3378         LD      (HL),B          ; Put back original byte
      001570 C9               [10] 3379         RET
                                   3380 
      001571 EB               [ 4] 3381 LFRGNM: EX      DE,HL           ; Code string address to HL
      001572 CD 66 08         [17] 3382         CALL    CHKSYN          ; Make sure ")" follows
      001575 29                    3383         .BYTE      ")"
      001576 C1               [10] 3384 MIDNUM: POP     BC              ; Get return address
      001577 D1               [10] 3385         POP     DE              ; Get number supplied
      001578 C5               [11] 3386         PUSH    BC              ; Re-save return address
      001579 43               [ 4] 3387         LD      B,E             ; Number to B
      00157A C9               [10] 3388         RET
                                   3389 
      00157B CD C1 15         [17] 3390 INP:    CALL    MAKINT          ; Make it integer A
      00157E 32 3F 23         [13] 3391         LD      (INPORT),A      ; Set input port
      001581 CD 3E 23         [17] 3392         CALL    INPSUB          ; Get input from port
      001584 C3 27 12         [10] 3393         JP      PASSA           ; Return integer A
                                   3394 
      001587 CD AB 15         [17] 3395 POUT:   CALL    SETIO           ; Set up port number
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 63.
Hexadecimal [24-Bits]



      00158A C3 06 23         [10] 3396         JP      OUTSUB          ; Output data and return
                                   3397 
      00158D CD AB 15         [17] 3398 WAIT:   CALL    SETIO           ; Set up port number
      001590 F5               [11] 3399         PUSH    AF              ; Save AND mask
      001591 1E 00            [ 7] 3400         LD      E,#0            ; Assume zero if none given
      001593 2B               [ 6] 3401         DEC     HL              ; DEC 'cos GETCHR INCs
      001594 CD F0 09         [17] 3402         CALL    GETCHR          ; Get next character
      001597 CA A1 15         [10] 3403         JP      Z,NOXOR         ; No XOR byte given
      00159A CD 66 08         [17] 3404         CALL    CHKSYN          ; Make sure ',' follows
      00159D 2C                    3405         .BYTE      ','
      00159E CD BE 15         [17] 3406         CALL    GETINT          ; Get integer 0-255 to XOR with
      0015A1 C1               [10] 3407 NOXOR:  POP     BC              ; Restore AND mask
      0015A2 CD 3E 23         [17] 3408 WAITLP: CALL    INPSUB          ; Get input
      0015A5 AB               [ 4] 3409         XOR     E               ; Flip selected bits
      0015A6 A0               [ 4] 3410         AND     B               ; Result non-zero?
      0015A7 CA A2 15         [10] 3411         JP      Z,WAITLP        ; No = keep waiting
      0015AA C9               [10] 3412         RET
                                   3413 
      0015AB CD BE 15         [17] 3414 SETIO:  CALL    GETINT          ; Get integer 0-255
      0015AE 32 3F 23         [13] 3415         LD      (INPORT),A      ; Set input port
      0015B1 32 07 23         [13] 3416         LD      (OTPORT),A      ; Set output port
      0015B4 CD 66 08         [17] 3417         CALL    CHKSYN          ; Make sure ',' follows
      0015B7 2C                    3418         .BYTE      ','
      0015B8 C3 BE 15         [10] 3419         JP      GETINT          ; Get integer 0-255 and return
                                   3420 
      0015BB CD F0 09         [17] 3421 FNDNUM: CALL    GETCHR          ; Get next character
      0015BE CD 5D 0E         [17] 3422 GETINT: CALL    GETNUM          ; Get a number from 0 to 255
      0015C1 CD 9C 0A         [17] 3423 MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
      0015C4 7A               [ 4] 3424         LD      A,D             ; Get MSB of number
      0015C5 B7               [ 4] 3425         OR      A               ; Zero?
      0015C6 C2 B7 0A         [10] 3426         JP      NZ,FCERR        ; No - Error
      0015C9 2B               [ 6] 3427         DEC     HL              ; DEC 'cos GETCHR INCs
      0015CA CD F0 09         [17] 3428         CALL    GETCHR          ; Get next character
      0015CD 7B               [ 4] 3429         LD      A,E             ; Get number to A
      0015CE C9               [10] 3430         RET
                                   3431 
      0015CF CD A2 0A         [17] 3432 PEEK:   CALL    DEINT           ; Get memory address
      0015D2 1A               [ 7] 3433         LD      A,(DE)          ; Get byte in memory
      0015D3 C3 27 12         [10] 3434         JP      PASSA           ; Return integer A
                                   3435 
      0015D6 CD 5D 0E         [17] 3436 POKE:   CALL    GETNUM          ; Get memory address
      0015D9 CD A2 0A         [17] 3437         CALL    DEINT           ; Get integer -32768 to 3276
      0015DC D5               [11] 3438         PUSH    DE              ; Save memory address
      0015DD CD 66 08         [17] 3439         CALL    CHKSYN          ; Make sure ',' follows
      0015E0 2C                    3440         .BYTE      ','
      0015E1 CD BE 15         [17] 3441         CALL    GETINT          ; Get integer 0-255
      0015E4 D1               [10] 3442         POP     DE              ; Restore memory address
      0015E5 12               [ 7] 3443         LD      (DE),A          ; Load it into memory
      0015E6 C9               [10] 3444         RET
                                   3445 
      0015E7 21 BD 1A         [10] 3446 ROUND:  LD      HL,#HALF        ; Add 0.5 to FPREG
      0015EA CD 8E 18         [17] 3447 ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
      0015ED C3 F9 15         [10] 3448         JP      FPADD           ; Add BCDE to FPREG
                                   3449 
      0015F0 CD 8E 18         [17] 3450 SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 64.
Hexadecimal [24-Bits]



      0015F3 21                    3451         .BYTE      0x21         ; Skip "POP BC" and "POP DE"
      0015F4 C1               [10] 3452 PSUB:   POP     BC              ; Get FP number from stack
      0015F5 D1               [10] 3453         POP     DE
      0015F6 CD 68 18         [17] 3454 SUBCDE: CALL    INVSGN          ; Negate FPREG
      0015F9 78               [ 4] 3455 FPADD:  LD      A,B             ; Get FP exponent
      0015FA B7               [ 4] 3456         OR      A               ; Is number zero?
      0015FB C8               [11] 3457         RET     Z               ; Yes - Nothing to add
      0015FC 3A E7 23         [13] 3458         LD      A,(FPEXP)       ; Get FPREG exponent
      0015FF B7               [ 4] 3459         OR      A               ; Is this number zero?
      001600 CA 80 18         [10] 3460         JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
      001603 90               [ 4] 3461         SUB     B               ; BCDE number larger?
      001604 D2 13 16         [10] 3462         JP      NC,NOSWAP       ; No - Don't swap them
      001607 2F               [ 4] 3463         CPL                     ; Two's complement
      001608 3C               [ 4] 3464         INC     A               ;  FP exponent
      001609 EB               [ 4] 3465         EX      DE,HL
      00160A CD 70 18         [17] 3466         CALL    STAKFP          ; Put FPREG on stack
      00160D EB               [ 4] 3467         EX      DE,HL
      00160E CD 80 18         [17] 3468         CALL    FPBCDE          ; Move BCDE to FPREG
      001611 C1               [10] 3469         POP     BC              ; Restore number from stack
      001612 D1               [10] 3470         POP     DE
      001613 FE 19            [ 7] 3471 NOSWAP: CP      #24+1           ; Second number insignificant?
      001615 D0               [11] 3472         RET     NC              ; Yes - First number is result
      001616 F5               [11] 3473         PUSH    AF              ; Save number of bits to scale
      001617 CD A5 18         [17] 3474         CALL    SIGNS           ; Set MSBs & sign of result
      00161A 67               [ 4] 3475         LD      H,A             ; Save sign of result
      00161B F1               [10] 3476         POP     AF              ; Restore scaling factor
      00161C CD BE 16         [17] 3477         CALL    SCALE           ; Scale BCDE to same exponent
      00161F B4               [ 4] 3478         OR      H               ; Result to be positive?
      001620 21 E4 23         [10] 3479         LD      HL,#FPREG       ; Point to FPREG
      001623 F2 39 16         [10] 3480         JP      P,MINCDE        ; No - Subtract FPREG from CDE
      001626 CD 9E 16         [17] 3481         CALL    PLUCDE          ; Add FPREG to CDE
      001629 D2 7F 16         [10] 3482         JP      NC,RONDUP       ; No overflow - Round it up
      00162C 23               [ 6] 3483         INC     HL              ; Point to exponent
      00162D 34               [11] 3484         INC     (HL)            ; Increment it
      00162E CA A7 05         [10] 3485         JP      Z,OVERR         ; Number overflowed - Error
      001631 2E 01            [ 7] 3486         LD      L,#1            ; 1 bit to shift right
      001633 CD D4 16         [17] 3487         CALL    SHRT1           ; Shift result right
      001636 C3 7F 16         [10] 3488         JP      RONDUP          ; Round it up
                                   3489 
      001639 AF               [ 4] 3490 MINCDE: XOR     A               ; Clear A and carry
      00163A 90               [ 4] 3491         SUB     B               ; Negate exponent
      00163B 47               [ 4] 3492         LD      B,A             ; Re-save exponent
      00163C 7E               [ 7] 3493         LD      A,(HL)          ; Get LSB of FPREG
      00163D 9B               [ 4] 3494         SBC     A, E            ; Subtract LSB of BCDE
      00163E 5F               [ 4] 3495         LD      E,A             ; Save LSB of BCDE
      00163F 23               [ 6] 3496         INC     HL
      001640 7E               [ 7] 3497         LD      A,(HL)          ; Get NMSB of FPREG
      001641 9A               [ 4] 3498         SBC     A,D             ; Subtract NMSB of BCDE
      001642 57               [ 4] 3499         LD      D,A             ; Save NMSB of BCDE
      001643 23               [ 6] 3500         INC     HL
      001644 7E               [ 7] 3501         LD      A,(HL)          ; Get MSB of FPREG
      001645 99               [ 4] 3502         SBC     A,C             ; Subtract MSB of BCDE
      001646 4F               [ 4] 3503         LD      C,A             ; Save MSB of BCDE
      001647 DC AA 16         [17] 3504 CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
                                   3505 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 65.
Hexadecimal [24-Bits]



      00164A 68               [ 4] 3506 BNORM:  LD      L,B             ; L = Exponent
      00164B 63               [ 4] 3507         LD      H,E             ; H = LSB
      00164C AF               [ 4] 3508         XOR     A
      00164D 47               [ 4] 3509 BNRMLP: LD      B,A             ; Save bit count
      00164E 79               [ 4] 3510         LD      A,C             ; Get MSB
      00164F B7               [ 4] 3511         OR      A               ; Is it zero?
      001650 C2 6C 16         [10] 3512         JP      NZ,PNORM        ; No - Do it bit at a time
      001653 4A               [ 4] 3513         LD      C,D             ; MSB = NMSB
      001654 54               [ 4] 3514         LD      D,H             ; NMSB= LSB
      001655 65               [ 4] 3515         LD      H,L             ; LSB = VLSB
      001656 6F               [ 4] 3516         LD      L,A             ; VLSB= 0
      001657 78               [ 4] 3517         LD      A,B             ; Get exponent
      001658 D6 08            [ 7] 3518         SUB     #8              ; Count 8 bits
      00165A FE E0            [ 7] 3519         CP      #-24-8          ; Was number zero?
      00165C C2 4D 16         [10] 3520         JP      NZ,BNRMLP       ; No - Keep normalising
      00165F AF               [ 4] 3521 RESZER: XOR     A               ; Result is zero
      001660 32 E7 23         [13] 3522 SAVEXP: LD      (FPEXP),A       ; Save result as zero
      001663 C9               [10] 3523         RET
                                   3524 
      001664 05               [ 4] 3525 NORMAL: DEC     B               ; Count bits
      001665 29               [11] 3526         ADD     HL,HL           ; Shift HL left
      001666 7A               [ 4] 3527         LD      A,D             ; Get NMSB
      001667 17               [ 4] 3528         RLA                     ; Shift left with last bit
      001668 57               [ 4] 3529         LD      D,A             ; Save NMSB
      001669 79               [ 4] 3530         LD      A,C             ; Get MSB
      00166A 8F               [ 4] 3531         ADC     A,A             ; Shift left with last bit
      00166B 4F               [ 4] 3532         LD      C,A             ; Save MSB
      00166C F2 64 16         [10] 3533 PNORM:  JP      P,NORMAL        ; Not done - Keep going
      00166F 78               [ 4] 3534         LD      A,B             ; Number of bits shifted
      001670 5C               [ 4] 3535         LD      E,H             ; Save HL in EB
      001671 45               [ 4] 3536         LD      B,L
      001672 B7               [ 4] 3537         OR      A               ; Any shifting done?
      001673 CA 7F 16         [10] 3538         JP      Z,RONDUP        ; No - Round it up
      001676 21 E7 23         [10] 3539         LD      HL,#FPEXP       ; Point to exponent
      001679 86               [ 7] 3540         ADD     A,(HL)          ; Add shifted bits
      00167A 77               [ 7] 3541         LD      (HL),A          ; Re-save exponent
      00167B D2 5F 16         [10] 3542         JP      NC,RESZER       ; Underflow - Result is zero
      00167E C8               [11] 3543         RET     Z               ; Result is zero
      00167F 78               [ 4] 3544 RONDUP: LD      A,B             ; Get VLSB of number
      001680 21 E7 23         [10] 3545 RONDB:  LD      HL,#FPEXP       ; Point to exponent
      001683 B7               [ 4] 3546         OR      A               ; Any rounding?
      001684 FC 91 16         [17] 3547         CALL    M,FPROND        ; Yes - Round number up
      001687 46               [ 7] 3548         LD      B,(HL)          ; B = Exponent
      001688 23               [ 6] 3549         INC     HL
      001689 7E               [ 7] 3550         LD      A,(HL)          ; Get sign of result
      00168A E6 80            [ 7] 3551         AND     #0b10000000     ; Only bit 7 needed
      00168C A9               [ 4] 3552         XOR     C               ; Set correct sign
      00168D 4F               [ 4] 3553         LD      C,A             ; Save correct sign in number
      00168E C3 80 18         [10] 3554         JP      FPBCDE          ; Move BCDE to FPREG
                                   3555 
      001691 1C               [ 4] 3556 FPROND: INC     E               ; Round LSB
      001692 C0               [11] 3557         RET     NZ              ; Return if ok
      001693 14               [ 4] 3558         INC     D               ; Round NMSB
      001694 C0               [11] 3559         RET     NZ              ; Return if ok
      001695 0C               [ 4] 3560         INC     C               ; Round MSB
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 66.
Hexadecimal [24-Bits]



      001696 C0               [11] 3561         RET     NZ              ; Return if ok
      001697 0E 80            [ 7] 3562         LD      C,#0x80         ; Set normal value
      001699 34               [11] 3563         INC     (HL)            ; Increment exponent
      00169A C0               [11] 3564         RET     NZ              ; Return if ok
      00169B C3 A7 05         [10] 3565         JP      OVERR           ; Overflow error
                                   3566 
      00169E 7E               [ 7] 3567 PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
      00169F 83               [ 4] 3568         ADD     A,E             ; Add LSB of BCDE
      0016A0 5F               [ 4] 3569         LD      E,A             ; Save LSB of BCDE
      0016A1 23               [ 6] 3570         INC     HL
      0016A2 7E               [ 7] 3571         LD      A,(HL)          ; Get NMSB of FPREG
      0016A3 8A               [ 4] 3572         ADC     A,D             ; Add NMSB of BCDE
      0016A4 57               [ 4] 3573         LD      D,A             ; Save NMSB of BCDE
      0016A5 23               [ 6] 3574         INC     HL
      0016A6 7E               [ 7] 3575         LD      A,(HL)          ; Get MSB of FPREG
      0016A7 89               [ 4] 3576         ADC     A,C             ; Add MSB of BCDE
      0016A8 4F               [ 4] 3577         LD      C,A             ; Save MSB of BCDE
      0016A9 C9               [10] 3578         RET
                                   3579 
      0016AA 21 E8 23         [10] 3580 COMPL:  LD      HL,#SGNRES      ; Sign of result
      0016AD 7E               [ 7] 3581         LD      A,(HL)          ; Get sign of result
      0016AE 2F               [ 4] 3582         CPL                     ; Negate it
      0016AF 77               [ 7] 3583         LD      (HL),A          ; Put it back
      0016B0 AF               [ 4] 3584         XOR     A
      0016B1 6F               [ 4] 3585         LD      L,A             ; Set L to zero
      0016B2 90               [ 4] 3586         SUB     B               ; Negate exponent,set carry
      0016B3 47               [ 4] 3587         LD      B,A             ; Re-save exponent
      0016B4 7D               [ 4] 3588         LD      A,L             ; Load zero
      0016B5 9B               [ 4] 3589         SBC     A,E             ; Negate LSB
      0016B6 5F               [ 4] 3590         LD      E,A             ; Re-save LSB
      0016B7 7D               [ 4] 3591         LD      A,L             ; Load zero
      0016B8 9A               [ 4] 3592         SBC     A,D             ; Negate NMSB
      0016B9 57               [ 4] 3593         LD      D,A             ; Re-save NMSB
      0016BA 7D               [ 4] 3594         LD      A,L             ; Load zero
      0016BB 99               [ 4] 3595         SBC     A,C             ; Negate MSB
      0016BC 4F               [ 4] 3596         LD      C,A             ; Re-save MSB
      0016BD C9               [10] 3597         RET
                                   3598 
      0016BE 06 00            [ 7] 3599 SCALE:  LD      B,#0            ; Clear underflow
      0016C0 D6 08            [ 7] 3600 SCALLP: SUB     #8              ; 8 bits (a whole byte)?
      0016C2 DA CD 16         [10] 3601         JP      C,SHRITE        ; No - Shift right A bits
      0016C5 43               [ 4] 3602         LD      B,E             ; <- Shift
      0016C6 5A               [ 4] 3603         LD      E,D             ; <- right
      0016C7 51               [ 4] 3604         LD      D,C             ; <- eight
      0016C8 0E 00            [ 7] 3605         LD      C,#0            ; <- bits
      0016CA C3 C0 16         [10] 3606         JP      SCALLP          ; More bits to shift
                                   3607 
      0016CD C6 09            [ 7] 3608 SHRITE: ADD     A,#8+1          ; Adjust count
      0016CF 6F               [ 4] 3609         LD      L,A             ; Save bits to shift
      0016D0 AF               [ 4] 3610 SHRLP:  XOR     A               ; Flag for all done
      0016D1 2D               [ 4] 3611         DEC     L               ; All shifting done?
      0016D2 C8               [11] 3612         RET     Z               ; Yes - Return
      0016D3 79               [ 4] 3613         LD      A,C             ; Get MSB
      0016D4 1F               [ 4] 3614 SHRT1:  RRA                     ; Shift it right
      0016D5 4F               [ 4] 3615         LD      C,A             ; Re-save
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 67.
Hexadecimal [24-Bits]



      0016D6 7A               [ 4] 3616         LD      A,D             ; Get NMSB
      0016D7 1F               [ 4] 3617         RRA                     ; Shift right with last bit
      0016D8 57               [ 4] 3618         LD      D,A             ; Re-save it
      0016D9 7B               [ 4] 3619         LD      A,E             ; Get LSB
      0016DA 1F               [ 4] 3620         RRA                     ; Shift right with last bit
      0016DB 5F               [ 4] 3621         LD      E,A             ; Re-save it
      0016DC 78               [ 4] 3622         LD      A,B             ; Get underflow
      0016DD 1F               [ 4] 3623         RRA                     ; Shift right with last bit
      0016DE 47               [ 4] 3624         LD      B,A             ; Re-save underflow
      0016DF C3 D0 16         [10] 3625         JP      SHRLP           ; More bits to do
                                   3626 
      0016E2 00 00 00 81           3627 UNITY:  .BYTE       0x00,0x00,0x00,0x81    ; 1.00000
                                   3628 
      0016E6 03                    3629 LOGTAB: .BYTE      3                       ; Table used by LOG
      0016E7 AA 56 19 80           3630         .BYTE      0xAA,0x56,0x19,0x80     ; 0.59898
      0016EB F1 22 76 80           3631         .BYTE      0xF1,0x22,0x76,0x80     ; 0.96147
      0016EF 45 AA 38 82           3632         .BYTE      0x45,0xAA,0x38,0x82     ; 2.88539
                                   3633 
      0016F3 CD 3F 18         [17] 3634 LOG:    CALL    TSTSGN          ; Test sign of value
      0016F6 B7               [ 4] 3635         OR      A
      0016F7 EA B7 0A         [10] 3636         JP      PE,FCERR        ; ?FC Error if <= zero
      0016FA 21 E7 23         [10] 3637         LD      HL,#FPEXP       ; Point to exponent
      0016FD 7E               [ 7] 3638         LD      A,(HL)          ; Get exponent
      0016FE 01 35 80         [10] 3639         LD      BC,#0x8035      ; BCDE = SQR(1/2)
      001701 11 F3 04         [10] 3640         LD      DE,#0x04F3
      001704 90               [ 4] 3641         SUB     B               ; Scale value to be < 1
      001705 F5               [11] 3642         PUSH    AF              ; Save scale factor
      001706 70               [ 7] 3643         LD      (HL),B          ; Save new exponent
      001707 D5               [11] 3644         PUSH    DE              ; Save SQR(1/2)
      001708 C5               [11] 3645         PUSH    BC
      001709 CD F9 15         [17] 3646         CALL    FPADD           ; Add SQR(1/2) to value
      00170C C1               [10] 3647         POP     BC              ; Restore SQR(1/2)
      00170D D1               [10] 3648         POP     DE
      00170E 04               [ 4] 3649         INC     B               ; Make it SQR(2)
      00170F CD 95 17         [17] 3650         CALL    DVBCDE          ; Divide by SQR(2)
      001712 21 E2 16         [10] 3651         LD      HL,#UNITY       ; Point to 1.
      001715 CD F0 15         [17] 3652         CALL    SUBPHL          ; Subtract FPREG from 1
      001718 21 E6 16         [10] 3653         LD      HL,#LOGTAB      ; Coefficient table
      00171B CD 87 1B         [17] 3654         CALL    SUMSER          ; Evaluate sum of series
      00171E 01 80 80         [10] 3655         LD      BC,#0x8080      ; BCDE = -0.5
      001721 11 00 00         [10] 3656         LD      DE,#0x0000
      001724 CD F9 15         [17] 3657         CALL    FPADD           ; Subtract 0.5 from FPREG
      001727 F1               [10] 3658         POP     AF              ; Restore scale factor
      001728 CD BA 19         [17] 3659         CALL    RSCALE          ; Re-scale number
      00172B 01 31 80         [10] 3660 MULLN2: LD      BC,#0x8031      ; BCDE = Ln(2)
      00172E 11 18 72         [10] 3661         LD      DE,#0x7218
      001731 21                    3662         .BYTE      0x21         ; Skip "POP BC" and "POP DE"
                                   3663 
      001732 C1               [10] 3664 MULT:   POP     BC              ; Get number from stack
      001733 D1               [10] 3665         POP     DE
      001734 CD 3F 18         [17] 3666 FPMULT: CALL    TSTSGN          ; Test sign of FPREG
      001737 C8               [11] 3667         RET     Z               ; Return zero if zero
      001738 2E 00            [ 7] 3668         LD      L,#0            ; Flag add exponents
      00173A CD FD 17         [17] 3669         CALL    ADDEXP          ; Add exponents
      00173D 79               [ 4] 3670         LD      A,C             ; Get MSB of multiplier
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 68.
Hexadecimal [24-Bits]



      00173E 32 F6 23         [13] 3671         LD      (MULVAL),A      ; Save MSB of multiplier
      001741 EB               [ 4] 3672         EX      DE,HL
      001742 22 F7 23         [16] 3673         LD      (MULVAL+1),HL   ; Save rest of multiplier
      001745 01 00 00         [10] 3674         LD      BC,#0           ; Partial product (BCDE) = zero
      001748 50               [ 4] 3675         LD      D,B
      001749 58               [ 4] 3676         LD      E,B
      00174A 21 4A 16         [10] 3677         LD      HL,#BNORM       ; Address of normalise
      00174D E5               [11] 3678         PUSH    HL              ; Save for return
      00174E 21 56 17         [10] 3679         LD      HL,#MULT8       ; Address of 8 bit multiply
      001751 E5               [11] 3680         PUSH    HL              ; Save for NMSB,MSB
      001752 E5               [11] 3681         PUSH    HL              ; 
      001753 21 E4 23         [10] 3682         LD      HL,#FPREG       ; Point to number
      001756 7E               [ 7] 3683 MULT8:  LD      A,(HL)          ; Get LSB of number
      001757 23               [ 6] 3684         INC     HL              ; Point to NMSB
      001758 B7               [ 4] 3685         OR      A               ; Test LSB
      001759 CA 82 17         [10] 3686         JP      Z,BYTSFT        ; Zero - shift to next byte
      00175C E5               [11] 3687         PUSH    HL              ; Save address of number
      00175D 2E 08            [ 7] 3688         LD      L,#8            ; 8 bits to multiply by
      00175F 1F               [ 4] 3689 MUL8LP: RRA                     ; Shift LSB right
      001760 67               [ 4] 3690         LD      H,A             ; Save LSB
      001761 79               [ 4] 3691         LD      A,C             ; Get MSB
      001762 D2 70 17         [10] 3692         JP      NC,NOMADD       ; Bit was zero - Don't add
      001765 E5               [11] 3693         PUSH    HL              ; Save LSB and count
      001766 2A F7 23         [16] 3694         LD      HL,(MULVAL+1)   ; Get LSB and NMSB
      001769 19               [11] 3695         ADD     HL,DE           ; Add NMSB and LSB
      00176A EB               [ 4] 3696         EX      DE,HL           ; Leave sum in DE
      00176B E1               [10] 3697         POP     HL              ; Restore MSB and count
      00176C 3A F6 23         [13] 3698         LD      A,(MULVAL)      ; Get MSB of multiplier
      00176F 89               [ 4] 3699         ADC     A,C             ; Add MSB
      001770 1F               [ 4] 3700 NOMADD: RRA                     ; Shift MSB right
      001771 4F               [ 4] 3701         LD      C,A             ; Re-save MSB
      001772 7A               [ 4] 3702         LD      A,D             ; Get NMSB
      001773 1F               [ 4] 3703         RRA                     ; Shift NMSB right
      001774 57               [ 4] 3704         LD      D,A             ; Re-save NMSB
      001775 7B               [ 4] 3705         LD      A,E             ; Get LSB
      001776 1F               [ 4] 3706         RRA                     ; Shift LSB right
      001777 5F               [ 4] 3707         LD      E,A             ; Re-save LSB
      001778 78               [ 4] 3708         LD      A,B             ; Get VLSB
      001779 1F               [ 4] 3709         RRA                     ; Shift VLSB right
      00177A 47               [ 4] 3710         LD      B,A             ; Re-save VLSB
      00177B 2D               [ 4] 3711         DEC     L               ; Count bits multiplied
      00177C 7C               [ 4] 3712         LD      A,H             ; Get LSB of multiplier
      00177D C2 5F 17         [10] 3713         JP      NZ,MUL8LP       ; More - Do it
      001780 E1               [10] 3714 POPHRT: POP     HL              ; Restore address of number
      001781 C9               [10] 3715         RET
                                   3716 
      001782 43               [ 4] 3717 BYTSFT: LD      B,E             ; Shift partial product left
      001783 5A               [ 4] 3718         LD      E,D
      001784 51               [ 4] 3719         LD      D,C
      001785 4F               [ 4] 3720         LD      C,A
      001786 C9               [10] 3721         RET
                                   3722 
      001787 CD 70 18         [17] 3723 DIV10:  CALL    STAKFP          ; Save FPREG on stack
      00178A 01 20 84         [10] 3724         LD      BC,#0x8420      ; BCDE = 10.
      00178D 11 00 00         [10] 3725         LD      DE,#0x0000
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 69.
Hexadecimal [24-Bits]



      001790 CD 80 18         [17] 3726         CALL    FPBCDE          ; Move 10 to FPREG
                                   3727 
      001793 C1               [10] 3728 DIV:    POP     BC              ; Get number from stack
      001794 D1               [10] 3729         POP     DE
      001795 CD 3F 18         [17] 3730 DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
      001798 CA 9B 05         [10] 3731         JP      Z,DZERR         ; Error if division by zero
      00179B 2E FF            [ 7] 3732         LD      L,#-1           ; Flag subtract exponents
      00179D CD FD 17         [17] 3733         CALL    ADDEXP          ; Subtract exponents
      0017A0 34               [11] 3734         INC     (HL)            ; Add 2 to exponent to adjust
      0017A1 34               [11] 3735         INC     (HL)
      0017A2 2B               [ 6] 3736         DEC     HL              ; Point to MSB
      0017A3 7E               [ 7] 3737         LD      A,(HL)          ; Get MSB of dividend
      0017A4 32 12 23         [13] 3738         LD      (DIV3),A        ; Save for subtraction
      0017A7 2B               [ 6] 3739         DEC     HL
      0017A8 7E               [ 7] 3740         LD      A,(HL)          ; Get NMSB of dividend
      0017A9 32 0E 23         [13] 3741         LD      (DIV2),A        ; Save for subtraction
      0017AC 2B               [ 6] 3742         DEC     HL
      0017AD 7E               [ 7] 3743         LD      A,(HL)          ; Get MSB of dividend
      0017AE 32 0A 23         [13] 3744         LD      (DIV1),A        ; Save for subtraction
      0017B1 41               [ 4] 3745         LD      B,C             ; Get MSB
      0017B2 EB               [ 4] 3746         EX      DE,HL           ; NMSB,LSB to HL
      0017B3 AF               [ 4] 3747         XOR     A
      0017B4 4F               [ 4] 3748         LD      C,A             ; Clear MSB of quotient
      0017B5 57               [ 4] 3749         LD      D,A             ; Clear NMSB of quotient
      0017B6 5F               [ 4] 3750         LD      E,A             ; Clear LSB of quotient
      0017B7 32 15 23         [13] 3751         LD      (DIV4),A        ; Clear overflow count
      0017BA E5               [11] 3752 DIVLP:  PUSH    HL              ; Save divisor
      0017BB C5               [11] 3753         PUSH    BC
      0017BC 7D               [ 4] 3754         LD      A,L             ; Get LSB of number
      0017BD CD 09 23         [17] 3755         CALL    DIVSUP          ; Subt' divisor from dividend
      0017C0 DE 00            [ 7] 3756         SBC     A,#0            ; Count for overflows
      0017C2 3F               [ 4] 3757         CCF
      0017C3 D2 CD 17         [10] 3758         JP      NC,RESDIV       ; Restore divisor if borrow
      0017C6 32 15 23         [13] 3759         LD      (DIV4),A        ; Re-save overflow count
      0017C9 F1               [10] 3760         POP     AF              ; Scrap divisor
      0017CA F1               [10] 3761         POP     AF
      0017CB 37               [ 4] 3762         SCF                     ; Set carry to
      0017CC D2                    3763         .BYTE      0xD2         ; Skip "POP BC" and "POP HL"
                                   3764 
      0017CD C1               [10] 3765 RESDIV: POP     BC              ; Restore divisor
      0017CE E1               [10] 3766         POP     HL
      0017CF 79               [ 4] 3767         LD      A,C             ; Get MSB of quotient
      0017D0 3C               [ 4] 3768         INC     A
      0017D1 3D               [ 4] 3769         DEC     A
      0017D2 1F               [ 4] 3770         RRA                     ; Bit 0 to bit 7
      0017D3 FA 80 16         [10] 3771         JP      M,RONDB         ; Done - Normalise result
      0017D6 17               [ 4] 3772         RLA                     ; Restore carry
      0017D7 7B               [ 4] 3773         LD      A,E             ; Get LSB of quotient
      0017D8 17               [ 4] 3774         RLA                     ; Double it
      0017D9 5F               [ 4] 3775         LD      E,A             ; Put it back
      0017DA 7A               [ 4] 3776         LD      A,D             ; Get NMSB of quotient
      0017DB 17               [ 4] 3777         RLA                     ; Double it
      0017DC 57               [ 4] 3778         LD      D,A             ; Put it back
      0017DD 79               [ 4] 3779         LD      A,C             ; Get MSB of quotient
      0017DE 17               [ 4] 3780         RLA                     ; Double it
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 70.
Hexadecimal [24-Bits]



      0017DF 4F               [ 4] 3781         LD      C,A             ; Put it back
      0017E0 29               [11] 3782         ADD     HL,HL           ; Double NMSB,LSB of divisor
      0017E1 78               [ 4] 3783         LD      A,B             ; Get MSB of divisor
      0017E2 17               [ 4] 3784         RLA                     ; Double it
      0017E3 47               [ 4] 3785         LD      B,A             ; Put it back
      0017E4 3A 15 23         [13] 3786         LD      A,(DIV4)        ; Get VLSB of quotient
      0017E7 17               [ 4] 3787         RLA                     ; Double it
      0017E8 32 15 23         [13] 3788         LD      (DIV4),A        ; Put it back
      0017EB 79               [ 4] 3789         LD      A,C             ; Get MSB of quotient
      0017EC B2               [ 4] 3790         OR      D               ; Merge NMSB
      0017ED B3               [ 4] 3791         OR      E               ; Merge LSB
      0017EE C2 BA 17         [10] 3792         JP      NZ,DIVLP        ; Not done - Keep dividing
      0017F1 E5               [11] 3793         PUSH    HL              ; Save divisor
      0017F2 21 E7 23         [10] 3794         LD      HL,#FPEXP       ; Point to exponent
      0017F5 35               [11] 3795         DEC     (HL)            ; Divide by 2
      0017F6 E1               [10] 3796         POP     HL              ; Restore divisor
      0017F7 C2 BA 17         [10] 3797         JP      NZ,DIVLP        ; Ok - Keep going
      0017FA C3 A7 05         [10] 3798         JP      OVERR           ; Overflow error
                                   3799 
      0017FD 78               [ 4] 3800 ADDEXP: LD      A,B             ; Get exponent of dividend
      0017FE B7               [ 4] 3801         OR      A               ; Test it
      0017FF CA 21 18         [10] 3802         JP      Z,OVTST3        ; Zero - Result zero
      001802 7D               [ 4] 3803         LD      A,L             ; Get add/subtract flag
      001803 21 E7 23         [10] 3804         LD      HL,#FPEXP       ; Point to exponent
      001806 AE               [ 7] 3805         XOR     (HL)            ; Add or subtract it
      001807 80               [ 4] 3806         ADD     A,B             ; Add the other exponent
      001808 47               [ 4] 3807         LD      B,A             ; Save new exponent
      001809 1F               [ 4] 3808         RRA                     ; Test exponent for overflow
      00180A A8               [ 4] 3809         XOR     B
      00180B 78               [ 4] 3810         LD      A,B             ; Get exponent
      00180C F2 20 18         [10] 3811         JP      P,OVTST2        ; Positive - Test for overflow
      00180F C6 80            [ 7] 3812         ADD     A,#0x80         ; Add excess 128
      001811 77               [ 7] 3813         LD      (HL),A          ; Save new exponent
      001812 CA 80 17         [10] 3814         JP      Z,POPHRT        ; Zero - Result zero
      001815 CD A5 18         [17] 3815         CALL    SIGNS           ; Set MSBs and sign of result
      001818 77               [ 7] 3816         LD      (HL),A          ; Save new exponent
      001819 2B               [ 6] 3817         DEC     HL              ; Point to MSB
      00181A C9               [10] 3818         RET
                                   3819 
      00181B CD 3F 18         [17] 3820 OVTST1: CALL    TSTSGN          ; Test sign of FPREG
      00181E 2F               [ 4] 3821         CPL                     ; Invert sign
      00181F E1               [10] 3822         POP     HL              ; Clean up stack
      001820 B7               [ 4] 3823 OVTST2: OR      A               ; Test if new exponent zero
      001821 E1               [10] 3824 OVTST3: POP     HL              ; Clear off return address
      001822 F2 5F 16         [10] 3825         JP      P,RESZER        ; Result zero
      001825 C3 A7 05         [10] 3826         JP      OVERR           ; Overflow error
                                   3827 
      001828 CD 8B 18         [17] 3828 MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
      00182B 78               [ 4] 3829         LD      A,B             ; Get exponent
      00182C B7               [ 4] 3830         OR      A               ; Is it zero?
      00182D C8               [11] 3831         RET     Z               ; Yes - Result is zero
      00182E C6 02            [ 7] 3832         ADD     A,#2            ; Multiply by 4
      001830 DA A7 05         [10] 3833         JP      C,OVERR         ; Overflow - ?OV Error
      001833 47               [ 4] 3834         LD      B,A             ; Re-save exponent
      001834 CD F9 15         [17] 3835         CALL    FPADD           ; Add BCDE to FPREG (Times 5)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 71.
Hexadecimal [24-Bits]



      001837 21 E7 23         [10] 3836         LD      HL,#FPEXP       ; Point to exponent
      00183A 34               [11] 3837         INC     (HL)            ; Double number (Times 10)
      00183B C0               [11] 3838         RET     NZ              ; Ok - Return
      00183C C3 A7 05         [10] 3839         JP      OVERR           ; Overflow error
                                   3840 
      00183F 3A E7 23         [13] 3841 TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
      001842 B7               [ 4] 3842         OR      A
      001843 C8               [11] 3843         RET     Z               ; RETurn if number is zero
      001844 3A E6 23         [13] 3844         LD      A,(FPREG+2)     ; Get MSB of FPREG
      001847 FE                    3845         .BYTE      0xFE         ; Test sign
      001848 2F               [ 4] 3846 RETREL: CPL                     ; Invert sign
      001849 17               [ 4] 3847         RLA                     ; Sign bit to carry
      00184A 9F               [ 4] 3848 FLGDIF: SBC     A,A             ; Carry to all bits of A
      00184B C0               [11] 3849         RET     NZ              ; Return -1 if negative
      00184C 3C               [ 4] 3850         INC     A               ; Bump to +1
      00184D C9               [10] 3851         RET                     ; Positive - Return +1
                                   3852 
      00184E CD 3F 18         [17] 3853 SGN:    CALL    TSTSGN          ; Test sign of FPREG
      001851 06 88            [ 7] 3854 FLGREL: LD      B,#0x80+8       ; 8 bit integer in exponent
      001853 11 00 00         [10] 3855         LD      DE,#0           ; Zero NMSB and LSB
      001856 21 E7 23         [10] 3856 RETINT: LD      HL,#FPEXP       ; Point to exponent
      001859 4F               [ 4] 3857         LD      C,A             ; CDE = MSB,NMSB and LSB
      00185A 70               [ 7] 3858         LD      (HL),B          ; Save exponent
      00185B 06 00            [ 7] 3859         LD      B,#0            ; CDE = integer to normalise
      00185D 23               [ 6] 3860         INC     HL              ; Point to sign of result
      00185E 36 80            [10] 3861         LD      (HL),#0x80      ; Set sign of result
      001860 17               [ 4] 3862         RLA                     ; Carry = sign of integer
      001861 C3 47 16         [10] 3863         JP      CONPOS          ; Set sign of result
                                   3864 
      001864 CD 3F 18         [17] 3865 ABS:    CALL    TSTSGN          ; Test sign of FPREG
      001867 F0               [11] 3866         RET     P               ; Return if positive
      001868 21 E6 23         [10] 3867 INVSGN: LD      HL,#FPREG+2     ; Point to MSB
      00186B 7E               [ 7] 3868         LD      A,(HL)          ; Get sign of mantissa
      00186C EE 80            [ 7] 3869         XOR     #0x80           ; Invert sign of mantissa
      00186E 77               [ 7] 3870         LD      (HL),A          ; Re-save sign of mantissa
      00186F C9               [10] 3871         RET
                                   3872 
      001870 EB               [ 4] 3873 STAKFP: EX      DE,HL           ; Save code string address
      001871 2A E4 23         [16] 3874         LD      HL,(FPREG)      ; LSB,NLSB of FPREG
      001874 E3               [19] 3875         EX      (SP),HL         ; Stack them,get return
      001875 E5               [11] 3876         PUSH    HL              ; Re-save return
      001876 2A E6 23         [16] 3877         LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
      001879 E3               [19] 3878         EX      (SP),HL         ; Stack them,get return
      00187A E5               [11] 3879         PUSH    HL              ; Re-save return
      00187B EB               [ 4] 3880         EX      DE,HL           ; Restore code string address
      00187C C9               [10] 3881         RET
                                   3882 
      00187D CD 8E 18         [17] 3883 PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
      001880 EB               [ 4] 3884 FPBCDE: EX      DE,HL           ; Save code string address
      001881 22 E4 23         [16] 3885         LD      (FPREG),HL      ; Save LSB,NLSB of number
      001884 60               [ 4] 3886         LD      H,B             ; Exponent of number
      001885 69               [ 4] 3887         LD      L,C             ; MSB of number
      001886 22 E6 23         [16] 3888         LD      (FPREG+2),HL    ; Save MSB and exponent
      001889 EB               [ 4] 3889         EX      DE,HL           ; Restore code string address
      00188A C9               [10] 3890         RET
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 72.
Hexadecimal [24-Bits]



                                   3891 
      00188B 21 E4 23         [10] 3892 BCDEFP: LD      HL,#FPREG       ; Point to FPREG
      00188E 5E               [ 7] 3893 LOADFP: LD      E,(HL)          ; Get LSB of number
      00188F 23               [ 6] 3894         INC     HL
      001890 56               [ 7] 3895         LD      D,(HL)          ; Get NMSB of number
      001891 23               [ 6] 3896         INC     HL
      001892 4E               [ 7] 3897         LD      C,(HL)          ; Get MSB of number
      001893 23               [ 6] 3898         INC     HL
      001894 46               [ 7] 3899         LD      B,(HL)          ; Get exponent of number
      001895 23               [ 6] 3900 INCHL:  INC     HL              ; Used for conditional "INC HL"
      001896 C9               [10] 3901         RET
                                   3902 
      001897 11 E4 23         [10] 3903 FPTHL:  LD      DE,#FPREG       ; Point to FPREG
      00189A 06 04            [ 7] 3904 DETHL4: LD      B,#4            ; 4 bytes to move
      00189C 1A               [ 7] 3905 DETHLB: LD      A,(DE)          ; Get source
      00189D 77               [ 7] 3906         LD      (HL),A          ; Save destination
      00189E 13               [ 6] 3907         INC     DE              ; Next source
      00189F 23               [ 6] 3908         INC     HL              ; Next destination
      0018A0 05               [ 4] 3909         DEC     B               ; Count bytes
      0018A1 C2 9C 18         [10] 3910         JP      NZ,DETHLB       ; Loop if more
      0018A4 C9               [10] 3911         RET
                                   3912 
      0018A5 21 E6 23         [10] 3913 SIGNS:  LD      HL,#FPREG+2     ; Point to MSB of FPREG
      0018A8 7E               [ 7] 3914         LD      A,(HL)          ; Get MSB
      0018A9 07               [ 4] 3915         RLCA                    ; Old sign to carry
      0018AA 37               [ 4] 3916         SCF                     ; Set MSBit
      0018AB 1F               [ 4] 3917         RRA                     ; Set MSBit of MSB
      0018AC 77               [ 7] 3918         LD      (HL),A          ; Save new MSB
      0018AD 3F               [ 4] 3919         CCF                     ; Complement sign
      0018AE 1F               [ 4] 3920         RRA                     ; Old sign to carry
      0018AF 23               [ 6] 3921         INC     HL
      0018B0 23               [ 6] 3922         INC     HL
      0018B1 77               [ 7] 3923         LD      (HL),A          ; Set sign of result
      0018B2 79               [ 4] 3924         LD      A,C             ; Get MSB
      0018B3 07               [ 4] 3925         RLCA                    ; Old sign to carry
      0018B4 37               [ 4] 3926         SCF                     ; Set MSBit
      0018B5 1F               [ 4] 3927         RRA                     ; Set MSBit of MSB
      0018B6 4F               [ 4] 3928         LD      C,A             ; Save MSB
      0018B7 1F               [ 4] 3929         RRA
      0018B8 AE               [ 7] 3930         XOR     (HL)            ; New sign of result
      0018B9 C9               [10] 3931         RET
                                   3932 
      0018BA 78               [ 4] 3933 CMPNUM: LD      A,B             ; Get exponent of number
      0018BB B7               [ 4] 3934         OR      A
      0018BC CA 3F 18         [10] 3935         JP      Z,TSTSGN        ; Zero - Test sign of FPREG
      0018BF 21 48 18         [10] 3936         LD      HL,#RETREL      ; Return relation routine
      0018C2 E5               [11] 3937         PUSH    HL              ; Save for return
      0018C3 CD 3F 18         [17] 3938         CALL    TSTSGN          ; Test sign of FPREG
      0018C6 79               [ 4] 3939         LD      A,C             ; Get MSB of number
      0018C7 C8               [11] 3940         RET     Z               ; FPREG zero - Number's MSB
      0018C8 21 E6 23         [10] 3941         LD      HL,#FPREG+2     ; MSB of FPREG
      0018CB AE               [ 7] 3942         XOR     (HL)            ; Combine signs
      0018CC 79               [ 4] 3943         LD      A,C             ; Get MSB of number
      0018CD F8               [11] 3944         RET     M               ; Exit if signs different
      0018CE CD D4 18         [17] 3945         CALL    CMPFP           ; Compare FP numbers
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 73.
Hexadecimal [24-Bits]



      0018D1 1F               [ 4] 3946         RRA                     ; Get carry to sign
      0018D2 A9               [ 4] 3947         XOR     C               ; Combine with MSB of number
      0018D3 C9               [10] 3948         RET
                                   3949 
      0018D4 23               [ 6] 3950 CMPFP:  INC     HL              ; Point to exponent
      0018D5 78               [ 4] 3951         LD      A,B             ; Get exponent
      0018D6 BE               [ 7] 3952         CP      (HL)            ; Compare exponents
      0018D7 C0               [11] 3953         RET     NZ              ; Different
      0018D8 2B               [ 6] 3954         DEC     HL              ; Point to MBS
      0018D9 79               [ 4] 3955         LD      A,C             ; Get MSB
      0018DA BE               [ 7] 3956         CP      (HL)            ; Compare MSBs
      0018DB C0               [11] 3957         RET     NZ              ; Different
      0018DC 2B               [ 6] 3958         DEC     HL              ; Point to NMSB
      0018DD 7A               [ 4] 3959         LD      A,D             ; Get NMSB
      0018DE BE               [ 7] 3960         CP      (HL)            ; Compare NMSBs
      0018DF C0               [11] 3961         RET     NZ              ; Different
      0018E0 2B               [ 6] 3962         DEC     HL              ; Point to LSB
      0018E1 7B               [ 4] 3963         LD      A,E             ; Get LSB
      0018E2 96               [ 7] 3964         SUB     (HL)            ; Compare LSBs
      0018E3 C0               [11] 3965         RET     NZ              ; Different
      0018E4 E1               [10] 3966         POP     HL              ; Drop RETurn
      0018E5 E1               [10] 3967         POP     HL              ; Drop another RETurn
      0018E6 C9               [10] 3968         RET
                                   3969 
      0018E7 47               [ 4] 3970 FPINT:  LD      B,A             ; <- Move
      0018E8 4F               [ 4] 3971         LD      C,A             ; <- exponent
      0018E9 57               [ 4] 3972         LD      D,A             ; <- to all
      0018EA 5F               [ 4] 3973         LD      E,A             ; <- bits
      0018EB B7               [ 4] 3974         OR      A               ; Test exponent
      0018EC C8               [11] 3975         RET     Z               ; Zero - Return zero
      0018ED E5               [11] 3976         PUSH    HL              ; Save pointer to number
      0018EE CD 8B 18         [17] 3977         CALL    BCDEFP          ; Move FPREG to BCDE
      0018F1 CD A5 18         [17] 3978         CALL    SIGNS           ; Set MSBs & sign of result
      0018F4 AE               [ 7] 3979         XOR     (HL)            ; Combine with sign of FPREG
      0018F5 67               [ 4] 3980         LD      H,A             ; Save combined signs
      0018F6 FC 0B 19         [17] 3981         CALL    M,DCBCDE        ; Negative - Decrement BCDE
      0018F9 3E 98            [ 7] 3982         LD      A,#0x80+24      ; 24 bits
      0018FB 90               [ 4] 3983         SUB     B               ; Bits to shift
      0018FC CD BE 16         [17] 3984         CALL    SCALE           ; Shift BCDE
      0018FF 7C               [ 4] 3985         LD      A,H             ; Get combined sign
      001900 17               [ 4] 3986         RLA                     ; Sign to carry
      001901 DC 91 16         [17] 3987         CALL    C,FPROND        ; Negative - Round number up
      001904 06 00            [ 7] 3988         LD      B,#0            ; Zero exponent
      001906 DC AA 16         [17] 3989         CALL    C,COMPL         ; If negative make positive
      001909 E1               [10] 3990         POP     HL              ; Restore pointer to number
      00190A C9               [10] 3991         RET
                                   3992 
      00190B 1B               [ 6] 3993 DCBCDE: DEC     DE              ; Decrement BCDE
      00190C 7A               [ 4] 3994         LD      A,D             ; Test LSBs
      00190D A3               [ 4] 3995         AND     E
      00190E 3C               [ 4] 3996         INC     A
      00190F C0               [11] 3997         RET     NZ              ; Exit if LSBs not FFFF
      001910 0B               [ 6] 3998         DEC     BC              ; Decrement MSBs
      001911 C9               [10] 3999         RET
                                   4000 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 74.
Hexadecimal [24-Bits]



      001912 21 E7 23         [10] 4001 INT:    LD      HL,#FPEXP       ; Point to exponent
      001915 7E               [ 7] 4002         LD      A,(HL)          ; Get exponent
      001916 FE 98            [ 7] 4003         CP      #0x80+24        ; Integer accuracy only?
      001918 3A E4 23         [13] 4004         LD      A,(FPREG)       ; Get LSB
      00191B D0               [11] 4005         RET     NC              ; Yes - Already integer
      00191C 7E               [ 7] 4006         LD      A,(HL)          ; Get exponent
      00191D CD E7 18         [17] 4007         CALL    FPINT           ; F.P to integer
      001920 36 98            [10] 4008         LD      (HL),#0x80+24   ; Save 24 bit integer
      001922 7B               [ 4] 4009         LD      A,E             ; Get LSB of number
      001923 F5               [11] 4010         PUSH    AF              ; Save LSB
      001924 79               [ 4] 4011         LD      A,C             ; Get MSB of number
      001925 17               [ 4] 4012         RLA                     ; Sign to carry
      001926 CD 47 16         [17] 4013         CALL    CONPOS          ; Set sign of result
      001929 F1               [10] 4014         POP     AF              ; Restore LSB of number
      00192A C9               [10] 4015         RET
                                   4016 
      00192B 21 00 00         [10] 4017 MLDEBC: LD      HL,#0           ; Clear partial product
      00192E 78               [ 4] 4018         LD      A,B             ; Test multiplier
      00192F B1               [ 4] 4019         OR      C
      001930 C8               [11] 4020         RET     Z               ; Return zero if zero
      001931 3E 10            [ 7] 4021         LD      A,#16           ; 16 bits
      001933 29               [11] 4022 MLDBLP: ADD     HL,HL           ; Shift P.P left
      001934 DA 6B 11         [10] 4023         JP      C,BSERR         ; ?BS Error if overflow
      001937 EB               [ 4] 4024         EX      DE,HL
      001938 29               [11] 4025         ADD     HL,HL           ; Shift multiplier left
      001939 EB               [ 4] 4026         EX      DE,HL
      00193A D2 41 19         [10] 4027         JP      NC,NOMLAD       ; Bit was zero - No add
      00193D 09               [11] 4028         ADD     HL,BC           ; Add multiplicand
      00193E DA 6B 11         [10] 4029         JP      C,BSERR         ; ?BS Error if overflow
      001941 3D               [ 4] 4030 NOMLAD: DEC     A               ; Count bits
      001942 C2 33 19         [10] 4031         JP      NZ,MLDBLP       ; More
      001945 C9               [10] 4032         RET
                                   4033 
      001946 FE 2D            [ 7] 4034 ASCTFP: CP      #'-'            ; Negative?
      001948 F5               [11] 4035         PUSH    AF              ; Save it and flags
      001949 CA 52 19         [10] 4036         JP      Z,CNVNUM        ; Yes - Convert number
      00194C FE 2B            [ 7] 4037         CP      #'+'            ; Positive?
      00194E CA 52 19         [10] 4038         JP      Z,CNVNUM        ; Yes - Convert number
      001951 2B               [ 6] 4039         DEC     HL              ; DEC 'cos GETCHR INCs
      001952 CD 5F 16         [17] 4040 CNVNUM: CALL    RESZER          ; Set result to zero
      001955 47               [ 4] 4041         LD      B,A             ; Digits after point counter
      001956 57               [ 4] 4042         LD      D,A             ; Sign of exponent
      001957 5F               [ 4] 4043         LD      E,A             ; Exponent of ten
      001958 2F               [ 4] 4044         CPL
      001959 4F               [ 4] 4045         LD      C,A             ; Before or after point flag
      00195A CD F0 09         [17] 4046 MANLP:  CALL    GETCHR          ; Get next character
      00195D DA A3 19         [10] 4047         JP      C,ADDIG         ; Digit - Add to number
      001960 FE 2E            [ 7] 4048         CP      #'.'
      001962 CA 7E 19         [10] 4049         JP      Z,DPOINT        ; '.' - Flag point
      001965 FE 45            [ 7] 4050         CP      #'E'
      001967 C2 82 19         [10] 4051         JP      NZ,CONEXP       ; Not 'E' - Scale number
      00196A CD F0 09         [17] 4052         CALL    GETCHR          ; Get next character
      00196D CD 96 0F         [17] 4053         CALL    SGNEXP          ; Get sign of exponent
      001970 CD F0 09         [17] 4054 EXPLP:  CALL    GETCHR          ; Get next character
      001973 DA C5 19         [10] 4055         JP      C,EDIGIT        ; Digit - Add to exponent
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 75.
Hexadecimal [24-Bits]



      001976 14               [ 4] 4056         INC     D               ; Is sign negative?
      001977 C2 82 19         [10] 4057         JP      NZ,CONEXP       ; No - Scale number
      00197A AF               [ 4] 4058         XOR     A
      00197B 93               [ 4] 4059         SUB     E               ; Negate exponent
      00197C 5F               [ 4] 4060         LD      E,A             ; And re-save it
      00197D 0C               [ 4] 4061         INC     C               ; Flag end of number
      00197E 0C               [ 4] 4062 DPOINT: INC     C               ; Flag point passed
      00197F CA 5A 19         [10] 4063         JP      Z,MANLP         ; Zero - Get another digit
      001982 E5               [11] 4064 CONEXP: PUSH    HL              ; Save code string address
      001983 7B               [ 4] 4065         LD      A,E             ; Get exponent
      001984 90               [ 4] 4066         SUB     B               ; Subtract digits after point
      001985 F4 9B 19         [17] 4067 SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
      001988 F2 91 19         [10] 4068         JP      P,ENDCON        ; Positive - All done
      00198B F5               [11] 4069         PUSH    AF              ; Save number of times to /10
      00198C CD 87 17         [17] 4070         CALL    DIV10           ; Divide by 10
      00198F F1               [10] 4071         POP     AF              ; Restore count
      001990 3C               [ 4] 4072         INC     A               ; Count divides
                                   4073 
      001991 C2 85 19         [10] 4074 ENDCON: JP      NZ,SCALMI       ; More to do
      001994 D1               [10] 4075         POP     DE              ; Restore code string address
      001995 F1               [10] 4076         POP     AF              ; Restore sign of number
      001996 CC 68 18         [17] 4077         CALL    Z,INVSGN        ; Negative - Negate number
      001999 EB               [ 4] 4078         EX      DE,HL           ; Code string address to HL
      00199A C9               [10] 4079         RET
                                   4080 
      00199B C8               [11] 4081 SCALPL: RET     Z               ; Exit if no scaling needed
      00199C F5               [11] 4082 MULTEN: PUSH    AF              ; Save count
      00199D CD 28 18         [17] 4083         CALL    MLSP10          ; Multiply number by 10
      0019A0 F1               [10] 4084         POP     AF              ; Restore count
      0019A1 3D               [ 4] 4085         DEC     A               ; Count multiplies
      0019A2 C9               [10] 4086         RET
                                   4087 
      0019A3 D5               [11] 4088 ADDIG:  PUSH    DE              ; Save sign of exponent
      0019A4 57               [ 4] 4089         LD      D,A             ; Save digit
      0019A5 78               [ 4] 4090         LD      A,B             ; Get digits after point
      0019A6 89               [ 4] 4091         ADC     A,C             ; Add one if after point
      0019A7 47               [ 4] 4092         LD      B,A             ; Re-save counter
      0019A8 C5               [11] 4093         PUSH    BC              ; Save point flags
      0019A9 E5               [11] 4094         PUSH    HL              ; Save code string address
      0019AA D5               [11] 4095         PUSH    DE              ; Save digit
      0019AB CD 28 18         [17] 4096         CALL    MLSP10          ; Multiply number by 10
      0019AE F1               [10] 4097         POP     AF              ; Restore digit
      0019AF D6 30            [ 7] 4098         SUB     #'0'            ; Make it absolute
      0019B1 CD BA 19         [17] 4099         CALL    RSCALE          ; Re-scale number
      0019B4 E1               [10] 4100         POP     HL              ; Restore code string address
      0019B5 C1               [10] 4101         POP     BC              ; Restore point flags
      0019B6 D1               [10] 4102         POP     DE              ; Restore sign of exponent
      0019B7 C3 5A 19         [10] 4103         JP      MANLP           ; Get another digit
                                   4104 
      0019BA CD 70 18         [17] 4105 RSCALE: CALL    STAKFP          ; Put number on stack
      0019BD CD 51 18         [17] 4106         CALL    FLGREL          ; Digit to add to FPREG
      0019C0 C1               [10] 4107 PADD:   POP     BC              ; Restore number
      0019C1 D1               [10] 4108         POP     DE
      0019C2 C3 F9 15         [10] 4109         JP      FPADD           ; Add BCDE to FPREG and return
                                   4110 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 76.
Hexadecimal [24-Bits]



      0019C5 7B               [ 4] 4111 EDIGIT: LD      A,E             ; Get digit
      0019C6 07               [ 4] 4112         RLCA                    ; Times 2
      0019C7 07               [ 4] 4113         RLCA                    ; Times 4
      0019C8 83               [ 4] 4114         ADD     A,E             ; Times 5
      0019C9 07               [ 4] 4115         RLCA                    ; Times 10
      0019CA 86               [ 7] 4116         ADD     A,(HL)          ; Add next digit
      0019CB D6 30            [ 7] 4117         SUB     #'0'            ; Make it absolute
      0019CD 5F               [ 4] 4118         LD      E,A             ; Save new digit
      0019CE C3 70 19         [10] 4119         JP      EXPLP           ; Look for another digit
                                   4120 
      0019D1 E5               [11] 4121 LINEIN: PUSH    HL              ; Save code string address
      0019D2 21 30 05         [10] 4122         LD      HL,#INMSG       ; Output " in "
      0019D5 CD 36 13         [17] 4123         CALL    PRS             ; Output string at HL
      0019D8 E1               [10] 4124         POP     HL              ; Restore code string address
      0019D9 EB               [ 4] 4125 PRNTHL: EX      DE,HL           ; Code string address to DE
      0019DA AF               [ 4] 4126         XOR     A
      0019DB 06 98            [ 7] 4127         LD      B,#0x80+24        ; 24 bits
      0019DD CD 56 18         [17] 4128         CALL    RETINT          ; Return the integer
      0019E0 21 35 13         [10] 4129         LD      HL,#PRNUMS      ; Print number string
      0019E3 E5               [11] 4130         PUSH    HL              ; Save for return
      0019E4 21 E9 23         [10] 4131 NUMASC: LD      HL,#PBUFF       ; Convert number to ASCII
      0019E7 E5               [11] 4132         PUSH    HL              ; Save for return
      0019E8 CD 3F 18         [17] 4133         CALL    TSTSGN          ; Test sign of FPREG
      0019EB 36 20            [10] 4134         LD      (HL),#' '       ; Space at start
      0019ED F2 F2 19         [10] 4135         JP      P,SPCFST        ; Positive - Space to start
      0019F0 36 2D            [10] 4136         LD      (HL),#'-'       ; '-' sign at start
      0019F2 23               [ 6] 4137 SPCFST: INC     HL              ; First byte of number
      0019F3 36 30            [10] 4138         LD      (HL),#'0'       ; '0' if zero
      0019F5 CA A8 1A         [10] 4139         JP      Z,JSTZER        ; Return '0' if zero
      0019F8 E5               [11] 4140         PUSH    HL              ; Save buffer address
      0019F9 FC 68 18         [17] 4141         CALL    M,INVSGN        ; Negate FPREG if negative
      0019FC AF               [ 4] 4142         XOR     A               ; Zero A
      0019FD F5               [11] 4143         PUSH    AF              ; Save it
      0019FE CD AE 1A         [17] 4144         CALL    RNGTST          ; Test number is in range
      001A01 01 43 91         [10] 4145 SIXDIG: LD      BC,#0x9143      ; BCDE - 99999.9
      001A04 11 F8 4F         [10] 4146         LD      DE,#0x4FF8
      001A07 CD BA 18         [17] 4147         CALL    CMPNUM          ; Compare numbers
      001A0A B7               [ 4] 4148         OR      A
      001A0B E2 1F 1A         [10] 4149         JP      PO,INRNG        ; > 99999.9 - Sort it out
      001A0E F1               [10] 4150         POP     AF              ; Restore count
      001A0F CD 9C 19         [17] 4151         CALL    MULTEN          ; Multiply by ten
      001A12 F5               [11] 4152         PUSH    AF              ; Re-save count
      001A13 C3 01 1A         [10] 4153         JP      SIXDIG          ; Test it again
                                   4154 
      001A16 CD 87 17         [17] 4155 GTSIXD: CALL    DIV10           ; Divide by 10
      001A19 F1               [10] 4156         POP     AF              ; Get count
      001A1A 3C               [ 4] 4157         INC     A               ; Count divides
      001A1B F5               [11] 4158         PUSH    AF              ; Re-save count
      001A1C CD AE 1A         [17] 4159         CALL    RNGTST          ; Test number is in range
      001A1F CD E7 15         [17] 4160 INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
      001A22 3C               [ 4] 4161         INC     A
      001A23 CD E7 18         [17] 4162         CALL    FPINT           ; F.P to integer
      001A26 CD 80 18         [17] 4163         CALL    FPBCDE          ; Move BCDE to FPREG
      001A29 01 06 03         [10] 4164         LD      BC,#0x0306      ; 1E+06 to 1E-03 range
      001A2C F1               [10] 4165         POP     AF              ; Restore count
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 77.
Hexadecimal [24-Bits]



      001A2D 81               [ 4] 4166         ADD     A,C             ; 6 digits before point
      001A2E 3C               [ 4] 4167         INC     A               ; Add one
      001A2F FA 3B 1A         [10] 4168         JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
      001A32 FE 08            [ 7] 4169         CP      #6+1+1          ; More than 999999 ?
      001A34 D2 3B 1A         [10] 4170         JP      NC,MAKNUM       ; Yes - Do it in 'E' form
      001A37 3C               [ 4] 4171         INC     A               ; Adjust for exponent
      001A38 47               [ 4] 4172         LD      B,A             ; Exponent of number
      001A39 3E 02            [ 7] 4173         LD      A,#2            ; Make it zero after
                                   4174 
      001A3B 3D               [ 4] 4175 MAKNUM: DEC     A               ; Adjust for digits to do
      001A3C 3D               [ 4] 4176         DEC     A
      001A3D E1               [10] 4177         POP     HL              ; Restore buffer address
      001A3E F5               [11] 4178         PUSH    AF              ; Save count
      001A3F 11 C1 1A         [10] 4179         LD      DE,#POWERS      ; Powers of ten
      001A42 05               [ 4] 4180         DEC     B               ; Count digits before point
      001A43 C2 4C 1A         [10] 4181         JP      NZ,DIGTXT       ; Not zero - Do number
      001A46 36 2E            [10] 4182         LD      (HL),#'.'       ; Save point
      001A48 23               [ 6] 4183         INC     HL              ; Move on
      001A49 36 30            [10] 4184         LD      (HL),#'0'       ; Save zero
      001A4B 23               [ 6] 4185         INC     HL              ; Move on
      001A4C 05               [ 4] 4186 DIGTXT: DEC     B               ; Count digits before point
      001A4D 36 2E            [10] 4187         LD      (HL),#'.'       ; Save point in case
      001A4F CC 95 18         [17] 4188         CALL    Z,INCHL         ; Last digit - move on
      001A52 C5               [11] 4189         PUSH    BC              ; Save digits before point
      001A53 E5               [11] 4190         PUSH    HL              ; Save buffer address
      001A54 D5               [11] 4191         PUSH    DE              ; Save powers of ten
      001A55 CD 8B 18         [17] 4192         CALL    BCDEFP          ; Move FPREG to BCDE
      001A58 E1               [10] 4193         POP     HL              ; Powers of ten table
      001A59 06 2F            [ 7] 4194         LD      B, #'0'-1       ; ASCII '0' - 1
      001A5B 04               [ 4] 4195 TRYAGN: INC     B               ; Count subtractions
      001A5C 7B               [ 4] 4196         LD      A,E             ; Get LSB
      001A5D 96               [ 7] 4197         SUB     (HL)            ; Subtract LSB
      001A5E 5F               [ 4] 4198         LD      E,A             ; Save LSB
      001A5F 23               [ 6] 4199         INC     HL
      001A60 7A               [ 4] 4200         LD      A,D             ; Get NMSB
      001A61 9E               [ 7] 4201         SBC     A,(HL)          ; Subtract NMSB
      001A62 57               [ 4] 4202         LD      D,A             ; Save NMSB
      001A63 23               [ 6] 4203         INC     HL
      001A64 79               [ 4] 4204         LD      A,C             ; Get MSB
      001A65 9E               [ 7] 4205         SBC     A,(HL)          ; Subtract MSB
      001A66 4F               [ 4] 4206         LD      C,A             ; Save MSB
      001A67 2B               [ 6] 4207         DEC     HL              ; Point back to start
      001A68 2B               [ 6] 4208         DEC     HL
      001A69 D2 5B 1A         [10] 4209         JP      NC,TRYAGN       ; No overflow - Try again
      001A6C CD 9E 16         [17] 4210         CALL    PLUCDE          ; Restore number
      001A6F 23               [ 6] 4211         INC     HL              ; Start of next number
      001A70 CD 80 18         [17] 4212         CALL    FPBCDE          ; Move BCDE to FPREG
      001A73 EB               [ 4] 4213         EX      DE,HL           ; Save point in table
      001A74 E1               [10] 4214         POP     HL              ; Restore buffer address
      001A75 70               [ 7] 4215         LD      (HL),B          ; Save digit in buffer
      001A76 23               [ 6] 4216         INC     HL              ; And move on
      001A77 C1               [10] 4217         POP     BC              ; Restore digit count
      001A78 0D               [ 4] 4218         DEC     C               ; Count digits
      001A79 C2 4C 1A         [10] 4219         JP      NZ,DIGTXT       ; More - Do them
      001A7C 05               [ 4] 4220         DEC     B               ; Any decimal part?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 78.
Hexadecimal [24-Bits]



      001A7D CA 8C 1A         [10] 4221         JP      Z,DOEBIT        ; No - Do 'E' bit
      001A80 2B               [ 6] 4222 SUPTLZ: DEC     HL              ; Move back through buffer
      001A81 7E               [ 7] 4223         LD      A,(HL)          ; Get character
      001A82 FE 30            [ 7] 4224         CP      #'0'            ; '0' character?
      001A84 CA 80 1A         [10] 4225         JP      Z,SUPTLZ        ; Yes - Look back for more
      001A87 FE 2E            [ 7] 4226         CP      #'.'            ; A decimal point?
      001A89 C4 95 18         [17] 4227         CALL    NZ,INCHL        ; Move back over digit
                                   4228 
      001A8C F1               [10] 4229 DOEBIT: POP     AF              ; Get 'E' flag
      001A8D CA AB 1A         [10] 4230         JP      Z,NOENED        ; No 'E' needed - End buffer
      001A90 36 45            [10] 4231         LD      (HL),#'E'       ; Put 'E' in buffer
      001A92 23               [ 6] 4232         INC     HL              ; And move on
      001A93 36 2B            [10] 4233         LD      (HL),#'+'       ; Put '+' in buffer
      001A95 F2 9C 1A         [10] 4234         JP      P,OUTEXP        ; Positive - Output exponent
      001A98 36 2D            [10] 4235         LD      (HL),#'-'       ; Put '-' in buffer
      001A9A 2F               [ 4] 4236         CPL                     ; Negate exponent
      001A9B 3C               [ 4] 4237         INC     A
      001A9C 06 2F            [ 7] 4238 OUTEXP: LD      B,#'0'-1         ; ASCII '0' - 1
      001A9E 04               [ 4] 4239 EXPTEN: INC     B               ; Count subtractions
      001A9F D6 0A            [ 7] 4240         SUB     #10              ; Tens digit
      001AA1 D2 9E 1A         [10] 4241         JP      NC,EXPTEN       ; More to do
      001AA4 C6 3A            [ 7] 4242         ADD     A,#'0'+10        ; Restore and make ASCII
      001AA6 23               [ 6] 4243         INC     HL              ; Move on
      001AA7 70               [ 7] 4244         LD      (HL),B          ; Save MSB of exponent
      001AA8 23               [ 6] 4245 JSTZER: INC     HL              ;
      001AA9 77               [ 7] 4246         LD      (HL),A          ; Save LSB of exponent
      001AAA 23               [ 6] 4247         INC     HL
      001AAB 71               [ 7] 4248 NOENED: LD      (HL),C          ; Mark end of buffer
      001AAC E1               [10] 4249         POP     HL              ; Restore code string address
      001AAD C9               [10] 4250         RET
                                   4251 
      001AAE 01 74 94         [10] 4252 RNGTST: LD      BC,#0x9474      ; BCDE = 999999.
      001AB1 11 F7 23         [10] 4253         LD      DE,#0x23F7
      001AB4 CD BA 18         [17] 4254         CALL    CMPNUM          ; Compare numbers
      001AB7 B7               [ 4] 4255         OR      A
      001AB8 E1               [10] 4256         POP     HL              ; Return address to HL
      001AB9 E2 16 1A         [10] 4257         JP      PO,GTSIXD       ; Too big - Divide by ten
      001ABC E9               [ 4] 4258         JP      (HL)            ; Otherwise return to caller
                                   4259 
      001ABD 00 00 00 80           4260 HALF:   .BYTE      0x00,0x00,0x00,0x80 ; 0.5
                                   4261 
      001AC1 A0 86 01              4262 POWERS: .BYTE      0xA0,0x86,0x01  ; 100000
      001AC4 10 27 00              4263         .BYTE      0x10,0x27,0x00  ;  10000
      001AC7 E8 03 00              4264         .BYTE      0xE8,0x03,0x00  ;   1000
      001ACA 64 00 00              4265         .BYTE      0x64,0x00,0x00  ;    100
      001ACD 0A 00 00              4266         .BYTE      0x0A,0x00,0x00  ;     10
      001AD0 01 00 00              4267         .BYTE      0x01,0x00,0x00  ;      1
                                   4268 
      001AD3 21 68 18         [10] 4269 NEGAFT: LD  HL,#INVSGN          ; Negate result
      001AD6 E3               [19] 4270         EX      (SP),HL         ; To be done after caller
      001AD7 E9               [ 4] 4271         JP      (HL)            ; Return to caller
                                   4272 
      001AD8 CD 70 18         [17] 4273 SQR:    CALL    STAKFP          ; Put value on stack
      001ADB 21 BD 1A         [10] 4274         LD      HL,#HALF        ; Set power to 1/2
      001ADE CD 7D 18         [17] 4275         CALL    PHLTFP          ; Move 1/2 to FPREG
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 79.
Hexadecimal [24-Bits]



                                   4276 
      001AE1 C1               [10] 4277 POWER:  POP     BC              ; Get base
      001AE2 D1               [10] 4278         POP     DE
      001AE3 CD 3F 18         [17] 4279         CALL    TSTSGN          ; Test sign of power
      001AE6 78               [ 4] 4280         LD      A,B             ; Get exponent of base
      001AE7 CA 26 1B         [10] 4281         JP      Z,EXP           ; Make result 1 if zero
      001AEA F2 F1 1A         [10] 4282         JP      P,POWER1        ; Positive base - Ok
      001AED B7               [ 4] 4283         OR      A               ; Zero to negative power?
      001AEE CA 9B 05         [10] 4284         JP      Z,DZERR         ; Yes - ?/0 Error
      001AF1 B7               [ 4] 4285 POWER1: OR      A               ; Base zero?
      001AF2 CA 60 16         [10] 4286         JP      Z,SAVEXP        ; Yes - Return zero
      001AF5 D5               [11] 4287         PUSH    DE              ; Save base
      001AF6 C5               [11] 4288         PUSH    BC
      001AF7 79               [ 4] 4289         LD      A,C             ; Get MSB of base
      001AF8 F6 7F            [ 7] 4290         OR      #0b01111111     ; Get sign status
      001AFA CD 8B 18         [17] 4291         CALL    BCDEFP          ; Move power to BCDE
      001AFD F2 0E 1B         [10] 4292         JP      P,POWER2        ; Positive base - Ok
      001B00 D5               [11] 4293         PUSH    DE              ; Save power
      001B01 C5               [11] 4294         PUSH    BC
      001B02 CD 12 19         [17] 4295         CALL    INT             ; Get integer of power
      001B05 C1               [10] 4296         POP     BC              ; Restore power
      001B06 D1               [10] 4297         POP     DE
      001B07 F5               [11] 4298         PUSH    AF              ; MSB of base
      001B08 CD BA 18         [17] 4299         CALL    CMPNUM          ; Power an integer?
      001B0B E1               [10] 4300         POP     HL              ; Restore MSB of base
      001B0C 7C               [ 4] 4301         LD      A,H             ; but don't affect flags
      001B0D 1F               [ 4] 4302         RRA                     ; Exponent odd or even?
      001B0E E1               [10] 4303 POWER2: POP     HL              ; Restore MSB and exponent
      001B0F 22 E6 23         [16] 4304         LD      (FPREG+2),HL    ; Save base in FPREG
      001B12 E1               [10] 4305         POP     HL              ; LSBs of base
      001B13 22 E4 23         [16] 4306         LD      (FPREG),HL      ; Save in FPREG
      001B16 DC D3 1A         [17] 4307         CALL    C,NEGAFT        ; Odd power - Negate result
      001B19 CC 68 18         [17] 4308         CALL    Z,INVSGN        ; Negative base - Negate it
      001B1C D5               [11] 4309         PUSH    DE              ; Save power
      001B1D C5               [11] 4310         PUSH    BC
      001B1E CD F3 16         [17] 4311         CALL    LOG             ; Get LOG of base
      001B21 C1               [10] 4312         POP     BC              ; Restore power
      001B22 D1               [10] 4313         POP     DE
      001B23 CD 34 17         [17] 4314         CALL    FPMULT          ; Multiply LOG by power
                                   4315 
      001B26 CD 70 18         [17] 4316 EXP:    CALL    STAKFP          ; Put value on stack
      001B29 01 38 81         [10] 4317         LD      BC,#0x08138     ; BCDE = 1/Ln(2)
      001B2C 11 3B AA         [10] 4318         LD      DE,#0x0AA3B
      001B2F CD 34 17         [17] 4319         CALL    FPMULT          ; Multiply value by 1/LN(2)
      001B32 3A E7 23         [13] 4320         LD      A,(FPEXP)       ; Get exponent
      001B35 FE 88            [ 7] 4321         CP      #0x80+8         ; Is it in range?
      001B37 D2 1B 18         [10] 4322         JP      NC,OVTST1       ; No - Test for overflow
      001B3A CD 12 19         [17] 4323         CALL    INT             ; Get INT of FPREG
      001B3D C6 80            [ 7] 4324         ADD     A,#0x80         ; For excess 128
      001B3F C6 02            [ 7] 4325         ADD     A,#2            ; Exponent > 126?
      001B41 DA 1B 18         [10] 4326         JP      C,OVTST1        ; Yes - Test for overflow
      001B44 F5               [11] 4327         PUSH    AF              ; Save scaling factor
      001B45 21 E2 16         [10] 4328         LD      HL,#UNITY       ; Point to 1.
      001B48 CD EA 15         [17] 4329         CALL    ADDPHL          ; Add 1 to FPREG
      001B4B CD 2B 17         [17] 4330         CALL    MULLN2          ; Multiply by LN(2)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 80.
Hexadecimal [24-Bits]



      001B4E F1               [10] 4331         POP     AF              ; Restore scaling factor
      001B4F C1               [10] 4332         POP     BC              ; Restore exponent
      001B50 D1               [10] 4333         POP     DE
      001B51 F5               [11] 4334         PUSH    AF              ; Save scaling factor
      001B52 CD F6 15         [17] 4335         CALL    SUBCDE          ; Subtract exponent from FPREG
      001B55 CD 68 18         [17] 4336         CALL    INVSGN          ; Negate result
      001B58 21 66 1B         [10] 4337         LD      HL,#EXPTAB      ; Coefficient table
      001B5B CD 96 1B         [17] 4338         CALL    SMSER1          ; Sum the series
      001B5E 11 00 00         [10] 4339         LD      DE,#0           ; Zero LSBs
      001B61 C1               [10] 4340         POP     BC              ; Scaling factor
      001B62 4A               [ 4] 4341         LD      C,D             ; Zero MSB
      001B63 C3 34 17         [10] 4342         JP      FPMULT          ; Scale result to correct value
                                   4343 
      001B66 08                    4344 EXPTAB: .BYTE      8                       ; Table used by EXP
      001B67 40 2E 94 74           4345         .BYTE      0x40,0x2E,0x94,0x74     ; -1/7! (-1/5040)
      001B6B 70 4F 2E 77           4346         .BYTE      0x70,0x4F,0x2E,0x77     ;  1/6! ( 1/720)
      001B6F 6E 02 88 7A           4347         .BYTE      0x6E,0x02,0x88,0x7A     ; -1/5! (-1/120)
      001B73 E6 A0 2A 7C           4348         .BYTE      0xE6,0xA0,0x2A,0x7C     ;  1/4! ( 1/24)
      001B77 50 AA AA 7E           4349         .BYTE      0x50,0xAA,0xAA,0x7E     ; -1/3! (-1/6)
      001B7B FF FF 7F 7F           4350         .BYTE      0xFF,0xFF,0x7F,0x7F     ;  1/2! ( 1/2)
      001B7F 00 00 80 81           4351         .BYTE      0x00,0x00,0x80,0x81     ; -1/1! (-1/1)
      001B83 00 00 00 81           4352         .BYTE      0x00,0x00,0x00,0x81     ;  1/0! ( 1/1)
                                   4353 
      001B87 CD 70 18         [17] 4354 SUMSER: CALL    STAKFP          ; Put FPREG on stack
      001B8A 11 32 17         [10] 4355         LD      DE,#MULT        ; Multiply by "X"
      001B8D D5               [11] 4356         PUSH    DE              ; To be done after
      001B8E E5               [11] 4357         PUSH    HL              ; Save address of table
      001B8F CD 8B 18         [17] 4358         CALL    BCDEFP          ; Move FPREG to BCDE
      001B92 CD 34 17         [17] 4359         CALL    FPMULT          ; Square the value
      001B95 E1               [10] 4360         POP     HL              ; Restore address of table
      001B96 CD 70 18         [17] 4361 SMSER1: CALL    STAKFP          ; Put value on stack
      001B99 7E               [ 7] 4362         LD      A,(HL)          ; Get number of coefficients
      001B9A 23               [ 6] 4363         INC     HL              ; Point to start of table
      001B9B CD 7D 18         [17] 4364         CALL    PHLTFP          ; Move coefficient to FPREG
      001B9E 06                    4365         .BYTE      0x06         ; Skip "POP AF"
      001B9F F1               [10] 4366 SUMLP:  POP     AF              ; Restore count
      001BA0 C1               [10] 4367         POP     BC              ; Restore number
      001BA1 D1               [10] 4368         POP     DE
      001BA2 3D               [ 4] 4369         DEC     A               ; Cont coefficients
      001BA3 C8               [11] 4370         RET     Z               ; All done
      001BA4 D5               [11] 4371         PUSH    DE              ; Save number
      001BA5 C5               [11] 4372         PUSH    BC
      001BA6 F5               [11] 4373         PUSH    AF              ; Save count
      001BA7 E5               [11] 4374         PUSH    HL              ; Save address in table
      001BA8 CD 34 17         [17] 4375         CALL    FPMULT          ; Multiply FPREG by BCDE
      001BAB E1               [10] 4376         POP     HL              ; Restore address in table
      001BAC CD 8E 18         [17] 4377         CALL    LOADFP          ; Number at HL to BCDE
      001BAF E5               [11] 4378         PUSH    HL              ; Save address in table
      001BB0 CD F9 15         [17] 4379         CALL    FPADD           ; Add coefficient to FPREG
      001BB3 E1               [10] 4380         POP     HL              ; Restore address in table
      001BB4 C3 9F 1B         [10] 4381         JP      SUMLP           ; More coefficients
                                   4382 
      001BB7 CD 3F 18         [17] 4383 RND:    CALL    TSTSGN          ; Test sign of FPREG
      001BBA 21 19 23         [10] 4384         LD      HL,#SEED+2      ; Random number seed
      001BBD FA 18 1C         [10] 4385         JP      M,RESEED        ; Negative - Re-seed
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 81.
Hexadecimal [24-Bits]



      001BC0 21 3A 23         [10] 4386         LD      HL,#LSTRND      ; Last random number
      001BC3 CD 7D 18         [17] 4387         CALL    PHLTFP          ; Move last RND to FPREG
      001BC6 21 19 23         [10] 4388         LD      HL,#SEED+2      ; Random number seed
      001BC9 C8               [11] 4389         RET     Z               ; Return if RND(0)
      001BCA 86               [ 7] 4390         ADD     A,(HL)          ; Add (SEED)+2)
      001BCB E6 07            [ 7] 4391         AND     #0b00000111     ; 0 to 7
      001BCD 06 00            [ 7] 4392         LD      B,#0
      001BCF 77               [ 7] 4393         LD      (HL),A          ; Re-save seed
      001BD0 23               [ 6] 4394         INC     HL              ; Move to coefficient table
      001BD1 87               [ 4] 4395         ADD     A,A             ; 4 bytes
      001BD2 87               [ 4] 4396         ADD     A,A             ; per entry
      001BD3 4F               [ 4] 4397         LD      C,A             ; BC = Offset into table
      001BD4 09               [11] 4398         ADD     HL,BC           ; Point to coefficient
      001BD5 CD 8E 18         [17] 4399         CALL    LOADFP          ; Coefficient to BCDE
      001BD8 CD 34 17         [17] 4400         CALL    FPMULT  ;       ; Multiply FPREG by coefficient
      001BDB 3A 18 23         [13] 4401         LD      A,(SEED+1)      ; Get (SEED+1)
      001BDE 3C               [ 4] 4402         INC     A               ; Add 1
      001BDF E6 03            [ 7] 4403         AND     #0b00000011     ; 0 to 3
      001BE1 06 00            [ 7] 4404         LD      B,#0
      001BE3 FE 01            [ 7] 4405         CP      #1              ; Is it zero?
      001BE5 88               [ 4] 4406         ADC     A,B             ; Yes - Make it 1
      001BE6 32 18 23         [13] 4407         LD      (SEED+1),A      ; Re-save seed
      001BE9 21 1C 1C         [10] 4408         LD      HL,#RNDTAB-4    ; Addition table
      001BEC 87               [ 4] 4409         ADD     A,A             ; 4 bytes
      001BED 87               [ 4] 4410         ADD     A,A             ; per entry
      001BEE 4F               [ 4] 4411         LD      C,A             ; BC = Offset into table
      001BEF 09               [11] 4412         ADD     HL,BC           ; Point to value
      001BF0 CD EA 15         [17] 4413         CALL    ADDPHL          ; Add value to FPREG
      001BF3 CD 8B 18         [17] 4414 RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
      001BF6 7B               [ 4] 4415         LD      A,E             ; Get LSB
      001BF7 59               [ 4] 4416         LD      E,C             ; LSB = MSB
      001BF8 EE 4F            [ 7] 4417         XOR     #0b01001111     ; Fiddle around
      001BFA 4F               [ 4] 4418         LD      C,A             ; New MSB
      001BFB 36 80            [10] 4419         LD      (HL),#0x80      ; Set exponent
      001BFD 2B               [ 6] 4420         DEC     HL              ; Point to MSB
      001BFE 46               [ 7] 4421         LD      B,(HL)          ; Get MSB
      001BFF 36 80            [10] 4422         LD      (HL),#0x80      ; Make value -0.5
      001C01 21 17 23         [10] 4423         LD      HL,#SEED        ; Random number seed
      001C04 34               [11] 4424         INC     (HL)            ; Count seed
      001C05 7E               [ 7] 4425         LD      A,(HL)          ; Get seed
      001C06 D6 AB            [ 7] 4426         SUB     #171            ; Do it modulo 171
      001C08 C2 0F 1C         [10] 4427         JP      NZ,RND2         ; Non-zero - Ok
      001C0B 77               [ 7] 4428         LD      (HL),A          ; Zero seed
      001C0C 0C               [ 4] 4429         INC     C               ; Fillde about
      001C0D 15               [ 4] 4430         DEC     D               ; with the
      001C0E 1C               [ 4] 4431         INC     E               ; number
      001C0F CD 4A 16         [17] 4432 RND2:   CALL    BNORM           ; Normalise number
      001C12 21 3A 23         [10] 4433         LD      HL,#LSTRND      ; Save random number
      001C15 C3 97 18         [10] 4434         JP      FPTHL           ; Move FPREG to last and return
                                   4435 
      001C18 77               [ 7] 4436 RESEED: LD      (HL),A          ; Re-seed random numbers
      001C19 2B               [ 6] 4437         DEC     HL
      001C1A 77               [ 7] 4438         LD      (HL),A
      001C1B 2B               [ 6] 4439         DEC     HL
      001C1C 77               [ 7] 4440         LD      (HL),A
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 82.
Hexadecimal [24-Bits]



      001C1D C3 F3 1B         [10] 4441         JP      RND1            ; Return RND seed
                                   4442 
      001C20 68 B1 46 68           4443 RNDTAB: .BYTE   0x68,0xB1,0x46,0x68     ; Table used by RND
      001C24 99 E9 92 69           4444         .BYTE   0x99,0xE9,0x92,0x69
      001C28 10 D1 75 68           4445         .BYTE   0x10,0xD1,0x75,0x68
                                   4446 
      001C2C 21 76 1C         [10] 4447 COS:    LD      HL,#HALFPI      ; Point to PI/2
      001C2F CD EA 15         [17] 4448         CALL    ADDPHL          ; Add it to PPREG
      001C32 CD 70 18         [17] 4449 SIN:    CALL    STAKFP          ; Put angle on stack
      001C35 01 49 83         [10] 4450         LD      BC,#0x8349      ; BCDE = 2 PI
      001C38 11 DB 0F         [10] 4451         LD      DE,#0x0FDB
      001C3B CD 80 18         [17] 4452         CALL    FPBCDE          ; Move 2 PI to FPREG
      001C3E C1               [10] 4453         POP     BC              ; Restore angle
      001C3F D1               [10] 4454         POP     DE
      001C40 CD 95 17         [17] 4455         CALL    DVBCDE          ; Divide angle by 2 PI
      001C43 CD 70 18         [17] 4456         CALL    STAKFP          ; Put it on stack
      001C46 CD 12 19         [17] 4457         CALL    INT             ; Get INT of result
      001C49 C1               [10] 4458         POP     BC              ; Restore number
      001C4A D1               [10] 4459         POP     DE
      001C4B CD F6 15         [17] 4460         CALL    SUBCDE          ; Make it 0 <= value < 1
      001C4E 21 7A 1C         [10] 4461         LD      HL,#QUARTR      ; Point to 0.25
      001C51 CD F0 15         [17] 4462         CALL    SUBPHL          ; Subtract value from 0.25
      001C54 CD 3F 18         [17] 4463         CALL    TSTSGN          ; Test sign of value
      001C57 37               [ 4] 4464         SCF                     ; Flag positive
      001C58 F2 62 1C         [10] 4465         JP      P,SIN1          ; Positive - Ok
      001C5B CD E7 15         [17] 4466         CALL    ROUND           ; Add 0.5 to value
      001C5E CD 3F 18         [17] 4467         CALL    TSTSGN          ; Test sign of value
      001C61 B7               [ 4] 4468         OR      A               ; Flag negative
      001C62 F5               [11] 4469 SIN1:   PUSH    AF              ; Save sign
      001C63 F4 68 18         [17] 4470         CALL    P,INVSGN        ; Negate value if positive
      001C66 21 7A 1C         [10] 4471         LD      HL,#QUARTR      ; Point to 0.25
      001C69 CD EA 15         [17] 4472         CALL    ADDPHL          ; Add 0.25 to value
      001C6C F1               [10] 4473         POP     AF              ; Restore sign
      001C6D D4 68 18         [17] 4474         CALL    NC,INVSGN       ; Negative - Make positive
      001C70 21 7E 1C         [10] 4475         LD      HL,#SINTAB      ; Coefficient table
      001C73 C3 87 1B         [10] 4476         JP      SUMSER          ; Evaluate sum of series
                                   4477 
      001C76 DB 0F 49 81           4478 HALFPI: .BYTE   0xDB,0x0F,0x49,0x81     ; 1.5708 (PI/2)
                                   4479 
      001C7A 00 00 00 7F           4480 QUARTR: .BYTE   0x00,0x00,0x00,0x7F     ; 0.25
                                   4481 
      001C7E 05                    4482 SINTAB: .BYTE   5                       ; Table used by SIN
      001C7F BA D7 1E 86           4483         .BYTE   0xBA,0xD7,0x1E,0x86     ; 39.711
      001C83 64 26 99 87           4484         .BYTE   0x64,0x26,0x99,0x87     ;-76.575
      001C87 58 34 23 87           4485         .BYTE   0x58,0x34,0x23,0x87     ; 81.602
      001C8B E0 5D A5 86           4486         .BYTE   0xE0,0x5D,0xA5,0x86     ;-41.342
      001C8F DA 0F 49 83           4487         .BYTE   0xDA,0x0F,0x49,0x83     ;  6.2832
                                   4488 
      001C93 CD 70 18         [17] 4489 TAN:    CALL    STAKFP          ; Put angle on stack
      001C96 CD 32 1C         [17] 4490         CALL    SIN             ; Get SIN of angle
      001C99 C1               [10] 4491         POP     BC              ; Restore angle
      001C9A E1               [10] 4492         POP     HL
      001C9B CD 70 18         [17] 4493         CALL    STAKFP          ; Save SIN of angle
      001C9E EB               [ 4] 4494         EX      DE,HL           ; BCDE = Angle
      001C9F CD 80 18         [17] 4495         CALL    FPBCDE          ; Angle to FPREG
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 83.
Hexadecimal [24-Bits]



      001CA2 CD 2C 1C         [17] 4496         CALL    COS             ; Get COS of angle
      001CA5 C3 93 17         [10] 4497         JP      DIV             ; TAN = SIN / COS
                                   4498 
      001CA8 CD 3F 18         [17] 4499 ATN:    CALL    TSTSGN          ; Test sign of value
      001CAB FC D3 1A         [17] 4500         CALL    M,NEGAFT        ; Negate result after if -ve
      001CAE FC 68 18         [17] 4501         CALL    M,INVSGN        ; Negate value if -ve
      001CB1 3A E7 23         [13] 4502         LD      A,(FPEXP)       ; Get exponent
      001CB4 FE 81            [ 7] 4503         CP      #0x81           ; Number less than 1?
      001CB6 DA C5 1C         [10] 4504         JP      C,ATN1          ; Yes - Get arc tangnt
      001CB9 01 00 81         [10] 4505         LD      BC,#0x8100      ; BCDE = 1
      001CBC 51               [ 4] 4506         LD      D,C
      001CBD 59               [ 4] 4507         LD      E,C
      001CBE CD 95 17         [17] 4508         CALL    DVBCDE          ; Get reciprocal of number
      001CC1 21 F0 15         [10] 4509         LD      HL,#SUBPHL      ; Sub angle from PI/2
      001CC4 E5               [11] 4510         PUSH    HL              ; Save for angle > 1
      001CC5 21 CF 1C         [10] 4511 ATN1:   LD      HL,#ATNTAB      ; Coefficient table
      001CC8 CD 87 1B         [17] 4512         CALL    SUMSER          ; Evaluate sum of series
      001CCB 21 76 1C         [10] 4513         LD      HL,#HALFPI      ; PI/2 - angle in case > 1
      001CCE C9               [10] 4514         RET                     ; Number > 1 - Sub from PI/2
                                   4515 
      001CCF 09                    4516 ATNTAB: .BYTE   9                       ; Table used by ATN
      001CD0 4A D7 3B 78           4517         .BYTE   0x4A,0xD7,0x3B,0x78     ; 1/17
      001CD4 02 6E 84 7B           4518         .BYTE   0x02,0x6E,0x84,0x7B     ;-1/15
      001CD8 FE C1 2F 7C           4519         .BYTE   0xFE,0xC1,0x2F,0x7C     ; 1/13
      001CDC 74 31 9A 7D           4520         .BYTE   0x74,0x31,0x9A,0x7D     ;-1/11
      001CE0 84 3D 5A 7D           4521         .BYTE   0x84,0x3D,0x5A,0x7D     ; 1/9
      001CE4 C8 7F 91 7E           4522         .BYTE   0xC8,0x7F,0x91,0x7E     ;-1/7
      001CE8 E4 BB 4C 7E           4523         .BYTE   0xE4,0xBB,0x4C,0x7E     ; 1/5
      001CEC 6C AA AA 7F           4524         .BYTE   0x6C,0xAA,0xAA,0x7F     ;-1/3
      001CF0 00 00 00 81           4525         .BYTE   0x00,0x00,0x00,0x81     ; 1/1
                                   4526 
                                   4527 
      001CF4 C9               [10] 4528 ARET:   RET                     ; A RETurn instruction
                                   4529 
      001CF5 D7               [11] 4530 GETINP: RST	    0x10        ;input a character
      001CF6 C9               [10] 4531         RET
                                   4532 
      001CF7                       4533 CLS: 
      001CF7 3E 0C            [ 7] 4534         LD      A,#CS           ; ASCII Clear screen
      001CF9 C3 31 1E         [10] 4535         JP      MONOUT          ; Output character
                                   4536 
      001CFC CD BE 15         [17] 4537 WIDTH:  CALL    GETINT          ; Get integer 0-255
      001CFF 7B               [ 4] 4538         LD      A,E             ; Width to A
      001D00 32 42 23         [13] 4539         LD      (LWIDTH),A      ; Set width
      001D03 C9               [10] 4540         RET
                                   4541 
      001D04 CD 5D 0E         [17] 4542 LINES:  CALL    GETNUM          ; Get a number
      001D07 CD A2 0A         [17] 4543         CALL    DEINT           ; Get integer -32768 to 32767
      001D0A ED 53 46 23      [20] 4544         LD      (LINESC),DE     ; Set lines counter
      001D0E ED 53 48 23      [20] 4545         LD      (LINESN),DE     ; Set lines number
      001D12 C9               [10] 4546         RET
                                   4547 
      001D13 CD A2 0A         [17] 4548 DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
      001D16 D5               [11] 4549         PUSH    DE              ; Save number
      001D17 E1               [10] 4550         POP     HL              ; Number to HL
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 84.
Hexadecimal [24-Bits]



      001D18 46               [ 7] 4551         LD      B,(HL)          ; Get LSB of contents
      001D19 23               [ 6] 4552         INC     HL
      001D1A 7E               [ 7] 4553         LD      A,(HL)          ; Get MSB of contents
      001D1B C3 18 12         [10] 4554         JP      ABPASS          ; Return integer AB
                                   4555 
      001D1E CD 5D 0E         [17] 4556 DOKE:   CALL    GETNUM          ; Get a number
      001D21 CD A2 0A         [17] 4557         CALL    DEINT           ; Get integer -32768 to 32767
      001D24 D5               [11] 4558         PUSH    DE              ; Save address
      001D25 CD 66 08         [17] 4559         CALL    CHKSYN          ; Make sure ',' follows
      001D28 2C                    4560         .BYTE      ','
      001D29 CD 5D 0E         [17] 4561         CALL    GETNUM          ; Get a number
      001D2C CD A2 0A         [17] 4562         CALL    DEINT           ; Get integer -32768 to 32767
      001D2F E3               [19] 4563         EX      (SP),HL         ; Save value,get address
      001D30 73               [ 7] 4564         LD      (HL),E          ; Save LSB of value
      001D31 23               [ 6] 4565         INC     HL
      001D32 72               [ 7] 4566         LD      (HL),D          ; Save MSB of value
      001D33 E1               [10] 4567         POP     HL              ; Restore code string address
      001D34 C9               [10] 4568         RET
                                   4569 
                                   4570 
                                   4571 ; HEX$(nn) Convert 16 bit number to Hexadecimal string
                                   4572 
      001D35 CD 60 0E         [17] 4573 HEX: 	CALL	TSTNUM          ; Verify it's a number
      001D38 CD A2 0A         [17] 4574         CALL	DEINT           ; Get integer -32768 to 32767
      001D3B C5               [11] 4575         PUSH	BC              ; Save contents of BC
      001D3C 21 E9 23         [10] 4576         LD	HL,#PBUFF
      001D3F 7A               [ 4] 4577         LD	    A,D             ; Get high order into A
      001D40 FE 00            [ 7] 4578         CP      #0
      001D42 28 0C            [12] 4579 	JR      Z,HEX2          ; Skip output if both high digits are zero
      001D44 CD 6D 1D         [17] 4580         CALL    BYT2ASC         ; Convert D to ASCII
      001D47 78               [ 4] 4581 	LD      A,B
      001D48 FE 30            [ 7] 4582 	CP      #'0'
      001D4A 28 02            [12] 4583 	JR      Z,HEX1          ; Don't store high digit if zero
      001D4C 70               [ 7] 4584         LD	    (HL),B          ; Store it to PBUFF
      001D4D 23               [ 6] 4585         INC	    HL              ; Next location
      001D4E 71               [ 7] 4586 HEX1:   LD	    (HL),C          ; Store C to PBUFF+1
      001D4F 23               [ 6] 4587         INC     HL              ; Next location
      001D50 7B               [ 4] 4588 HEX2:   LD	    A,E             ; Get lower byte
      001D51 CD 6D 1D         [17] 4589         CALL    BYT2ASC         ; Convert E to ASCII
      001D54 7A               [ 4] 4590 		LD      A,D
      001D55 FE 00            [ 7] 4591         CP      #0
      001D57 20 05            [12] 4592 	JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
      001D59 78               [ 4] 4593 	LD      A,B
      001D5A FE 30            [ 7] 4594 	CP      #'0'             ; If high digit of lower byte is zero then don't print
      001D5C 28 02            [12] 4595 	JR      Z,HEX4
      001D5E 70               [ 7] 4596 HEX3:   LD      (HL),B          ; to PBUFF+2
      001D5F 23               [ 6] 4597         INC     HL              ; Next location
      001D60 71               [ 7] 4598 HEX4:   LD      (HL),C          ; to PBUFF+3
      001D61 23               [ 6] 4599         INC     HL              ; PBUFF+4 to zero
      001D62 AF               [ 4] 4600         XOR     A               ; Terminating character
      001D63 77               [ 7] 4601         LD      (HL),A          ; Store zero to terminate
      001D64 23               [ 6] 4602         INC     HL              ; Make sure PBUFF is terminated
      001D65 77               [ 7] 4603         LD      (HL),A          ; Store the double zero there
      001D66 C1               [10] 4604         POP     BC              ; Get BC back
      001D67 21 E9 23         [10] 4605         LD      HL,#PBUFF       ; Reset to start of PBUFF
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 85.
Hexadecimal [24-Bits]



      001D6A C3 C6 12         [10] 4606         JP      STR1            ; Convert the PBUFF to a string and return it
                                   4607 
      001D6D 47               [ 4] 4608 BYT2ASC:LD      B,A             ; Save original value
      001D6E E6 0F            [ 7] 4609         AND     #0x0F           ; Strip off upper nybble
      001D70 FE 0A            [ 7] 4610         CP      #0x0A           ; 0-9?
      001D72 38 02            [12] 4611         JR      C,#ADD30        ; If A-F, add 7 more
      001D74 C6 07            [ 7] 4612         ADD     A,#0x07         ; Bring value up to ASCII A-F
      001D76 C6 30            [ 7] 4613 ADD30:	ADD     A,#0x30         ; And make ASCII
      001D78 4F               [ 4] 4614         LD      C,A             ; Save converted char to C
      001D79 78               [ 4] 4615         LD      A,B             ; Retrieve original value
      001D7A 0F               [ 4] 4616         RRCA                    ; and Rotate it right
      001D7B 0F               [ 4] 4617         RRCA
      001D7C 0F               [ 4] 4618         RRCA
      001D7D 0F               [ 4] 4619         RRCA
      001D7E E6 0F            [ 7] 4620         AND     #0x0F           ; Mask off upper nybble
      001D80 FE 0A            [ 7] 4621         CP      #0x0A           ; 0-9? < A hex?
      001D82 38 02            [12] 4622         JR      C,ADD301        ; Skip Add 7
      001D84 C6 07            [ 7] 4623         ADD     A,#0x07         ; Bring it up to ASCII A-F
      001D86 C6 30            [ 7] 4624 ADD301:	ADD     A,#0x30         ; And make it full ASCII
      001D88 47               [ 4] 4625         LD      B,A             ; Store high order byte
      001D89 C9               [10] 4626         RET	
                                   4627 
                                   4628 ; Convert "&Hnnnn" to FPREG
                                   4629 ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
                                   4630 ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
      001D8A EB               [ 4] 4631 HEXTFP: EX      DE,HL           ; Move code string pointer to DE
      001D8B 21 00 00         [10] 4632         LD      HL,#0x0000      ; Zero out the value
      001D8E CD A3 1D         [17] 4633         CALL    GETHEX          ; Check the number for valid hex
      001D91 DA C3 1D         [10] 4634         JP      C,HXERR         ; First value wasn't hex, HX error
      001D94 18 05            [12] 4635         JR      HEXLP1          ; Convert first character
      001D96 CD A3 1D         [17] 4636 HEXLP:  CALL    GETHEX          ; Get second and addtional characters
      001D99 38 1F            [12] 4637         JR      C,HEXIT         ; Exit if not a hex character
      001D9B 29               [11] 4638 HEXLP1: ADD     HL,HL           ; Rotate 4 bits to the left
      001D9C 29               [11] 4639         ADD     HL,HL
      001D9D 29               [11] 4640         ADD     HL,HL
      001D9E 29               [11] 4641         ADD     HL,HL
      001D9F B5               [ 4] 4642         OR      L               ; Add in D0-D3 into L
      001DA0 6F               [ 4] 4643         LD      L,A             ; Save new value
      001DA1 18 F3            [12] 4644         JR      HEXLP           ; And continue until all hex characters are in
                                   4645 
      001DA3 13               [ 6] 4646 GETHEX: INC     DE              ; Next location
      001DA4 1A               [ 7] 4647         LD      A,(DE)          ; Load character at pointer
      001DA5 FE 20            [ 7] 4648         CP      #' '
      001DA7 CA A3 1D         [10] 4649         JP      Z,GETHEX        ; Skip spaces
      001DAA D6 30            [ 7] 4650         SUB     #0x30           ; Get absolute value
      001DAC D8               [11] 4651         RET     C               ; < "0", error
      001DAD FE 0A            [ 7] 4652         CP      #0x0A
      001DAF 38 05            [12] 4653         JR      C,NOSUB7        ; Is already in the range 0-9
      001DB1 D6 07            [ 7] 4654         SUB     #0x07           ; Reduce to A-F
      001DB3 FE 0A            [ 7] 4655         CP      #0x0A           ; Value should be $0A-$0F at this point
      001DB5 D8               [11] 4656         RET     C               ; CY set if was :            ; < = > ? @
      001DB6 FE 10            [ 7] 4657 NOSUB7: CP      #0x10           ; > Greater than "F"?
      001DB8 3F               [ 4] 4658         CCF
      001DB9 C9               [10] 4659         RET                     ; CY set if it wasn't valid hex
                                   4660     
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 86.
Hexadecimal [24-Bits]



      001DBA EB               [ 4] 4661 HEXIT:  EX      DE,HL           ; Value into DE, Code string into HL
      001DBB 7A               [ 4] 4662         LD      A,D             ; Load DE into AC
      001DBC 4B               [ 4] 4663         LD      C,E             ; For prep to 
      001DBD E5               [11] 4664         PUSH    HL
      001DBE CD 17 12         [17] 4665         CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
      001DC1 E1               [10] 4666         POP     HL
      001DC2 C9               [10] 4667         RET
                                   4668 
      001DC3 1E 26            [ 7] 4669 HXERR:  LD      E,#HX           ; ?HEX Error
      001DC5 C3 AC 05         [10] 4670         JP      ERROR
                                   4671 
                                   4672 ; BIN$(NN) Convert integer to a 1-16 char binary string
      001DC8 CD 60 0E         [17] 4673 BIN:    CALL    TSTNUM          ; Verify it's a number
      001DCB CD A2 0A         [17] 4674         CALL    DEINT           ; Get integer -32768 to 32767
      001DCE C5               [11] 4675 BIN2:   PUSH    BC              ; Save contents of BC
      001DCF 21 E9 23         [10] 4676         LD      HL,#PBUFF
      001DD2 06 11            [ 7] 4677         LD      B,#17           ; One higher than max char count
      001DD4                       4678 ZEROSUP:                        ; Suppress leading zeros
      001DD4 05               [ 4] 4679         DEC     B               ; Max 16 chars
      001DD5 78               [ 4] 4680         LD      A,B
      001DD6 FE 01            [ 7] 4681         CP      #0x01
      001DD8 28 08            [12] 4682         JR      Z,BITOUT        ; Always output at least one character
      001DDA CB 13            [ 8] 4683         RL      E
      001DDC CB 12            [ 8] 4684         RL      D
      001DDE 30 F4            [12] 4685         JR      NC,ZEROSUP
      001DE0 18 04            [12] 4686         JR      BITOUT2
      001DE2                       4687 BITOUT:      
      001DE2 CB 13            [ 8] 4688         RL      E
      001DE4 CB 12            [ 8] 4689         RL      D               ; Top bit now in carry
      001DE6                       4690 BITOUT2:
      001DE6 3E 30            [ 7] 4691         LD      A,#'0'          ; Char for '0'
      001DE8 CE 00            [ 7] 4692         ADC     A,#0            ; If carry set then '0' --> '1'
      001DEA 77               [ 7] 4693         LD      (HL),A
      001DEB 23               [ 6] 4694         INC     HL
      001DEC 05               [ 4] 4695         DEC     B
      001DED 20 F3            [12] 4696         JR      NZ,BITOUT
      001DEF AF               [ 4] 4697         XOR     A               ; Terminating character
      001DF0 77               [ 7] 4698         LD      (HL),A          ; Store zero to terminate
      001DF1 23               [ 6] 4699         INC     HL              ; Make sure PBUFF is terminated
      001DF2 77               [ 7] 4700         LD      (HL),A          ; Store the double zero there
      001DF3 C1               [10] 4701         POP     BC
      001DF4 21 E9 23         [10] 4702         LD      HL,#PBUFF
      001DF7 C3 C6 12         [10] 4703         JP      STR1
                                   4704 
                                   4705 ; Convert "&Bnnnn" to FPREG
                                   4706 ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
      001DFA EB               [ 4] 4707 BINTFP: EX      DE,HL           ; Move code string pointer to DE
      001DFB 21 00 00         [10] 4708         LD      HL,#0x0000      ; Zero out the value
      001DFE CD 17 1E         [17] 4709         CALL    CHKBIN          ; Check the number for valid bin
      001E01 DA 25 1E         [10] 4710         JP      C,BINERR        ; First value wasn't bin, HX error
      001E04 D6 30            [ 7] 4711 BINIT:  SUB     #'0'
      001E06 29               [11] 4712         ADD     HL,HL           ; Rotate HL left
      001E07 B5               [ 4] 4713         OR      L
      001E08 6F               [ 4] 4714         LD      L,A
      001E09 CD 17 1E         [17] 4715         CALL    CHKBIN          ; Get second and addtional characters
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 87.
Hexadecimal [24-Bits]



      001E0C 30 F6            [12] 4716         JR      NC,BINIT        ; Process if a bin character
      001E0E EB               [ 4] 4717         EX      DE,HL           ; Value into DE, Code string into HL
      001E0F 7A               [ 4] 4718         LD      A,D             ; Load DE into AC
      001E10 4B               [ 4] 4719         LD      C,E             ; For prep to 
      001E11 E5               [11] 4720         PUSH    HL
      001E12 CD 17 12         [17] 4721         CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
      001E15 E1               [10] 4722         POP     HL
      001E16 C9               [10] 4723         RET
                                   4724 
                                   4725 ; Char is in A, NC if char is 0 or 1
      001E17 13               [ 6] 4726 CHKBIN: INC     DE
      001E18 1A               [ 7] 4727         LD      A,(DE)
      001E19 FE 20            [ 7] 4728         CP      #' '
      001E1B CA 17 1E         [10] 4729         JP      Z,CHKBIN        ; Skip spaces
      001E1E FE 30            [ 7] 4730         CP      #'0'            ; Set C if < '0'
      001E20 D8               [11] 4731         RET     C
      001E21 FE 32            [ 7] 4732         CP      #'2'
      001E23 3F               [ 4] 4733         CCF                     ; Set C if > '1'
      001E24 C9               [10] 4734         RET
                                   4735 
      001E25 1E 28            [ 7] 4736 BINERR: LD      E,#BN           ; ?BIN Error
      001E27 C3 AC 05         [10] 4737         JP      ERROR
                                   4738 
                                   4739 
      001E2A                       4740 JJUMP1: 
      001E2A DD 21 FF FF      [14] 4741         LD      IX,#-1          ; Flag cold start
      001E2E C3 11 02         [10] 4742         JP      CSTART          ; Go and initialise
                                   4743 
      001E31 F5               [11] 4744 MONOUT: PUSH    AF
      001E32 CF               [11] 4745         RST     0x0008           ; output a char
      001E33 F1               [10] 4746         POP     AF
      001E34 C9               [10] 4747         RET
                                   4748 
      001E35                       4749 MONITR: 
      001E35 C3 00 00         [10] 4750         JP      0x0000           ; Restart (Normally Monitor Start)
                                   4751 
                                   4752 
      001E38 3E 00            [ 7] 4753 INITST: LD      A,#0            ; Clear break flag
      001E3A 32 4D 23         [13] 4754         LD      (BRKFLG),A
      001E3D C3 18 02         [10] 4755         JP      INIT
                                   4756 
      001E40 ED 45            [14] 4757 ARETN:  RETN                    ; Return from NMI
                                   4758 
                                   4759 
      001E42 F5               [11] 4760 TSTBIT: PUSH    AF              ; Save bit mask
      001E43 A0               [ 4] 4761         AND     B               ; Get common bits
      001E44 C1               [10] 4762         POP     BC              ; Restore bit mask
      001E45 B8               [ 4] 4763         CP      B               ; Same bit set?
      001E46 3E 00            [ 7] 4764         LD      A,#0            ; Return 0 in A
      001E48 C9               [10] 4765         RET
                                   4766 
      001E49 CD 71 08         [17] 4767 OUTNCR: CALL    OUTC            ; Output character in A
      001E4C C3 98 0C         [10] 4768         JP      PRNTCRLF        ; Output CRLF
                                   4769 
                                   4770 .area	_DATA
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 88.
Hexadecimal [24-Bits]



                                   4771 
                                   4772 ;.end
                                   4773 
