ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 1.
Hexadecimal [24-Bits]



                                      1 	.module basic
                                      2 	.area	_HEADER (ABS)
                                      3 
                                      4 ;==================================================================================
                                      5 ; The updates to the original BASIC within this file are copyright Grant Searle
                                      6 ;
                                      7 ; You have permission to use this for NON COMMERCIAL USE ONLY
                                      8 ; If you wish to use it elsewhere, please include an acknowledgement to myself.
                                      9 ;
                                     10 ; http://searle.hostei.com/grant/index.html
                                     11 ;
                                     12 ; eMail: home.micros01@btinternet.com
                                     13 ;
                                     14 ; If the above don't work, please perform an Internet search to see if I have
                                     15 ; updated the web page hosting service.
                                     16 ;
                                     17 ;==================================================================================
                                     18 
                                     19 ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
                                     20 ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
                                     21 ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
                                     22 ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
                                     23 ; the original ROM code (checksum A934H). PA
                                     24 
                                     25 ; GENERAL EQUATES
                                     26 
                           000003    27 CTRLC   .EQU    0x03             ; Control "C"
                           000007    28 CTRLG   .EQU    0x07             ; Control "G"
                           000008    29 BKSP    .EQU    0x08             ; Back space
                           00000A    30 LF      .EQU    0x0A             ; Line feed
                           00000C    31 CS      .EQU    0x0C             ; Clear screen
                           00000D    32 CR      .EQU    0x0D             ; Carriage return
                           00000F    33 CTRLO   .EQU    0x0F             ; Control "O"
                           000011    34 CTRLQ	.EQU	0x11             ; Control "Q"
                           000012    35 CTRLR   .EQU    0x12             ; Control "R"
                           000013    36 CTRLS   .EQU    0x13             ; Control "S"
                           000015    37 CTRLU   .EQU    0x15             ; Control "U"
                           00001B    38 ESC     .EQU    0x1B             ; Escape
                           00007F    39 DEL     .EQU    0x7F             ; Delete
                                     40 
                                     41 ; BASIC WORK SPACE LOCATIONS
                                     42 
                                     43 ;;WRKSPC  .EQU    0x8045               ; BASIC Work space
                           004200    44 WRKSPC  .EQU    0x4200               ; BASIC Work space
                           004203    45 USR     .EQU    WRKSPC+0x03          ; "USR (x)" jump
                           004206    46 OUTSUB  .EQU    WRKSPC+0x06          ; "OUT p,n"
                           004207    47 OTPORT  .EQU    WRKSPC+0x07          ; Port (p)
                           004209    48 DIVSUP  .EQU    WRKSPC+0x09          ; Division support routine
                           00420A    49 DIV1    .EQU    WRKSPC+0x0A          ; <- Values
                           00420E    50 DIV2    .EQU    WRKSPC+0x0E          ; <-   to
                           004212    51 DIV3    .EQU    WRKSPC+0x12          ; <-   be
                           004215    52 DIV4    .EQU    WRKSPC+0x15          ; <-inserted
                           004217    53 SEED    .EQU    WRKSPC+0x17          ; Random number seed
                           00423A    54 LSTRND  .EQU    WRKSPC+0x3A          ; Last random number
                           00423E    55 INPSUB  .EQU    WRKSPC+0x3E          ; #INP (x)" Routine
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 2.
Hexadecimal [24-Bits]



                           00423F    56 INPORT  .EQU    WRKSPC+0x3F          ; PORT (x)
                           004241    57 NULLS   .EQU    WRKSPC+0x41          ; Number of nulls
                           004242    58 LWIDTH  .EQU    WRKSPC+0x42          ; Terminal width
                           004243    59 COMMAN  .EQU    WRKSPC+0x43          ; Width for commas
                           004244    60 NULFLG  .EQU    WRKSPC+0x44          ; Null after input byte flag
                           004245    61 CTLOFG  .EQU    WRKSPC+0x45          ; Control "O" flag
                           004246    62 LINESC  .EQU    WRKSPC+0x46          ; Lines counter
                           004248    63 LINESN  .EQU    WRKSPC+0x48          ; Lines number
                           00424A    64 CHKSUM  .EQU    WRKSPC+0x4A          ; Array load/save check sum
                           00424C    65 NMIFLG  .EQU    WRKSPC+0x4C          ; Flag for NMI break routine
                           00424D    66 BRKFLG  .EQU    WRKSPC+0x4D          ; Break flag
                           00424E    67 RINPUT  .EQU    WRKSPC+0x4E          ; Input reflection
                           004251    68 POINT   .EQU    WRKSPC+0x51          ; "POINT" reflection (unused)
                           004254    69 PSET    .EQU    WRKSPC+0x54          ; "SET"   reflection
                           004257    70 RESET   .EQU    WRKSPC+0x57          ; "RESET" reflection
                           00425A    71 STRSPC  .EQU    WRKSPC+0x5A          ; Bottom of string space
                           00425C    72 LINEAT  .EQU    WRKSPC+0x5C          ; Current line number
                           00425E    73 BASTXT  .EQU    WRKSPC+0x5E          ; Pointer to start of program
                           004261    74 BUFFER  .EQU    WRKSPC+0x61          ; Input buffer
                           004266    75 STACK   .EQU    WRKSPC+0x66          ; Initial stack
                           0042AB    76 CURPOS  .EQU    WRKSPC+0xAB          ; Character position on line
                           0042AC    77 LCRFLG  .EQU    WRKSPC+0xAC          ; Locate/Create flag
                           0042AD    78 TYPE    .EQU    WRKSPC+0xAD          ; Data type flag
                           0042AE    79 DATFLG  .EQU    WRKSPC+0xAE          ; Literal statement flag
                           0042AF    80 LSTRAM  .EQU    WRKSPC+0xAF          ; Last available RAM
                           0042B1    81 TMSTPT  .EQU    WRKSPC+0xB1          ; Temporary string pointer
                           0042B3    82 TMSTPL  .EQU    WRKSPC+0xB3          ; Temporary string pool
                           0042BF    83 TMPSTR  .EQU    WRKSPC+0xBF          ; Temporary string
                           0042C3    84 STRBOT  .EQU    WRKSPC+0xC3          ; Bottom of string space
                           0042C5    85 CUROPR  .EQU    WRKSPC+0xC5          ; Current operator in EVAL
                           0042C7    86 LOOPST  .EQU    WRKSPC+0xC7          ; First statement of loop
                           0042C9    87 DATLIN  .EQU    WRKSPC+0xC9          ; Line of current DATA item
                           0042CB    88 FORFLG  .EQU    WRKSPC+0xCB          ; "FOR" loop flag
                           0042CC    89 LSTBIN  .EQU    WRKSPC+0xCC          ; Last byte entered
                           0042CD    90 READFG  .EQU    WRKSPC+0xCD          ; Read/Input flag
                           0042CE    91 BRKLIN  .EQU    WRKSPC+0xCE          ; Line of break
                           0042D0    92 NXTOPR  .EQU    WRKSPC+0xD0          ; Next operator in EVAL
                           0042D2    93 ERRLIN  .EQU    WRKSPC+0xD2          ; Line of error
                           0042D4    94 CONTAD  .EQU    WRKSPC+0xD4          ; Where to CONTinue
                           0042D6    95 PROGND  .EQU    WRKSPC+0xD6          ; End of program
                           0042D8    96 VAREND  .EQU    WRKSPC+0xD8          ; End of variables
                           0042DA    97 ARREND  .EQU    WRKSPC+0xDA          ; End of arrays
                           0042DC    98 NXTDAT  .EQU    WRKSPC+0xDC          ; Next data item
                           0042DE    99 FNRGNM  .EQU    WRKSPC+0xDE          ; Name of FN argument
                           0042E0   100 FNARG   .EQU    WRKSPC+0xE0          ; FN argument value
                           0042E4   101 FPREG   .EQU    WRKSPC+0xE4          ; Floating point register
                           0042E7   102 FPEXP   .EQU    FPREG+3              ; Floating point exponent
                           0042E8   103 SGNRES  .EQU    WRKSPC+0xE8          ; Sign of result
                           0042E9   104 PBUFF   .EQU    WRKSPC+0xE9          ; Number print buffer
                           0042F6   105 MULVAL  .EQU    WRKSPC+0xF6          ; Multiplier
                           0042F9   106 PROGST  .EQU    WRKSPC+0xF9          ; Start of program text area
                           00435D   107 STLOOK  .EQU    WRKSPC+0x15D         ; Start of memory test
                                    108 
                                    109 ; BASIC ERROR CODE VALUES
                                    110 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 3.
Hexadecimal [24-Bits]



                           000000   111 NF      .EQU    0x00             ; NEXT without FOR
                           000002   112 SN      .EQU    0x02             ; Syntax error
                           000004   113 RG      .EQU    0x04             ; RETURN without GOSUB
                           000006   114 OD      .EQU    0x06             ; Out of DATA
                           000008   115 FC      .EQU    0x08             ; Function call error
                           00000A   116 OV      .EQU    0x0A             ; Overflow
                           00000C   117 OM      .EQU    0x0C             ; Out of memory
                           00000E   118 UL      .EQU    0x0E             ; Undefined line number
                           000010   119 BS      .EQU    0x10             ; Bad subscript
                           000012   120 DD      .EQU    0x12             ; Re-DIMensioned array
                           000014   121 DZ      .EQU    0x14             ; Division by zero (/0)
                           000016   122 ID      .EQU    0x16             ; Illegal direct
                           000018   123 TM      .EQU    0x18             ; Type miss-match
                           00001A   124 OS      .EQU    0x1A             ; Out of string space
                           00001C   125 LS      .EQU    0x1C             ; String too long
                           00001E   126 ST      .EQU    0x1E             ; String formula too complex
                           000020   127 CN      .EQU    0x20             ; Can't CONTinue
                           000022   128 UF      .EQU    0x22             ; UnDEFined FN function
                           000024   129 MO      .EQU    0x24             ; Missing operand
                           000026   130 HX      .EQU    0x26             ; HEX error
                           000028   131 BN      .EQU    0x28             ; BIN error
                                    132 
      002000                        133         .org    0x2000
                                    134 
      002000 C3 06 20         [10]  135 COLD:	JP      STARTB          ; Jump for cold start
      002003 C3 A4 20         [10]  136 WARM:   JP      WARMST          ; Jump for warm start
      002006                        137 STARTB: 
      002006 DD 21 00 00      [14]  138         LD      IX,#0           ; Flag cold start
      00200A C3 11 20         [10]  139         JP      CSTART          ; Jump to initialise
                                    140 
      00200D A2 28                  141         .WORD   DEINT           ; Get integer -32768 to 32767
      00200F 18 30                  142         .WORD   ABPASS          ; Return integer in AB
                                    143 
                                    144 
      002011 21 00 42         [10]  145 CSTART: LD      HL,#WRKSPC      ; Start of workspace RAM
      002014 F9               [ 6]  146         LD      SP,HL           ; Set up a temporary stack
      002015 C3 38 3C         [10]  147         JP      INITST          ; Go to initialise
                                    148 
      002018 11 C9 22         [10]  149 INIT:   LD      DE,#INITAB      ; Initialise workspace
      00201B 06 63            [ 7]  150         LD      B,#INITBE-INITAB+3; Bytes to copy
      00201D 21 00 42         [10]  151         LD      HL,#WRKSPC       ; Into workspace RAM
      002020 1A               [ 7]  152 COPY:   LD      A,(DE)          ; Get source
      002021 77               [ 7]  153         LD      (HL),A          ; To destination
      002022 23               [ 6]  154         INC     HL              ; Next destination
      002023 13               [ 6]  155         INC     DE              ; Next source
      002024 05               [ 4]  156         DEC     B               ; Count bytes
      002025 C2 20 20         [10]  157         JP      NZ,COPY         ; More to move
      002028 F9               [ 6]  158         LD      SP,HL           ; Temporary stack
      002029 CD CA 24         [17]  159         CALL    CLREG           ; Clear registers and stack
      00202C CD 98 2A         [17]  160         CALL    PRNTCRLF        ; Output CRLF
      00202F 32 AA 42         [13]  161         LD      (BUFFER+72+1),A ; Mark end of buffer
      002032 32 F9 42         [13]  162         LD      (PROGST),A      ; Initialise program area
      002035 21 F3 20         [10]  163 MSIZE:  LD      HL,#MEMMSG      ; Point to message
      002038 CD 36 31         [17]  164         CALL    PRS             ; Output "Memory size"
      00203B CD E7 24         [17]  165         CALL    PROMPT          ; Get input with '?'
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 4.
Hexadecimal [24-Bits]



      00203E CD F0 27         [17]  166         CALL    GETCHR          ; Get next character
      002041 B7               [ 4]  167         OR      A               ; Set flags
      002042 C2 5A 20         [10]  168         JP      NZ,TSTMEM       ; If number - Test if RAM there
      002045 21 5D 43         [10]  169         LD      HL,#STLOOK      ; Point to start of RAM
      002048 23               [ 6]  170 MLOOP:  INC     HL              ; Next byte
      002049 7C               [ 4]  171         LD      A,H             ; Above address FFFF ?
      00204A B5               [ 4]  172         OR      L
      00204B CA 6C 20         [10]  173         JP      Z,SETTOP        ; Yes - 64K RAM
      00204E 7E               [ 7]  174         LD      A,(HL)          ; Get contents
      00204F 47               [ 4]  175         LD      B,A             ; Save it
      002050 2F               [ 4]  176         CPL                     ; Flip all bits
      002051 77               [ 7]  177         LD      (HL),A          ; Put it back
      002052 BE               [ 7]  178         CP      (HL)            ; RAM there if same
      002053 70               [ 7]  179         LD      (HL),B          ; Restore old contents
      002054 CA 48 20         [10]  180         JP      Z,MLOOP         ; If RAM - test next byte
      002057 C3 6C 20         [10]  181         JP      SETTOP          ; Top of RAM found
                                    182 
      00205A CD BC 28         [17]  183 TSTMEM: CALL    ATOH            ; Get high memory into DE
      00205D B7               [ 4]  184         OR      A               ; Set flags on last byte
      00205E C2 98 23         [10]  185         JP      NZ,SNERR        ; ?SN Error if bad character
      002061 EB               [ 4]  186         EX      DE,HL           ; Address into HL
      002062 2B               [ 6]  187         DEC     HL              ; Back one byte
      002063 3E D9            [ 7]  188         LD      A,#0b11011001   ; Test byte
      002065 46               [ 7]  189         LD      B,(HL)          ; Get old contents
      002066 77               [ 7]  190         LD      (HL),A          ; Load test byte
      002067 BE               [ 7]  191         CP      (HL)            ; RAM there if same
      002068 70               [ 7]  192         LD      (HL),B          ; Restore old contents
      002069 C2 35 20         [10]  193         JP      NZ,MSIZE        ; Ask again if no RAM
                                    194 
      00206C 2B               [ 6]  195 SETTOP: DEC     HL              ; Back one byte
      00206D 11 5C 43         [10]  196         LD      DE,#STLOOK-1    ; See if enough RAM
      002070 CD 60 26         [17]  197         CALL    CPDEHL          ; Compare DE with HL
      002073 DA 35 20         [10]  198         JP      C,MSIZE         ; Ask again if not enough RAM
      002076 11 CE FF         [10]  199         LD      DE,#0-50        ; 50 Bytes string space
      002079 22 AF 42         [16]  200         LD      (LSTRAM),HL     ; Save last available RAM
      00207C 19               [11]  201         ADD     HL,DE           ; Allocate string space
      00207D 22 5A 42         [16]  202         LD      (STRSPC),HL     ; Save string space
      002080 CD A5 24         [17]  203         CALL    CLRPTR          ; Clear program area
      002083 2A 5A 42         [16]  204         LD      HL,(STRSPC)     ; Get end of memory
      002086 11 EF FF         [10]  205         LD      DE,#0-17         ; Offset for free bytes
      002089 19               [11]  206         ADD     HL,DE           ; Adjust HL
      00208A 11 F9 42         [10]  207         LD      DE,#PROGST      ; Start of program text
      00208D 7D               [ 4]  208         LD      A,L             ; Get LSB
      00208E 93               [ 4]  209         SUB     E               ; Adjust it
      00208F 6F               [ 4]  210         LD      L,A             ; Re-save
      002090 7C               [ 4]  211         LD      A,H             ; Get MSB
      002091 9A               [ 4]  212         SBC     A,D             ; Adjust it
      002092 67               [ 4]  213         LD      H,A             ; Re-save
      002093 E5               [11]  214         PUSH    HL              ; Save bytes free
      002094 21 BC 20         [10]  215         LD      HL,#SIGNON      ; Sign-on message
      002097 CD 36 31         [17]  216         CALL    PRS             ; Output string
      00209A E1               [10]  217         POP     HL              ; Get bytes free back
      00209B CD D9 37         [17]  218         CALL    PRNTHL          ; Output amount of free memory
      00209E 21 AD 20         [10]  219         LD      HL,#BFREE       ; " Bytes free" message
      0020A1 CD 36 31         [17]  220         CALL    PRS             ; Output string
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 5.
Hexadecimal [24-Bits]



                                    221 
      0020A4 31 66 42         [10]  222 WARMST: LD      SP,#STACK       ; Temporary stack
      0020A7 CD CA 24         [17]  223 BRKRET: CALL    CLREG           ; Clear registers and stack
      0020AA C3 E3 23         [10]  224         JP      PRNTOK          ; Go to get command line
                                    225 
      0020AD 20 42 79 74 65 73 20   226 BFREE:  .ascii  " Bytes free"
             66 72 65 65
      0020B8 0D 0A 00 00            227         .db     CR,LF,0,0
                                    228 
      0020BC 5A 38 30 20 42 41 53   229 SIGNON: .ascii  "Z80 BASIC Ver 4.7b"
             49 43 20 56 65 72 20
             34 2E 37 62
      0020CE 0D 0A                  230         .db      CR,LF
      0020D0 43 6F 70 79 72 69 67   231         .ascii  "Copyright (C) 1978 by Microsoft"
             68 74 20 28 43 29 20
             31 39 37 38 20 62 79
             20 4D 69 63 72 6F 73
             6F 66 74
      0020EF 0D 0A 00 00            232         .db     CR,LF,0,0
                                    233 
      0020F3 4D 65 6D 6F 72 79 20   234 MEMMSG: .ascii  "Memory top"
             74 6F 70
      0020FD 00                     235         .db     0
                                    236 
                                    237 ; FUNCTION ADDRESS TABLE
                                    238 
      0020FE 4E 36                  239 FNCTAB: .WORD   SGN
      002100 12 37                  240         .WORD   INT
      002102 64 36                  241         .WORD   ABS
      002104 03 42                  242         .WORD   USR
      002106 F6 2F                  243         .WORD   FRE
      002108 7B 33                  244         .WORD   INP
      00210A 24 30                  245         .WORD   POS
      00210C D8 38                  246         .WORD   SQR
      00210E B7 39                  247         .WORD   RND
      002110 F3 34                  248         .WORD   LOG
      002112 26 39                  249         .WORD   EXP
      002114 2C 3A                  250         .WORD   COS
      002116 32 3A                  251         .WORD   SIN
      002118 93 3A                  252         .WORD   TAN
      00211A A8 3A                  253         .WORD   ATN
      00211C CF 33                  254         .WORD   PEEK
      00211E 13 3B                  255         .WORD   DEEK
      002120 51 42                  256         .WORD   POINT
      002122 A8 32                  257         .WORD   LEN
      002124 C0 30                  258         .WORD   STR
      002126 42 33                  259         .WORD   VAL
      002128 B7 32                  260         .WORD   ASC
      00212A C8 32                  261         .WORD   CHR
      00212C 35 3B                  262         .WORD   HEX
      00212E C8 3B                  263         .WORD   BIN
      002130 D8 32                  264         .WORD   LEFT
      002132 08 33                  265         .WORD   RIGHT
      002134 12 33                  266         .WORD   MID
                                    267 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 6.
Hexadecimal [24-Bits]



                                    268 ; RESERVED WORD LIST
                                    269 
      002136 C5                     270 WORDS:  .BYTE   'E'+0x80
      002137 4E 44                  271          .ascii "ND"
      002139 C6                     272         .BYTE   'F'+0x80
      00213A 4F 52                  273         .ascii  "OR"
      00213C CE                     274         .BYTE   'N'+0x80
      00213D 45 58 54               275         .ascii  "EXT"
      002140 C4                     276         .BYTE   'D'+0x80
      002141 41 54 41               277         .ascii  "ATA"
      002144 C9                     278         .BYTE   'I'+0x80
      002145 4E 50 55 54            279         .ascii  "NPUT"
      002149 C4                     280         .BYTE   'D'+0x80
      00214A 49 4D                  281         .ascii  "IM"
      00214C D2                     282         .BYTE   'R'+0x80
      00214D 45 41 44               283         .ascii  "EAD"
      002150 CC                     284         .BYTE   'L'+0x80
      002151 45 54                  285         .ascii  "ET"
      002153 C7                     286         .BYTE   'G'+0x80
      002154 4F 54 4F               287         .ascii  "OTO"
      002157 D2                     288         .BYTE   'R'+0x80
      002158 55 4E                  289         .ascii  "UN"
      00215A C9                     290         .BYTE   'I'+0x80
      00215B 46                     291         .ascii  "F"
      00215C D2                     292         .BYTE   'R'+0x80
      00215D 45 53 54 4F 52 45      293         .ascii  "ESTORE"
      002163 C7                     294         .BYTE   'G'+0x80
      002164 4F 53 55 42            295         .ascii  "OSUB"
      002168 D2                     296         .BYTE   'R'+0x80
      002169 45 54 55 52 4E         297         .ascii  "ETURN"
      00216E D2                     298         .BYTE   'R'+0x80
      00216F 45 4D                  299         .ascii  "EM"
      002171 D3                     300         .BYTE   'S'+0x80
      002172 54 4F 50               301         .ascii  "TOP"
      002175 CF                     302         .BYTE   'O'+0x80
      002176 55 54                  303         .ascii  "UT"
      002178 CF                     304         .BYTE   'O'+0x80
      002179 4E                     305         .ascii  "N"
      00217A CE                     306         .BYTE   'N'+0x80
      00217B 55 4C 4C               307         .ascii  "ULL"
      00217E D7                     308         .BYTE   'W'+0x80
      00217F 41 49 54               309         .ascii  "AIT"
      002182 C4                     310         .BYTE   'D'+0x80
      002183 45 46                  311         .ascii  "EF"
      002185 D0                     312         .BYTE   'P'+0x80
      002186 4F 4B 45               313         .ascii  "OKE"
      002189 C4                     314         .BYTE   'D'+0x80
      00218A 4F 4B 45               315         .ascii  "OKE"
      00218D D3                     316         .BYTE   'S'+0x80
      00218E 43 52 45 45 4E         317         .ascii  "CREEN"
      002193 CC                     318         .BYTE   'L'+0x80
      002194 49 4E 45 53            319         .ascii  "INES"
      002198 C3                     320         .BYTE   'C'+0x80
      002199 4C 53                  321         .ascii  "LS"
      00219B D7                     322         .BYTE   'W'+0x80
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 7.
Hexadecimal [24-Bits]



      00219C 49 44 54 48            323         .ascii  "IDTH"
      0021A0 CD                     324         .BYTE   'M'+0x80
      0021A1 4F 4E 49 54 4F 52      325         .ascii  "ONITOR"
      0021A7 D3                     326         .BYTE   'S'+0x80
      0021A8 45 54                  327         .ascii  "ET"
      0021AA D2                     328         .BYTE   'R'+0x80
      0021AB 45 53 45 54            329         .ascii  "ESET"
      0021AF D0                     330         .BYTE   'P'+0x80
      0021B0 52 49 4E 54            331         .ascii  "RINT"
      0021B4 C3                     332         .BYTE   'C'+0x80
      0021B5 4F 4E 54               333         .ascii  "ONT"
      0021B8 CC                     334         .BYTE   'L'+0x80
      0021B9 49 53 54               335         .ascii  "IST"
      0021BC C3                     336         .BYTE   'C'+0x80
      0021BD 4C 45 41 52            337         .ascii  "LEAR"
      0021C1 C3                     338         .BYTE   'C'+0x80
      0021C2 4C 4F 41 44            339         .ascii  "LOAD"
      0021C6 C3                     340         .BYTE   'C'+0x80
      0021C7 53 41 56 45            341         .ascii  "SAVE"
      0021CB CE                     342         .BYTE   'N'+0x80
      0021CC 45 57                  343         .ascii  "EW"
                                    344 
      0021CE D4                     345         .BYTE   'T'+0x80
      0021CF 41 42 28               346         .ascii  "AB("
      0021D2 D4                     347         .BYTE   'T'+0x80
      0021D3 4F                     348         .ascii  "O"
      0021D4 C6                     349         .BYTE   'F'+0x80
      0021D5 4E                     350         .ascii  "N"
      0021D6 D3                     351         .BYTE   'S'+0x80
      0021D7 50 43 28               352         .ascii  "PC("
      0021DA D4                     353         .BYTE   'T'+0x80
      0021DB 48 45 4E               354         .ascii  "HEN"
      0021DE CE                     355         .BYTE   'N'+0x80
      0021DF 4F 54                  356         .ascii  "OT"
      0021E1 D3                     357         .BYTE   'S'+0x80
      0021E2 54 45 50               358         .ascii  "TEP"
                                    359 
      0021E5 AB                     360         .BYTE   '+'+0x80
      0021E6 AD                     361         .BYTE   '-'+0x80
      0021E7 AA                     362         .BYTE   '*'+0x80
      0021E8 AF                     363         .BYTE   '/'+0x80
      0021E9 DE                     364         .BYTE   '^'+0x80
      0021EA C1                     365         .BYTE   'A'+0x80
      0021EB 4E 44                  366         .ascii  "ND"
      0021ED CF                     367         .BYTE   'O'+0x80
      0021EE 52                     368         .ascii  "R"
      0021EF BE                     369         .BYTE   '>'+0x80
      0021F0 BD                     370         .BYTE   '='+0x80
      0021F1 BC                     371         .BYTE   '<'+0x80
                                    372 
      0021F2 D3                     373         .BYTE   'S'+0x80
      0021F3 47 4E                  374         .ascii  "GN"
      0021F5 C9                     375         .BYTE   'I'+0x80
      0021F6 4E 54                  376         .ascii  "NT"
      0021F8 C1                     377         .BYTE   'A'+0x80
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 8.
Hexadecimal [24-Bits]



      0021F9 42 53                  378         .ascii  "BS"
      0021FB D5                     379         .BYTE   'U'+0x80
      0021FC 53 52                  380         .ascii  "SR"
      0021FE C6                     381         .BYTE   'F'+0x80
      0021FF 52 45                  382         .ascii  "RE"
      002201 C9                     383         .BYTE   'I'+0x80
      002202 4E 50                  384         .ascii  "NP"
      002204 D0                     385         .BYTE   'P'+0x80
      002205 4F 53                  386         .ascii  "OS"
      002207 D3                     387         .BYTE   'S'+0x80
      002208 51 52                  388         .ascii  "QR"
      00220A D2                     389         .BYTE   'R'+0x80
      00220B 4E 44                  390         .ascii  "ND"
      00220D CC                     391         .BYTE   'L'+0x80
      00220E 4F 47                  392         .ascii  "OG"
      002210 C5                     393         .BYTE   'E'+0x80
      002211 58 50                  394         .ascii  "XP"
      002213 C3                     395         .BYTE   'C'+0x80
      002214 4F 53                  396         .ascii  "OS"
      002216 D3                     397         .BYTE   'S'+0x80
      002217 49 4E                  398         .ascii  "IN"
      002219 D4                     399         .BYTE   'T'+0x80
      00221A 41 4E                  400         .ascii  "AN"
      00221C C1                     401         .BYTE   'A'+0x80
      00221D 54 4E                  402         .ascii  "TN"
      00221F D0                     403         .BYTE   'P'+0x80
      002220 45 45 4B               404         .ascii  "EEK"
      002223 C4                     405         .BYTE   'D'+0x80
      002224 45 45 4B               406         .ascii  "EEK"
      002227 D0                     407         .BYTE   'P'+0x80
      002228 4F 49 4E 54            408         .ascii  "OINT"
      00222C CC                     409         .BYTE   'L'+0x80
      00222D 45 4E                  410         .ascii  "EN"
      00222F D3                     411         .BYTE   'S'+0x80
      002230 54 52 24               412         .ascii  "TR$"
      002233 D6                     413         .BYTE   'V'+0x80
      002234 41 4C                  414         .ascii  "AL"
      002236 C1                     415         .BYTE   'A'+0x80
      002237 53 43                  416         .ascii  "SC"
      002239 C3                     417         .BYTE   'C'+0x80
      00223A 48 52 24               418         .ascii  "HR$"
      00223D C8                     419         .BYTE   'H'+0x80
      00223E 45 58 24               420         .ascii  "EX$"
      002241 C2                     421         .BYTE   'B'+0x80
      002242 49 4E 24               422         .ascii  "IN$"
      002245 CC                     423         .BYTE   'L'+0x80
      002246 45 46 54 24            424         .ascii  "EFT$"
      00224A D2                     425         .BYTE   'R'+0x80
      00224B 49 47 48 54 24         426         .ascii  "IGHT$"
      002250 CD                     427         .BYTE   'M'+0x80
      002251 49 44 24               428         .ascii  "ID$"
      002254 80                     429         .BYTE   0x80            ; End of list marker
                                    430 
                                    431 ; KEYWORD ADDRESS TABLE
                                    432 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 9.
Hexadecimal [24-Bits]



      002255 3A 28                  433 WORDTB: .WORD   PEND
      002257 37 27                  434         .WORD   FOR
      002259 12 2C                  435         .WORD   NEXT
      00225B 87 29                  436         .WORD   DATA
      00225D 19 2B                  437         .WORD   INPUT
      00225F 4E 2E                  438         .WORD   DIM
      002261 48 2B                  439         .WORD   READ
      002263 9E 29                  440         .WORD   LET
      002265 44 29                  441         .WORD   GOTO
      002267 27 29                  442         .WORD   RUN
      002269 16 2A                  443         .WORD   IF
      00226B 00 28                  444         .WORD   RESTOR
      00226D 33 29                  445         .WORD   GOSUB
      00226F 62 29                  446         .WORD   RETURN
      002271 89 29                  447         .WORD   REM
      002273 38 28                  448         .WORD   STOP
      002275 87 33                  449         .WORD   POUT
      002277 F8 29                  450         .WORD   ON
      002279 79 28                  451         .WORD   NULL
      00227B 8D 33                  452         .WORD   WAIT
      00227D 2C 30                  453         .WORD   DEF
      00227F D6 33                  454         .WORD   POKE
      002281 1E 3B                  455         .WORD   DOKE
      002283 89 29                  456         .WORD   REM
      002285 04 3B                  457         .WORD   LINES
      002287 F7 3A                  458         .WORD   CLS
      002289 FC 3A                  459         .WORD   WIDTH
      00228B 35 3C                  460         .WORD   MONITR
      00228D 54 42                  461         .WORD   PSET
      00228F 57 42                  462         .WORD   RESET
      002291 3A 2A                  463         .WORD   PRINT
      002293 66 28                  464         .WORD   CONT
      002295 AC 26                  465         .WORD   LIST
      002297 E1 28                  466         .WORD   CLEAR
      002299 89 29                  467         .WORD   REM
      00229B 89 29                  468         .WORD   REM
      00229D A4 24                  469         .WORD   NEW
                                    470 
                                    471 ; RESERVED WORD TOKEN VALUES
                                    472 
                           000080   473 ZEND    .EQU    0x80            ; END
                           000081   474 ZFOR    .EQU    0x81            ; FOR
                           000083   475 ZDATA   .EQU    0x83            ; DATA
                           000088   476 ZGOTO   .EQU    0x88            ; GOTO
                           00008C   477 ZGOSUB  .EQU    0x8C            ; GOSUB
                           00008E   478 ZREM    .EQU    0x8E            ; REM
                           00009E   479 ZPRINT  .EQU    0x9E            ; PRINT
                           0000A4   480 ZNEW    .EQU    0xA4            ; NEW
                                    481 
                           0000A5   482 ZTAB    .EQU    0xA5            ; TAB
                           0000A6   483 ZTO     .EQU    0xA6            ; TO
                           0000A7   484 ZFN     .EQU    0xA7            ; FN
                           0000A8   485 ZSPC    .EQU    0xA8            ; SPC
                           0000A9   486 ZTHEN   .EQU    0xA9            ; THEN
                           0000AA   487 ZNOT    .EQU    0xAA            ; NOT
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 10.
Hexadecimal [24-Bits]



                           0000AB   488 ZSTEP   .EQU    0xAB            ; STEP
                                    489 
                           0000AC   490 ZPLUS   .EQU    0xAC            ; +
                           0000AD   491 ZMINUS  .EQU    0xAD            ; -
                           0000AE   492 ZTIMES  .EQU    0xAE            ; *
                           0000AF   493 ZDIV    .EQU    0xAF            ; /
                           0000B2   494 ZOR     .EQU    0xB2            ; OR
                           0000B3   495 ZGTR    .EQU    0xB3            ; >
                           0000B4   496 ZEQUAL  .EQU    0xB4            ; M
                           0000B5   497 ZLTH    .EQU    0xB5            ; <
                           0000B6   498 ZSGN    .EQU    0xB6            ; SGN
                           0000C7   499 ZPOINT  .EQU    0xC7            ; POINT
                           0000CF   500 ZLEFT   .EQU    0xCD +2         ; LEFT$
                                    501 
                                    502 ; ARITHMETIC PRECEDENCE TABLE
                                    503 
      00229F 79                     504 PRITAB: .BYTE   0x79            ; Precedence value
      0022A0 C0 37                  505         .WORD   PADD            ; FPREG = <last> + FPREG
                                    506 
      0022A2 79                     507         .BYTE   0x79            ; Precedence value
      0022A3 F4 33                  508         .WORD   PSUB            ; FPREG = <last> - FPREG
                                    509 
      0022A5 7C                     510         .BYTE   0x7C            ; Precedence value
      0022A6 32 35                  511         .WORD   MULT            ; PPREG = <last> * FPREG
                                    512 
      0022A8 7C                     513         .BYTE   0x7C            ; Precedence value
      0022A9 93 35                  514         .WORD   DIV             ; FPREG = <last> / FPREG
                                    515 
      0022AB 7F                     516         .BYTE   0x7F            ; Precedence value
      0022AC E1 38                  517         .WORD   POWER           ; FPREG = <last> ^ FPREG
                                    518 
      0022AE 50                     519         .BYTE   0x50            ; Precedence value
      0022AF A7 2D                  520         .WORD   PAND            ; FPREG = <last> AND FPREG
                                    521 
      0022B1 46                     522         .BYTE   0x46            ; Precedence value
      0022B2 A6 2D                  523         .WORD   POR             ; FPREG = <last> OR FPREG
                                    524 
                                    525 ; BASIC ERROR CODE LIST
                                    526 
      0022B4 4E                     527 ERRORS: .BYTE   "NF"            ; NEXT without FOR
      0022B5 53                     528         .BYTE   "SN"            ; Syntax error
      0022B6 52                     529         .BYTE   "RG"            ; RETURN without GOSUB
      0022B7 4F                     530         .BYTE   "OD"            ; Out of DATA
      0022B8 46                     531         .BYTE   "FC"            ; Illegal function call
      0022B9 4F                     532         .BYTE   "OV"            ; Overflow error
      0022BA 4F                     533         .BYTE   "OM"            ; Out of memory
      0022BB 55                     534         .BYTE   "UL"            ; Undefined line
      0022BC 42                     535         .BYTE   "BS"            ; Bad subscript
      0022BD 44                     536         .BYTE   "DD"            ; Re-DIMensioned array
      0022BE 2F                     537         .BYTE   "/0"            ; Division by zero
      0022BF 49                     538         .BYTE   "ID"            ; Illegal direct
      0022C0 54                     539         .BYTE   "TM"            ; Type mis-match
      0022C1 4F                     540         .BYTE   "OS"            ; Out of string space
      0022C2 4C                     541         .BYTE   "LS"            ; String too long
      0022C3 53                     542         .BYTE   "ST"            ; String formula too complex
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 11.
Hexadecimal [24-Bits]



      0022C4 43                     543         .BYTE   "CN"            ; Can't CONTinue
      0022C5 55                     544         .BYTE   "UF"            ; Undefined FN function
      0022C6 4D                     545         .BYTE   "MO"            ; Missing operand
      0022C7 48                     546         .BYTE   "HX"            ; HEX error
      0022C8 42                     547         .BYTE   "BN"            ; BIN error
                                    548 
                                    549 ; INITIALISATION TABLE -------------------------------------------------------
                                    550 
      0022C9 C3 A4 20         [10]  551 INITAB: JP      WARMST          ; Warm start jump
      0022CC C3 B7 28         [10]  552         JP      FCERR           ; "USR (X)" jump (Set to Error)
      0022CF D3 00            [11]  553         OUT     (0),A           ; "OUT p,n" skeleton
      0022D1 C9               [10]  554         RET
      0022D2 D6 00            [ 7]  555         SUB     #0              ; Division support routine
      0022D4 6F               [ 4]  556         LD      L,A
      0022D5 7C               [ 4]  557         LD      A,H
      0022D6 DE 00            [ 7]  558         SBC     A,#0
      0022D8 67               [ 4]  559         LD      H,A
      0022D9 78               [ 4]  560         LD      A,B
      0022DA DE 00            [ 7]  561         SBC     A,#0
      0022DC 47               [ 4]  562         LD      B,A
      0022DD 3E 00            [ 7]  563         LD      A,#0
      0022DF C9               [10]  564         RET
      0022E0 00 00 00               565         .BYTE   0,0,0                   ; Random number seed table used by RND
      0022E3 35 4A CA 99            566         .BYTE   0x35,0x4A,0xCA,0x99     ;-2.65145E+07
      0022E7 39 1C 76 98            567         .BYTE   0x39,0x1C,0x76,0x98     ; 1.61291E+07
      0022EB 22 95 B3 98            568         .BYTE   0x22,0x95,0xB3,0x98     ;-1.17691E+07
      0022EF 0A DD 47 98            569         .BYTE   0x0A,0xDD,0x47,0x98     ; 1.30983E+07
      0022F3 53 D1 99 99            570         .BYTE   0x53,0xD1,0x99,0x99     ;-2-01612E+07
      0022F7 0A 1A 9F 98            571         .BYTE   0x0A,0x1A,0x9F,0x98     ;-1.04269E+07
      0022FB 65 BC CD 98            572         .BYTE   0x65,0xBC,0xCD,0x98     ;-1.34831E+07
      0022FF D6 77 3E 98            573         .BYTE   0xD6,0x77,0x3E,0x98     ; 1.24825E+07
      002303 52 C7 4F 80            574         .BYTE   0x52,0xC7,0x4F,0x80     ; Last random number
      002307 DB 00            [11]  575         IN      A,(0)           ; INP (x) skeleton
      002309 C9               [10]  576         RET
      00230A 01                     577         .BYTE   1               ; POS (x) number (1)
      00230B FF                     578         .BYTE   255             ; Terminal width (255 = no auto CRLF)
      00230C 1C                     579         .BYTE   28              ; Width for commas (3 columns)
      00230D 00                     580         .BYTE   0               ; No nulls after input bytes
      00230E 00                     581         .BYTE   0               ; Output enabled (^O off)
      00230F 14 00                  582         .WORD   20              ; Initial lines counter
      002311 14 00                  583         .WORD   20              ; Initial lines number
      002313 00 00                  584         .WORD   0               ; Array load/save check sum
      002315 00                     585         .BYTE   0               ; Break not by NMI
      002316 00                     586         .BYTE   0               ; Break flag
      002317 C3 DD 25         [10]  587         JP      TTYLIN          ; Input reflection (set to TTY)
      00231A C3 00 00         [10]  588         JP      0x0000          ; POINT reflection unused
      00231D C3 00 00         [10]  589         JP      0x0000          ; SET reflection
      002320 C3 00 00         [10]  590         JP      0x0000         	; RESET reflection
      002323 5D 43                  591         .WORD   STLOOK          ; Temp string space
      002325 FE FF                  592         .WORD   -2              ; Current line number (cold)
      002327 FA 42                  593         .WORD   PROGST+1        ; Start of program text
      002329                        594 INITBE:                         
                                    595 
                                    596 ; END OF INITIALISATION TABLE ---------------------------------------------------
                                    597 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 12.
Hexadecimal [24-Bits]



      002329 20 45 72 72 6F 72      598 ERRMSG: .ascii  " Error"
      00232F 00                     599         .byte   0
      002330 20 69 6E 20            600 INMSG:  .ascii  " in "
      002334 00                     601 ZERBYT: .byte   0               ; A zero byte
      002335 4F 6B                  602 OKMSG:  .ascii  "Ok"
      002337 0D 0A 00 00            603         .byte   CR,LF,0,0
      00233B 42 72 65 61 6B         604 BRKMSG: .ascii  "Break"
      002340 00                     605         .byte   0
                                    606 
      002341 21 04 00         [10]  607 BAKSTK: LD      HL,#4           ; Look for "FOR" block with
      002344 39               [11]  608         ADD     HL,SP           ; same index as specified
      002345 7E               [ 7]  609 LOKFOR: LD      A,(HL)          ; Get block ID
      002346 23               [ 6]  610         INC     HL              ; Point to index address
      002347 FE 81            [ 7]  611         CP      #ZFOR            ; Is it a "FOR" token
      002349 C0               [11]  612         RET     NZ              ; No - exit
      00234A 4E               [ 7]  613         LD      C,(HL)          ; BC = Address of "FOR" index
      00234B 23               [ 6]  614         INC     HL
      00234C 46               [ 7]  615         LD      B,(HL)
      00234D 23               [ 6]  616         INC     HL              ; Point to sign of STEP
      00234E E5               [11]  617         PUSH    HL              ; Save pointer to sign
      00234F 69               [ 4]  618         LD      L,C             ; HL = address of "FOR" index
      002350 60               [ 4]  619         LD      H,B
      002351 7A               [ 4]  620         LD      A,D             ; See if an index was specified
      002352 B3               [ 4]  621         OR      E               ; DE = 0 if no index specified
      002353 EB               [ 4]  622         EX      DE,HL           ; Specified index into HL
      002354 CA 5B 23         [10]  623         JP      Z,INDFND        ; Skip if no index given
      002357 EB               [ 4]  624         EX      DE,HL           ; Index back into DE
      002358 CD 60 26         [17]  625         CALL    CPDEHL          ; Compare index with one given
      00235B 01 0D 00         [10]  626 INDFND: LD      BC,#16-3        ; Offset to next block
      00235E E1               [10]  627         POP     HL              ; Restore pointer to sign
      00235F C8               [11]  628         RET     Z               ; Return if block found
      002360 09               [11]  629         ADD     HL,BC           ; Point to next block
      002361 C3 45 23         [10]  630         JP      LOKFOR          ; Keep on looking
                                    631 
      002364 CD 7E 23         [17]  632 MOVUP:  CALL    ENFMEM          ; See if enough memory
      002367 C5               [11]  633 MOVSTR: PUSH    BC              ; Save end of source
      002368 E3               [19]  634         EX      (SP),HL         ; Swap source and dest" end
      002369 C1               [10]  635         POP     BC              ; Get end of destination
      00236A CD 60 26         [17]  636 MOVLP:  CALL    CPDEHL          ; See if list moved
      00236D 7E               [ 7]  637         LD      A,(HL)          ; Get byte
      00236E 02               [ 7]  638         LD      (BC),A          ; Move it
      00236F C8               [11]  639         RET     Z               ; Exit if all done
      002370 0B               [ 6]  640         DEC     BC              ; Next byte to move to
      002371 2B               [ 6]  641         DEC     HL              ; Next byte to move
      002372 C3 6A 23         [10]  642         JP      MOVLP           ; Loop until all bytes moved
                                    643 
      002375 E5               [11]  644 CHKSTK: PUSH    HL              ; Save code string address
      002376 2A DA 42         [16]  645         LD      HL,(ARREND)     ; Lowest free memory
      002379 06 00            [ 7]  646         LD      B,#0            ; BC = Number of levels to test
      00237B 09               [11]  647         ADD     HL,BC           ; 2 Bytes for each level
      00237C 09               [11]  648         ADD     HL,BC
      00237D 3E                     649         .BYTE   0x3E            ; Skip "PUSH HL"
      00237E E5               [11]  650 ENFMEM: PUSH    HL              ; Save code string address
      00237F 3E D0            [ 7]  651         LD      A,#0xD0;LOW -48 ; 48 Bytes minimum RAM
      002381 95               [ 4]  652         SUB     L
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 13.
Hexadecimal [24-Bits]



      002382 6F               [ 4]  653         LD      L,A
      002383 3E FF            [ 7]  654         LD      A,#0xFF; HIGH (-48) ; 48 Bytes minimum RAM
      002385 9C               [ 4]  655         SBC     A,H
      002386 DA 8D 23         [10]  656         JP      C,OMERR         ; Not enough - ?OM Error
      002389 67               [ 4]  657         LD      H,A
      00238A 39               [11]  658         ADD     HL,SP           ; Test if stack is overflowed
      00238B E1               [10]  659         POP     HL              ; Restore code string address
      00238C D8               [11]  660         RET     C               ; Return if enough mmory
      00238D 1E 0C            [ 7]  661 OMERR:  LD      E,#OM           ; ?OM Error
      00238F C3 AC 23         [10]  662         JP      ERROR
                                    663 
      002392 2A C9 42         [16]  664 DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
      002395 22 5C 42         [16]  665         LD      (LINEAT),HL     ; Save as current line
      002398 1E 02            [ 7]  666 SNERR:  LD      E,#SN           ; ?SN Error
      00239A 01                     667         .BYTE   0x01            ; Skip "LD E,DZ"
      00239B 1E 14            [ 7]  668 DZERR:  LD      E,#DZ           ; ?/0 Error
      00239D 01                     669         .BYTE   0x01            ; Skip "LD E,NF"
      00239E 1E 00            [ 7]  670 NFERR:  LD      E,#NF           ; ?NF Error
      0023A0 01                     671         .BYTE   0x01            ; Skip "LD E,DD"
      0023A1 1E 12            [ 7]  672 DDERR:  LD      E,#DD           ; ?DD Error
      0023A3 01                     673         .BYTE   0x01            ; Skip "LD E,UF"
      0023A4 1E 22            [ 7]  674 UFERR:  LD      E,#UF           ; ?UF Error
      0023A6 01                     675         .BYTE   0x01            ; Skip "LD E,OV
      0023A7 1E 0A            [ 7]  676 OVERR:  LD      E,#OV           ; ?OV Error
      0023A9 01                     677         .BYTE   0x01            ; Skip "LD E,TM"
      0023AA 1E 18            [ 7]  678 TMERR:  LD      E,#TM           ; ?TM Error
                                    679 
      0023AC CD CA 24         [17]  680 ERROR:  CALL    CLREG           ; Clear registers and stack
      0023AF 32 45 42         [13]  681         LD      (CTLOFG),A      ; Enable output (A is 0)
      0023B2 CD 8B 2A         [17]  682         CALL    STTLIN          ; Start new line
      0023B5 21 B4 22         [10]  683         LD      HL,#ERRORS      ; Point to error codes
      0023B8 57               [ 4]  684         LD      D,A             ; D = 0 (A is 0)
      0023B9 3E 3F            [ 7]  685         LD      A,#'?'
      0023BB CD 71 26         [17]  686         CALL    OUTC            ; Output '?'
      0023BE 19               [11]  687         ADD     HL,DE           ; Offset to correct error code
      0023BF 7E               [ 7]  688         LD      A,(HL)          ; First character
      0023C0 CD 71 26         [17]  689         CALL    OUTC            ; Output it
      0023C3 CD F0 27         [17]  690         CALL    GETCHR          ; Get next character
      0023C6 CD 71 26         [17]  691         CALL    OUTC            ; Output it
      0023C9 21 29 23         [10]  692         LD      HL,#ERRMSG      ; "Error" message
      0023CC CD 36 31         [17]  693 ERRIN:  CALL    PRS             ; Output message
      0023CF 2A 5C 42         [16]  694         LD      HL,(LINEAT)     ; Get line of error
      0023D2 11 FE FF         [10]  695         LD      DE,#-2          ; Cold start error if -2
      0023D5 CD 60 26         [17]  696         CALL    CPDEHL          ; See if cold start error
      0023D8 CA 11 20         [10]  697         JP      Z,CSTART        ; Cold start error - Restart
      0023DB 7C               [ 4]  698         LD      A,H             ; Was it a direct error?
      0023DC A5               [ 4]  699         AND     L               ; Line = -1 if direct error
      0023DD 3C               [ 4]  700         INC     A
      0023DE C4 D1 37         [17]  701         CALL    NZ,LINEIN       ; No - output line of error
      0023E1 3E                     702         .BYTE   0x3E            ; Skip "POP BC"
      0023E2 C1               [10]  703 POPNOK: POP     BC              ; Drop address in input buffer
                                    704 
      0023E3 AF               [ 4]  705 PRNTOK: XOR     A               ; Output "Ok" and get command
      0023E4 32 45 42         [13]  706         LD      (CTLOFG),A      ; Enable output
      0023E7 CD 8B 2A         [17]  707         CALL    STTLIN          ; Start new line
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 14.
Hexadecimal [24-Bits]



      0023EA 21 35 23         [10]  708         LD      HL,#OKMSG       ; "Ok" message
      0023ED CD 36 31         [17]  709         CALL    PRS             ; Output "Ok"
      0023F0 21 FF FF         [10]  710 GETCMD: LD      HL,#-1          ; Flag direct mode
      0023F3 22 5C 42         [16]  711         LD      (LINEAT),HL     ; Save as current line
      0023F6 CD DD 25         [17]  712         CALL    GETLIN          ; Get an input line
      0023F9 DA F0 23         [10]  713         JP      C,GETCMD        ; Get line again if break
      0023FC CD F0 27         [17]  714         CALL    GETCHR          ; Get first character
      0023FF 3C               [ 4]  715         INC     A               ; Test if end of line
      002400 3D               [ 4]  716         DEC     A               ; Without affecting Carry
      002401 CA F0 23         [10]  717         JP      Z,GETCMD        ; Nothing entered - Get another
      002404 F5               [11]  718         PUSH    AF              ; Save Carry status
      002405 CD BC 28         [17]  719         CALL    ATOH            ; Get line number into DE
      002408 D5               [11]  720         PUSH    DE              ; Save line number
      002409 CD F4 24         [17]  721         CALL    CRUNCH          ; Tokenise rest of line
      00240C 47               [ 4]  722         LD      B,A             ; Length of tokenised line
      00240D D1               [10]  723         POP     DE              ; Restore line number
      00240E F1               [10]  724         POP     AF              ; Restore Carry
      00240F D2 D0 27         [10]  725         JP      NC,EXCUTE       ; No line number - Direct mode
      002412 D5               [11]  726         PUSH    DE              ; Save line number
      002413 C5               [11]  727         PUSH    BC              ; Save length of tokenised line
      002414 AF               [ 4]  728         XOR     A
      002415 32 CC 42         [13]  729         LD      (LSTBIN),A      ; Clear last byte input
      002418 CD F0 27         [17]  730         CALL    GETCHR          ; Get next character
      00241B B7               [ 4]  731         OR      A               ; Set flags
      00241C F5               [11]  732         PUSH    AF              ; And save them
      00241D CD 84 24         [17]  733         CALL    SRCHLN          ; Search for line number in DE
      002420 DA 29 24         [10]  734         JP      C,LINFND        ; Jump if line found
      002423 F1               [10]  735         POP     AF              ; Get status
      002424 F5               [11]  736         PUSH    AF              ; And re-save
      002425 CA 5D 29         [10]  737         JP      Z,ULERR         ; Nothing after number - Error
      002428 B7               [ 4]  738         OR      A               ; Clear Carry
      002429 C5               [11]  739 LINFND: PUSH    BC              ; Save address of line in prog
      00242A D2 40 24         [10]  740         JP      NC,INEWLN       ; Line not found - Insert new
      00242D EB               [ 4]  741         EX      DE,HL           ; Next line address in DE
      00242E 2A D6 42         [16]  742         LD      HL,(PROGND)     ; End of program
      002431 1A               [ 7]  743 SFTPRG: LD      A,(DE)          ; Shift rest of program down
      002432 02               [ 7]  744         LD      (BC),A
      002433 03               [ 6]  745         INC     BC              ; Next destination
      002434 13               [ 6]  746         INC     DE              ; Next source
      002435 CD 60 26         [17]  747         CALL    CPDEHL          ; All done?
      002438 C2 31 24         [10]  748         JP      NZ,SFTPRG       ; More to do
      00243B 60               [ 4]  749         LD      H,B             ; HL - New end of program
      00243C 69               [ 4]  750         LD      L,C
      00243D 22 D6 42         [16]  751         LD      (PROGND),HL     ; Update end of program
                                    752 
      002440 D1               [10]  753 INEWLN: POP     DE              ; Get address of line,
      002441 F1               [10]  754         POP     AF              ; Get status
      002442 CA 67 24         [10]  755         JP      Z,SETPTR        ; No text - Set up pointers
      002445 2A D6 42         [16]  756         LD      HL,(PROGND)     ; Get end of program
      002448 E3               [19]  757         EX      (SP),HL         ; Get length of input line
      002449 C1               [10]  758         POP     BC              ; End of program to BC
      00244A 09               [11]  759         ADD     HL,BC           ; Find new end
      00244B E5               [11]  760         PUSH    HL              ; Save new end
      00244C CD 64 23         [17]  761         CALL    MOVUP           ; Make space for line
      00244F E1               [10]  762         POP     HL              ; Restore new end
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 15.
Hexadecimal [24-Bits]



      002450 22 D6 42         [16]  763         LD      (PROGND),HL     ; Update end of program pointer
      002453 EB               [ 4]  764         EX      DE,HL           ; Get line to move up in HL
      002454 74               [ 7]  765         LD      (HL),H          ; Save MSB
      002455 D1               [10]  766         POP     DE              ; Get new line number
      002456 23               [ 6]  767         INC     HL              ; Skip pointer
      002457 23               [ 6]  768         INC     HL
      002458 73               [ 7]  769         LD      (HL),E          ; Save LSB of line number
      002459 23               [ 6]  770         INC     HL
      00245A 72               [ 7]  771         LD      (HL),D          ; Save MSB of line number
      00245B 23               [ 6]  772         INC     HL              ; To first byte in line
      00245C 11 61 42         [10]  773         LD      DE,#BUFFER      ; Copy buffer to program
      00245F 1A               [ 7]  774 MOVBUF: LD      A,(DE)          ; Get source
      002460 77               [ 7]  775         LD      (HL),A          ; Save destinations
      002461 23               [ 6]  776         INC     HL              ; Next source
      002462 13               [ 6]  777         INC     DE              ; Next destination
      002463 B7               [ 4]  778         OR      A               ; Done?
      002464 C2 5F 24         [10]  779         JP      NZ,MOVBUF       ; No - Repeat
      002467 CD B0 24         [17]  780 SETPTR: CALL    RUNFST          ; Set line pointers
      00246A 23               [ 6]  781         INC     HL              ; To LSB of pointer
      00246B EB               [ 4]  782         EX      DE,HL           ; Address to DE
      00246C 62               [ 4]  783 PTRLP:  LD      H,D             ; Address to HL
      00246D 6B               [ 4]  784         LD      L,E
      00246E 7E               [ 7]  785         LD      A,(HL)          ; Get LSB of pointer
      00246F 23               [ 6]  786         INC     HL              ; To MSB of pointer
      002470 B6               [ 7]  787         OR      (HL)            ; Compare with MSB pointer
      002471 CA F0 23         [10]  788         JP      Z,GETCMD        ; Get command line if end
      002474 23               [ 6]  789         INC     HL              ; To LSB of line number
      002475 23               [ 6]  790         INC     HL              ; Skip line number
      002476 23               [ 6]  791         INC     HL              ; Point to first byte in line
      002477 AF               [ 4]  792         XOR     A               ; Looking for 00 byte
      002478 BE               [ 7]  793 FNDEND: CP      (HL)            ; Found end of line?
      002479 23               [ 6]  794         INC     HL              ; Move to next byte
      00247A C2 78 24         [10]  795         JP      NZ,FNDEND       ; No - Keep looking
      00247D EB               [ 4]  796         EX      DE,HL           ; Next line address to HL
      00247E 73               [ 7]  797         LD      (HL),E          ; Save LSB of pointer
      00247F 23               [ 6]  798         INC     HL
      002480 72               [ 7]  799         LD      (HL),D          ; Save MSB of pointer
      002481 C3 6C 24         [10]  800         JP      PTRLP           ; Do next line
                                    801 
      002484 2A 5E 42         [16]  802 SRCHLN: LD      HL,(BASTXT)     ; Start of program text
      002487 44               [ 4]  803 SRCHLP: LD      B,H             ; BC = Address to look at
      002488 4D               [ 4]  804         LD      C,L
      002489 7E               [ 7]  805         LD      A,(HL)          ; Get address of next line
      00248A 23               [ 6]  806         INC     HL
      00248B B6               [ 7]  807         OR      (HL)            ; End of program found?
      00248C 2B               [ 6]  808         DEC     HL
      00248D C8               [11]  809         RET     Z               ; Yes - Line not found
      00248E 23               [ 6]  810         INC     HL
      00248F 23               [ 6]  811         INC     HL
      002490 7E               [ 7]  812         LD      A,(HL)          ; Get LSB of line number
      002491 23               [ 6]  813         INC     HL
      002492 66               [ 7]  814         LD      H,(HL)          ; Get MSB of line number
      002493 6F               [ 4]  815         LD      L,A
      002494 CD 60 26         [17]  816         CALL    CPDEHL          ; Compare with line in DE
      002497 60               [ 4]  817         LD      H,B             ; HL = Start of this line
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 16.
Hexadecimal [24-Bits]



      002498 69               [ 4]  818         LD      L,C
      002499 7E               [ 7]  819         LD      A,(HL)          ; Get LSB of next line address
      00249A 23               [ 6]  820         INC     HL
      00249B 66               [ 7]  821         LD      H,(HL)          ; Get MSB of next line address
      00249C 6F               [ 4]  822         LD      L,A             ; Next line to HL
      00249D 3F               [ 4]  823         CCF
      00249E C8               [11]  824         RET     Z               ; Lines found - Exit
      00249F 3F               [ 4]  825         CCF
      0024A0 D0               [11]  826         RET     NC              ; Line not found,at line after
      0024A1 C3 87 24         [10]  827         JP      SRCHLP          ; Keep looking
                                    828 
      0024A4 C0               [11]  829 NEW:    RET     NZ              ; Return if any more on line
      0024A5 2A 5E 42         [16]  830 CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
      0024A8 AF               [ 4]  831         XOR     A               ; Set program area to empty
      0024A9 77               [ 7]  832         LD      (HL),A          ; Save LSB = 00
      0024AA 23               [ 6]  833         INC     HL
      0024AB 77               [ 7]  834         LD      (HL),A          ; Save MSB = 00
      0024AC 23               [ 6]  835         INC     HL
      0024AD 22 D6 42         [16]  836         LD      (PROGND),HL     ; Set program end
                                    837 
      0024B0 2A 5E 42         [16]  838 RUNFST: LD      HL,(BASTXT)     ; Clear all variables
      0024B3 2B               [ 6]  839         DEC     HL
                                    840 
      0024B4 22 CE 42         [16]  841 INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
      0024B7 2A AF 42         [16]  842         LD      HL,(LSTRAM)     ; Get end of RAM
      0024BA 22 C3 42         [16]  843         LD      (STRBOT),HL     ; Clear string space
      0024BD AF               [ 4]  844         XOR     A
      0024BE CD 00 28         [17]  845         CALL    RESTOR          ; Reset DATA pointers
      0024C1 2A D6 42         [16]  846         LD      HL,(PROGND)     ; Get end of program
      0024C4 22 D8 42         [16]  847         LD      (VAREND),HL     ; Clear variables
      0024C7 22 DA 42         [16]  848         LD      (ARREND),HL     ; Clear arrays
                                    849 
      0024CA C1               [10]  850 CLREG:  POP     BC              ; Save return address
      0024CB 2A 5A 42         [16]  851         LD      HL,(STRSPC)     ; Get end of working RAN
      0024CE F9               [ 6]  852         LD      SP,HL           ; Set stack
      0024CF 21 B3 42         [10]  853         LD      HL,#TMSTPL      ; Temporary string pool
      0024D2 22 B1 42         [16]  854         LD      (TMSTPT),HL     ; Reset temporary string ptr
      0024D5 AF               [ 4]  855         XOR     A               ; A = 00
      0024D6 6F               [ 4]  856         LD      L,A             ; HL = 0000
      0024D7 67               [ 4]  857         LD      H,A
      0024D8 22 D4 42         [16]  858         LD      (CONTAD),HL     ; No CONTinue
      0024DB 32 CB 42         [13]  859         LD      (FORFLG),A      ; Clear FOR flag
      0024DE 22 DE 42         [16]  860         LD      (FNRGNM),HL     ; Clear FN argument
      0024E1 E5               [11]  861         PUSH    HL              ; HL = 0000
      0024E2 C5               [11]  862         PUSH    BC              ; Put back return
      0024E3 2A CE 42         [16]  863 DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
      0024E6 C9               [10]  864         RET                     ; Return to execution driver
                                    865 
      0024E7 3E 3F            [ 7]  866 PROMPT: LD      A,#'?'          ; '?'
      0024E9 CD 71 26         [17]  867         CALL    OUTC            ; Output character
      0024EC 3E 20            [ 7]  868         LD      A,#' '          ; Space
      0024EE CD 71 26         [17]  869         CALL    OUTC            ; Output character
      0024F1 C3 4E 42         [10]  870         JP      RINPUT          ; Get input line
                                    871 
      0024F4 AF               [ 4]  872 CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 17.
Hexadecimal [24-Bits]



      0024F5 32 AE 42         [13]  873         LD      (DATFLG),A      ; Reset literal flag
      0024F8 0E 05            [ 7]  874         LD      C,#2+3          ; 2 byte number and 3 nulls
      0024FA 11 61 42         [10]  875         LD      DE,#BUFFER      ; Start of input buffer
      0024FD 7E               [ 7]  876 CRNCLP: LD      A,(HL)          ; Get byte
      0024FE FE 20            [ 7]  877         CP      #' '            ; Is it a space?
      002500 CA 7C 25         [10]  878         JP      Z,MOVDIR        ; Yes - Copy direct
      002503 47               [ 4]  879         LD      B,A             ; Save character
      002504 FE 22            [ 7]  880         CP      #'"'            ; Is it a quote?
      002506 CA 9C 25         [10]  881         JP      Z,CPYLIT        ; Yes - Copy literal string
      002509 B7               [ 4]  882         OR      A               ; Is it end of buffer?
      00250A CA A3 25         [10]  883         JP      Z,ENDBUF        ; Yes - End buffer
      00250D 3A AE 42         [13]  884         LD      A,(DATFLG)      ; Get data type
      002510 B7               [ 4]  885         OR      A               ; Literal?
      002511 7E               [ 7]  886         LD      A,(HL)          ; Get byte to copy
      002512 C2 7C 25         [10]  887         JP      NZ,MOVDIR       ; Literal - Copy direct
      002515 FE 3F            [ 7]  888         CP      #'?'            ; Is it '?' short for PRINT
      002517 3E 9E            [ 7]  889         LD      A,#ZPRINT       ; "PRINT" token
      002519 CA 7C 25         [10]  890         JP      Z,MOVDIR        ; Yes - replace it
      00251C 7E               [ 7]  891         LD      A,(HL)          ; Get byte again
      00251D FE 30            [ 7]  892         CP      #'0'            ; Is it less than '0'
      00251F DA 27 25         [10]  893         JP      C,FNDWRD        ; Yes - Look for reserved words
      002522 FE 3C            [ 7]  894         CP      #60; ";"+1      ; Is it "0123456789:;" ?
      002524 DA 7C 25         [10]  895         JP      C,MOVDIR        ; Yes - copy it direct
      002527 D5               [11]  896 FNDWRD: PUSH    DE              ; Look for reserved words
      002528 11 35 21         [10]  897         LD      DE,#WORDS-1     ; Point to table
      00252B C5               [11]  898         PUSH    BC              ; Save count
      00252C 01 78 25         [10]  899         LD      BC,#RETNAD      ; Where to return to
      00252F C5               [11]  900         PUSH    BC              ; Save return address
      002530 06 7F            [ 7]  901         LD      B,#ZEND-1       ; First token value -1
      002532 7E               [ 7]  902         LD      A,(HL)          ; Get byte
      002533 FE 61            [ 7]  903         CP      #'a'            ; Less than 'a' ?
      002535 DA 40 25         [10]  904         JP      C,SEARCH        ; Yes - search for words
      002538 FE 7B            [ 7]  905         CP      #'z'+1          ; Greater than 'z' ?
      00253A D2 40 25         [10]  906         JP      NC,SEARCH       ; Yes - search for words
      00253D E6 5F            [ 7]  907         AND     #0b01011111     ; Force upper case
      00253F 77               [ 7]  908         LD      (HL),A          ; Replace byte
      002540 4E               [ 7]  909 SEARCH: LD      C,(HL)          ; Search for a word
      002541 EB               [ 4]  910         EX      DE,HL
      002542 23               [ 6]  911 GETNXT: INC     HL              ; Get next reserved word
      002543 B6               [ 7]  912         OR      (HL)            ; Start of word?
      002544 F2 42 25         [10]  913         JP      P,GETNXT        ; No - move on
      002547 04               [ 4]  914         INC     B               ; Increment token value
      002548 7E               [ 7]  915         LD      A, (HL)         ; Get byte from table
      002549 E6 7F            [ 7]  916         AND     #0b01111111     ; Strip bit 7
      00254B C8               [11]  917         RET     Z               ; Return if end of list
      00254C B9               [ 4]  918         CP      C               ; Same character as in buffer?
      00254D C2 42 25         [10]  919         JP      NZ,GETNXT       ; No - get next word
      002550 EB               [ 4]  920         EX      DE,HL
      002551 E5               [11]  921         PUSH    HL              ; Save start of word
                                    922 
      002552 13               [ 6]  923 NXTBYT: INC     DE              ; Look through rest of word
      002553 1A               [ 7]  924         LD      A,(DE)          ; Get byte from table
      002554 B7               [ 4]  925         OR      A               ; End of word ?
      002555 FA 74 25         [10]  926         JP      M,MATCH         ; Yes - Match found
      002558 4F               [ 4]  927         LD      C,A             ; Save it
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 18.
Hexadecimal [24-Bits]



      002559 78               [ 4]  928         LD      A,B             ; Get token value
      00255A FE 88            [ 7]  929         CP      #ZGOTO          ; Is it "GOTO" token ?
      00255C C2 63 25         [10]  930         JP      NZ,NOSPC        ; No - Don't allow spaces
      00255F CD F0 27         [17]  931         CALL    GETCHR          ; Get next character
      002562 2B               [ 6]  932         DEC     HL              ; Cancel increment from GETCHR
      002563 23               [ 6]  933 NOSPC:  INC     HL              ; Next byte
      002564 7E               [ 7]  934         LD      A,(HL)          ; Get byte
      002565 FE 61            [ 7]  935         CP      #'a'            ; Less than 'a' ?
      002567 DA 6C 25         [10]  936         JP      C,NOCHNG        ; Yes - don't change
      00256A E6 5F            [ 7]  937         AND     #0b01011111     ; Make upper case
      00256C B9               [ 4]  938 NOCHNG: CP      C               ; Same as in buffer ?
      00256D CA 52 25         [10]  939         JP      Z,NXTBYT        ; Yes - keep testing
      002570 E1               [10]  940         POP     HL              ; Get back start of word
      002571 C3 40 25         [10]  941         JP      SEARCH          ; Look at next word
                                    942 
      002574 48               [ 4]  943 MATCH:  LD      C,B             ; Word found - Save token value
      002575 F1               [10]  944         POP     AF              ; Throw away return
      002576 EB               [ 4]  945         EX      DE,HL
      002577 C9               [10]  946         RET                     ; Return to "RETNAD"
      002578 EB               [ 4]  947 RETNAD: EX      DE,HL           ; Get address in string
      002579 79               [ 4]  948         LD      A,C             ; Get token value
      00257A C1               [10]  949         POP     BC              ; Restore buffer length
      00257B D1               [10]  950         POP     DE              ; Get destination address
      00257C 23               [ 6]  951 MOVDIR: INC     HL              ; Next source in buffer
      00257D 12               [ 7]  952         LD      (DE),A          ; Put byte in buffer
      00257E 13               [ 6]  953         INC     DE              ; Move up buffer
      00257F 0C               [ 4]  954         INC     C               ; Increment length of buffer
      002580 D6 3A            [ 7]  955         SUB     #':'            ; End of statement?
      002582 CA 8A 25         [10]  956         JP      Z,SETLIT        ; Jump if multi-statement line
      002585 FE 49            [ 7]  957         CP      #ZDATA-0x3A     ; Is it DATA statement ?
      002587 C2 8D 25         [10]  958         JP      NZ,TSTREM       ; No - see if REM
      00258A 32 AE 42         [13]  959 SETLIT: LD      (DATFLG),A      ; Set literal flag
      00258D D6 54            [ 7]  960 TSTREM: SUB     #ZREM-0x3A      ; Is it REM?
      00258F C2 FD 24         [10]  961         JP      NZ,CRNCLP       ; No - Leave flag
      002592 47               [ 4]  962         LD      B,A             ; Copy rest of buffer
      002593 7E               [ 7]  963 NXTCHR: LD      A,(HL)          ; Get byte
      002594 B7               [ 4]  964         OR      A               ; End of line ?
      002595 CA A3 25         [10]  965         JP      Z,ENDBUF        ; Yes - Terminate buffer
      002598 B8               [ 4]  966         CP      B               ; End of statement ?
      002599 CA 7C 25         [10]  967         JP      Z,MOVDIR        ; Yes - Get next one
      00259C 23               [ 6]  968 CPYLIT: INC     HL              ; Move up source string
      00259D 12               [ 7]  969         LD      (DE),A          ; Save in destination
      00259E 0C               [ 4]  970         INC     C               ; Increment length
      00259F 13               [ 6]  971         INC     DE              ; Move up destination
      0025A0 C3 93 25         [10]  972         JP      NXTCHR          ; Repeat
                                    973 
      0025A3 21 60 42         [10]  974 ENDBUF: LD      HL,#BUFFER-1    ; Point to start of buffer
      0025A6 12               [ 7]  975         LD      (DE),A          ; Mark end of buffer (A = 00)
      0025A7 13               [ 6]  976         INC     DE
      0025A8 12               [ 7]  977         LD      (DE),A          ; A = 00
      0025A9 13               [ 6]  978         INC     DE
      0025AA 12               [ 7]  979         LD      (DE),A          ; A = 00
      0025AB C9               [10]  980         RET
                                    981 
      0025AC 3A 44 42         [13]  982 DODEL:  LD      A,(NULFLG)      ; Get null flag status
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 19.
Hexadecimal [24-Bits]



      0025AF B7               [ 4]  983         OR      A               ; Is it zero?
      0025B0 3E 00            [ 7]  984         LD      A,#0            ; Zero A - Leave flags
      0025B2 32 44 42         [13]  985         LD      (NULFLG),A      ; Zero null flag
      0025B5 C2 C0 25         [10]  986         JP      NZ,ECHDEL       ; Set - Echo it
      0025B8 05               [ 4]  987         DEC     B               ; Decrement length
      0025B9 CA DD 25         [10]  988         JP      Z,GETLIN        ; Get line again if empty
      0025BC CD 71 26         [17]  989         CALL    OUTC            ; Output null character
      0025BF 3E                     990         .BYTE   0x3E            ; Skip "DEC B"
      0025C0 05               [ 4]  991 ECHDEL: DEC     B               ; Count bytes in buffer
      0025C1 2B               [ 6]  992         DEC     HL              ; Back space buffer
      0025C2 CA D4 25         [10]  993         JP      Z,OTKLN         ; No buffer - Try again
      0025C5 7E               [ 7]  994         LD      A,(HL)          ; Get deleted byte
      0025C6 CD 71 26         [17]  995         CALL    OUTC            ; Echo it
      0025C9 C3 E6 25         [10]  996         JP      MORINP          ; Get more input
                                    997 
      0025CC 05               [ 4]  998 DELCHR: DEC     B               ; Count bytes in buffer
      0025CD 2B               [ 6]  999         DEC     HL              ; Back space buffer
      0025CE CD 71 26         [17] 1000         CALL    OUTC            ; Output character in A
      0025D1 C2 E6 25         [10] 1001         JP      NZ,MORINP       ; Not end - Get more
      0025D4 CD 71 26         [17] 1002 OTKLN:  CALL    OUTC            ; Output character in A
      0025D7 CD 98 2A         [17] 1003 KILIN:  CALL    PRNTCRLF        ; Output CRLF
      0025DA C3 DD 25         [10] 1004         JP      TTYLIN          ; Get line again
                                   1005 
      0025DD                       1006 GETLIN:
      0025DD 21 61 42         [10] 1007 TTYLIN: LD      HL,#BUFFER      ; Get a line by character
      0025E0 06 01            [ 7] 1008         LD      B,#1            ; Set buffer as empty
      0025E2 AF               [ 4] 1009         XOR     A
      0025E3 32 44 42         [13] 1010         LD      (NULFLG),A      ; Clear null flag
      0025E6 CD 9B 26         [17] 1011 MORINP: CALL    CLOTST          ; Get character and test ^O
      0025E9 4F               [ 4] 1012         LD      C,A             ; Save character in C
      0025EA FE 7F            [ 7] 1013         CP      #DEL            ; Delete character?
      0025EC CA AC 25         [10] 1014         JP      Z,DODEL         ; Yes - Process it
      0025EF 3A 44 42         [13] 1015         LD      A,(NULFLG)      ; Get null flag
      0025F2 B7               [ 4] 1016         OR      A               ; Test null flag status
      0025F3 CA FF 25         [10] 1017         JP      Z,PROCES        ; Reset - Process character
      0025F6 3E 00            [ 7] 1018         LD      A,#0            ; Set a null
      0025F8 CD 71 26         [17] 1019         CALL    OUTC            ; Output null
      0025FB AF               [ 4] 1020         XOR     A               ; Clear A
      0025FC 32 44 42         [13] 1021         LD      (NULFLG),A      ; Reset null flag
      0025FF 79               [ 4] 1022 PROCES: LD      A,C             ; Get character
      002600 FE 07            [ 7] 1023         CP      #CTRLG          ; Bell?
      002602 CA 43 26         [10] 1024         JP      Z,PUTCTL        ; Yes - Save it
      002605 FE 03            [ 7] 1025         CP      #CTRLC          ; Is it control "C"?
      002607 CC 98 2A         [17] 1026         CALL    Z,PRNTCRLF      ; Yes - Output CRLF
      00260A 37               [ 4] 1027         SCF                     ; Flag break
      00260B C8               [11] 1028         RET     Z               ; Return if control "C"
      00260C FE 0D            [ 7] 1029         CP      #CR             ; Is it enter?
      00260E CA 93 2A         [10] 1030         JP      Z,ENDINP        ; Yes - Terminate input
      002611 FE 15            [ 7] 1031         CP      #CTRLU          ; Is it control "U"?
      002613 CA D7 25         [10] 1032         JP      Z,KILIN         ; Yes - Get another line
      002616 FE 40            [ 7] 1033         CP      #'@'            ; Is it "kill line"?
      002618 CA D4 25         [10] 1034         JP      Z,OTKLN         ; Yes - Kill line
      00261B FE 5F            [ 7] 1035         CP      #'_'            ; Is it delete?
      00261D CA CC 25         [10] 1036         JP      Z,DELCHR        ; Yes - Delete character
      002620 FE 08            [ 7] 1037         CP      #BKSP           ; Is it backspace?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 20.
Hexadecimal [24-Bits]



      002622 CA CC 25         [10] 1038         JP      Z,DELCHR        ; Yes - Delete character
      002625 FE 12            [ 7] 1039         CP      #CTRLR          ; Is it control "R"?
      002627 C2 3E 26         [10] 1040         JP      NZ,PUTBUF       ; No - Put in buffer
      00262A C5               [11] 1041         PUSH    BC              ; Save buffer length
      00262B D5               [11] 1042         PUSH    DE              ; Save DE
      00262C E5               [11] 1043         PUSH    HL              ; Save buffer address
      00262D 36 00            [10] 1044         LD      (HL),#0         ; Mark end of buffer
      00262F CD 49 3C         [17] 1045         CALL    OUTNCR          ; Output and do CRLF
      002632 21 61 42         [10] 1046         LD      HL,#BUFFER      ; Point to buffer start
      002635 CD 36 31         [17] 1047         CALL    PRS             ; Output buffer
      002638 E1               [10] 1048         POP     HL              ; Restore buffer address
      002639 D1               [10] 1049         POP     DE              ; Restore DE
      00263A C1               [10] 1050         POP     BC              ; Restore buffer length
      00263B C3 E6 25         [10] 1051         JP      MORINP          ; Get another character
                                   1052 
      00263E FE 20            [ 7] 1053 PUTBUF: CP      #' '            ; Is it a control code?
      002640 DA E6 25         [10] 1054         JP      C,MORINP        ; Yes - Ignore
      002643 78               [ 4] 1055 PUTCTL: LD      A,B             ; Get number of bytes in buffer
      002644 FE 49            [ 7] 1056         CP      #72+1           ; Test for line overflow
      002646 3E 07            [ 7] 1057         LD      A,#CTRLG        ; Set a bell
      002648 D2 58 26         [10] 1058         JP      NC,OUTNBS       ; Ring bell if buffer full
      00264B 79               [ 4] 1059         LD      A,C             ; Get character
      00264C 71               [ 7] 1060         LD      (HL),C          ; Save in buffer
      00264D 32 CC 42         [13] 1061         LD      (LSTBIN),A      ; Save last input byte
      002650 23               [ 6] 1062         INC     HL              ; Move up buffer
      002651 04               [ 4] 1063         INC     B               ; Increment length
      002652 CD 71 26         [17] 1064 OUTIT:  CALL    OUTC            ; Output the character entered
      002655 C3 E6 25         [10] 1065         JP      MORINP          ; Get another character
                                   1066 
      002658 CD 71 26         [17] 1067 OUTNBS: CALL    OUTC            ; Output bell and back over it
      00265B 3E 08            [ 7] 1068         LD      A,#BKSP         ; Set back space
      00265D C3 52 26         [10] 1069         JP      OUTIT           ; Output it and get more
                                   1070 
      002660 7C               [ 4] 1071 CPDEHL: LD      A,H             ; Get H
      002661 92               [ 4] 1072         SUB     D               ; Compare with D
      002662 C0               [11] 1073         RET     NZ              ; Different - Exit
      002663 7D               [ 4] 1074         LD      A,L             ; Get L
      002664 93               [ 4] 1075         SUB     E               ; Compare with E
      002665 C9               [10] 1076         RET                     ; Return status
                                   1077 
      002666 7E               [ 7] 1078 CHKSYN: LD      A,(HL)          ; Check syntax of character
      002667 E3               [19] 1079         EX      (SP),HL         ; Address of test byte
      002668 BE               [ 7] 1080         CP      (HL)            ; Same as in code string?
      002669 23               [ 6] 1081         INC     HL              ; Return address
      00266A E3               [19] 1082         EX      (SP),HL         ; Put it back
      00266B CA F0 27         [10] 1083         JP      Z,GETCHR        ; Yes - Get next character
      00266E C3 98 23         [10] 1084         JP      SNERR           ; Different - ?SN Error
                                   1085 
      002671 F5               [11] 1086 OUTC:   PUSH    AF              ; Save character
      002672 3A 45 42         [13] 1087         LD      A,(CTLOFG)      ; Get control "O" flag
      002675 B7               [ 4] 1088         OR      A               ; Is it set?
      002676 C2 6B 31         [10] 1089         JP      NZ,POPAF        ; Yes - don't output
      002679 F1               [10] 1090         POP     AF              ; Restore character
      00267A C5               [11] 1091         PUSH    BC              ; Save buffer length
      00267B F5               [11] 1092         PUSH    AF              ; Save character
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 21.
Hexadecimal [24-Bits]



      00267C FE 20            [ 7] 1093         CP      #' '            ; Is it a control code?
      00267E DA 95 26         [10] 1094         JP      C,DINPOS        ; Yes - Don't INC POS(X)
      002681 3A 42 42         [13] 1095         LD      A,(LWIDTH)      ; Get line width
      002684 47               [ 4] 1096         LD      B,A             ; To B
      002685 3A AB 42         [13] 1097         LD      A,(CURPOS)      ; Get cursor position
      002688 04               [ 4] 1098         INC     B               ; Width 255?
      002689 CA 91 26         [10] 1099         JP      Z,INCLEN        ; Yes - No width limit
      00268C 05               [ 4] 1100         DEC     B               ; Restore width
      00268D B8               [ 4] 1101         CP      B               ; At end of line?
      00268E CC 98 2A         [17] 1102         CALL    Z,PRNTCRLF      ; Yes - output CRLF
      002691 3C               [ 4] 1103 INCLEN: INC     A               ; Move on one character
      002692 32 AB 42         [13] 1104         LD      (CURPOS),A      ; Save new position
      002695 F1               [10] 1105 DINPOS: POP     AF              ; Restore character
      002696 C1               [10] 1106         POP     BC              ; Restore buffer length
      002697 CD 31 3C         [17] 1107         CALL    MONOUT          ; Send it
      00269A C9               [10] 1108         RET
                                   1109 
      00269B CD F5 3A         [17] 1110 CLOTST: CALL    GETINP          ; Get input character
      00269E E6 7F            [ 7] 1111         AND     #0b01111111     ; Strip bit 7
      0026A0 FE 0F            [ 7] 1112         CP      #CTRLO          ; Is it control "O"?
      0026A2 C0               [11] 1113         RET     NZ              ; No don't flip flag
      0026A3 3A 45 42         [13] 1114         LD      A,(CTLOFG)      ; Get flag
      0026A6 2F               [ 4] 1115         CPL                     ; Flip it
      0026A7 32 45 42         [13] 1116         LD      (CTLOFG),A      ; Put it back
      0026AA AF               [ 4] 1117         XOR     A               ; Null character
      0026AB C9               [10] 1118         RET
                                   1119 
      0026AC CD BC 28         [17] 1120 LIST:   CALL    ATOH            ; ASCII number to DE
      0026AF C0               [11] 1121         RET     NZ              ; Return if anything extra
      0026B0 C1               [10] 1122         POP     BC              ; Rubbish - Not needed
      0026B1 CD 84 24         [17] 1123         CALL    SRCHLN          ; Search for line number in DE
      0026B4 C5               [11] 1124         PUSH    BC              ; Save address of line
      0026B5 CD 02 27         [17] 1125         CALL    SETLIN          ; Set up lines counter
      0026B8 E1               [10] 1126 LISTLP: POP     HL              ; Restore address of line
      0026B9 4E               [ 7] 1127         LD      C,(HL)          ; Get LSB of next line
      0026BA 23               [ 6] 1128         INC     HL
      0026BB 46               [ 7] 1129         LD      B,(HL)          ; Get MSB of next line
      0026BC 23               [ 6] 1130         INC     HL
      0026BD 78               [ 4] 1131         LD      A,B             ; BC = 0 (End of program)?
      0026BE B1               [ 4] 1132         OR      C
      0026BF CA E3 23         [10] 1133         JP      Z,PRNTOK        ; Yes - Go to command mode
      0026C2 CD 0B 27         [17] 1134         CALL    COUNT           ; Count lines
      0026C5 CD 1B 28         [17] 1135         CALL    TSTBRK          ; Test for break key
      0026C8 C5               [11] 1136         PUSH    BC              ; Save address of next line
      0026C9 CD 98 2A         [17] 1137         CALL    PRNTCRLF        ; Output CRLF
      0026CC 5E               [ 7] 1138         LD      E,(HL)          ; Get LSB of line number
      0026CD 23               [ 6] 1139         INC     HL
      0026CE 56               [ 7] 1140         LD      D,(HL)          ; Get MSB of line number
      0026CF 23               [ 6] 1141         INC     HL
      0026D0 E5               [11] 1142         PUSH    HL              ; Save address of line start
      0026D1 EB               [ 4] 1143         EX      DE,HL           ; Line number to HL
      0026D2 CD D9 37         [17] 1144         CALL    PRNTHL          ; Output line number in decimal
      0026D5 3E 20            [ 7] 1145         LD      A,#' '          ; Space after line number
      0026D7 E1               [10] 1146         POP     HL              ; Restore start of line address
      0026D8 CD 71 26         [17] 1147 LSTLP2: CALL    OUTC            ; Output character in A
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 22.
Hexadecimal [24-Bits]



      0026DB 7E               [ 7] 1148 LSTLP3: LD      A,(HL)          ; Get next byte in line
      0026DC B7               [ 4] 1149         OR      A               ; End of line?
      0026DD 23               [ 6] 1150         INC     HL              ; To next byte in line
      0026DE CA B8 26         [10] 1151         JP      Z,LISTLP        ; Yes - get next line
      0026E1 F2 D8 26         [10] 1152         JP      P,LSTLP2        ; No token - output it
      0026E4 D6 7F            [ 7] 1153         SUB     #ZEND-1         ; Find and output word
      0026E6 4F               [ 4] 1154         LD      C,A             ; Token offset+1 to C
      0026E7 11 36 21         [10] 1155         LD      DE,#WORDS       ; Reserved word list
      0026EA 1A               [ 7] 1156 FNDTOK: LD      A,(DE)          ; Get character in list
      0026EB 13               [ 6] 1157         INC     DE              ; Move on to next
      0026EC B7               [ 4] 1158         OR      A               ; Is it start of word?
      0026ED F2 EA 26         [10] 1159         JP      P,FNDTOK        ; No - Keep looking for word
      0026F0 0D               [ 4] 1160         DEC     C               ; Count words
      0026F1 C2 EA 26         [10] 1161         JP      NZ,FNDTOK       ; Not there - keep looking
      0026F4 E6 7F            [ 7] 1162 OUTWRD: AND     #0b01111111     ; Strip bit 7
      0026F6 CD 71 26         [17] 1163         CALL    OUTC            ; Output first character
      0026F9 1A               [ 7] 1164         LD      A,(DE)          ; Get next character
      0026FA 13               [ 6] 1165         INC     DE              ; Move on to next
      0026FB B7               [ 4] 1166         OR      A               ; Is it end of word?
      0026FC F2 F4 26         [10] 1167         JP      P,OUTWRD        ; No - output the rest
      0026FF C3 DB 26         [10] 1168         JP      LSTLP3          ; Next byte in line
                                   1169 
      002702 E5               [11] 1170 SETLIN: PUSH    HL              ; Set up LINES counter
      002703 2A 48 42         [16] 1171         LD      HL,(LINESN)     ; Get LINES number
      002706 22 46 42         [16] 1172         LD      (LINESC),HL     ; Save in LINES counter
      002709 E1               [10] 1173         POP     HL
      00270A C9               [10] 1174         RET
                                   1175 
      00270B E5               [11] 1176 COUNT:  PUSH    HL              ; Save code string address
      00270C D5               [11] 1177         PUSH    DE
      00270D 2A 46 42         [16] 1178         LD      HL,(LINESC)     ; Get LINES counter
      002710 11 FF FF         [10] 1179         LD      DE,#-1
      002713 ED 5A            [15] 1180         ADC     HL,DE           ; Decrement
      002715 22 46 42         [16] 1181         LD      (LINESC),HL     ; Put it back
      002718 D1               [10] 1182         POP     DE
      002719 E1               [10] 1183         POP     HL              ; Restore code string address
      00271A F0               [11] 1184         RET     P               ; Return if more lines to go
      00271B E5               [11] 1185         PUSH    HL              ; Save code string address
      00271C 2A 48 42         [16] 1186         LD      HL,(LINESN)     ; Get LINES number
      00271F 22 46 42         [16] 1187         LD      (LINESC),HL     ; Reset LINES counter
      002722 CD F5 3A         [17] 1188         CALL    GETINP          ; Get input character
      002725 FE 03            [ 7] 1189         CP      #CTRLC          ; Is it control "C"?
      002727 CA 2E 27         [10] 1190         JP      Z,RSLNBK        ; Yes - Reset LINES and break
      00272A E1               [10] 1191         POP     HL              ; Restore code string address
      00272B C3 0B 27         [10] 1192         JP      COUNT           ; Keep on counting
                                   1193 
      00272E 2A 48 42         [16] 1194 RSLNBK: LD      HL,(LINESN)     ; Get LINES number
      002731 22 46 42         [16] 1195         LD      (LINESC),HL     ; Reset LINES counter
      002734 C3 A7 20         [10] 1196         JP      BRKRET          ; Go and output "Break"
                                   1197 
      002737 3E 64            [ 7] 1198 FOR:    LD      A,#0x64          ; Flag "FOR" assignment
      002739 32 CB 42         [13] 1199         LD      (FORFLG),A      ; Save "FOR" flag
      00273C CD 9E 29         [17] 1200         CALL    LET             ; Set up initial index
      00273F C1               [10] 1201         POP     BC              ; Drop RETurn address
      002740 E5               [11] 1202         PUSH    HL              ; Save code string address
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 23.
Hexadecimal [24-Bits]



      002741 CD 87 29         [17] 1203         CALL    DATA            ; Get next statement address
      002744 22 C7 42         [16] 1204         LD      (LOOPST),HL     ; Save it for start of loop
      002747 21 02 00         [10] 1205         LD      HL,#2           ; Offset for "FOR" block
      00274A 39               [11] 1206         ADD     HL,SP           ; Point to it
      00274B CD 45 23         [17] 1207 FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
      00274E D1               [10] 1208         POP     DE              ; Get code string address
      00274F C2 67 27         [10] 1209         JP      NZ,FORFND       ; No nesting found
      002752 09               [11] 1210         ADD     HL,BC           ; Move into "FOR" block
      002753 D5               [11] 1211         PUSH    DE              ; Save code string address
      002754 2B               [ 6] 1212         DEC     HL
      002755 56               [ 7] 1213         LD      D,(HL)          ; Get MSB of loop statement
      002756 2B               [ 6] 1214         DEC     HL
      002757 5E               [ 7] 1215         LD      E,(HL)          ; Get LSB of loop statement
      002758 23               [ 6] 1216         INC     HL
      002759 23               [ 6] 1217         INC     HL
      00275A E5               [11] 1218         PUSH    HL              ; Save block address
      00275B 2A C7 42         [16] 1219         LD      HL,(LOOPST)     ; Get address of loop statement
      00275E CD 60 26         [17] 1220         CALL    CPDEHL          ; Compare the FOR loops
      002761 E1               [10] 1221         POP     HL              ; Restore block address
      002762 C2 4B 27         [10] 1222         JP      NZ,FORSLP       ; Different FORs - Find another
      002765 D1               [10] 1223         POP     DE              ; Restore code string address
      002766 F9               [ 6] 1224         LD      SP,HL           ; Remove all nested loops
                                   1225 
      002767 EB               [ 4] 1226 FORFND: EX      DE,HL           ; Code string address to HL
      002768 0E 08            [ 7] 1227         LD      C,#8
      00276A CD 75 23         [17] 1228         CALL    CHKSTK          ; Check for 8 levels of stack
      00276D E5               [11] 1229         PUSH    HL              ; Save code string address
      00276E 2A C7 42         [16] 1230         LD      HL,(LOOPST)     ; Get first statement of loop
      002771 E3               [19] 1231         EX      (SP),HL         ; Save and restore code string
      002772 E5               [11] 1232         PUSH    HL              ; Re-save code string address
      002773 2A 5C 42         [16] 1233         LD      HL,(LINEAT)     ; Get current line number
      002776 E3               [19] 1234         EX      (SP),HL         ; Save and restore code string
      002777 CD 60 2C         [17] 1235         CALL    TSTNUM          ; Make sure it's a number
      00277A CD 66 26         [17] 1236         CALL    CHKSYN          ; Make sure "TO" is next
      00277D A6                    1237         .BYTE   ZTO          ; "TO" token
      00277E CD 5D 2C         [17] 1238         CALL    GETNUM          ; Get "TO" expression value
      002781 E5               [11] 1239         PUSH    HL              ; Save code string address
      002782 CD 8B 36         [17] 1240         CALL    BCDEFP          ; Move "TO" value to BCDE
      002785 E1               [10] 1241         POP     HL              ; Restore code string address
      002786 C5               [11] 1242         PUSH    BC              ; Save "TO" value in block
      002787 D5               [11] 1243         PUSH    DE
      002788 01 00 81         [10] 1244         LD      BC,#0x8100      ; BCDE - 1 (default STEP)
      00278B 51               [ 4] 1245         LD      D,C             ; C=0
      00278C 5A               [ 4] 1246         LD      E,D             ; D=0
      00278D 7E               [ 7] 1247         LD      A,(HL)          ; Get next byte in code string
      00278E FE AB            [ 7] 1248         CP      #ZSTEP          ; See if "STEP" is stated
      002790 3E 01            [ 7] 1249         LD      A,#1            ; Sign of step = 1
      002792 C2 A3 27         [10] 1250         JP      NZ,SAVSTP       ; No STEP given - Default to 1
      002795 CD F0 27         [17] 1251         CALL    GETCHR          ; Jump over "STEP" token
      002798 CD 5D 2C         [17] 1252         CALL    GETNUM          ; Get step value
      00279B E5               [11] 1253         PUSH    HL              ; Save code string address
      00279C CD 8B 36         [17] 1254         CALL    BCDEFP          ; Move STEP to BCDE
      00279F CD 3F 36         [17] 1255         CALL    TSTSGN          ; Test sign of FPREG
      0027A2 E1               [10] 1256         POP     HL              ; Restore code string address
      0027A3 C5               [11] 1257 SAVSTP: PUSH    BC              ; Save the STEP value in block
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 24.
Hexadecimal [24-Bits]



      0027A4 D5               [11] 1258         PUSH    DE
      0027A5 F5               [11] 1259         PUSH    AF              ; Save sign of STEP
      0027A6 33               [ 6] 1260         INC     SP              ; Don't save flags
      0027A7 E5               [11] 1261         PUSH    HL              ; Save code string address
      0027A8 2A CE 42         [16] 1262         LD      HL,(BRKLIN)     ; Get address of index variable
      0027AB E3               [19] 1263         EX      (SP),HL         ; Save and restore code string
      0027AC 06 81            [ 7] 1264 PUTFID: LD      B,#ZFOR         ; "FOR" block marker
      0027AE C5               [11] 1265         PUSH    BC              ; Save it
      0027AF 33               [ 6] 1266         INC     SP              ; Don't save C
                                   1267 
      0027B0 CD 1B 28         [17] 1268 RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
      0027B3 22 CE 42         [16] 1269         LD      (BRKLIN),HL     ; Save code address for break
      0027B6 7E               [ 7] 1270         LD      A,(HL)          ; Get next byte in code string
      0027B7 FE 3A            [ 7] 1271         CP      #':'            ; Multi statement line?
      0027B9 CA D0 27         [10] 1272         JP      Z,EXCUTE        ; Yes - Execute it
      0027BC B7               [ 4] 1273         OR      A               ; End of line?
      0027BD C2 98 23         [10] 1274         JP      NZ,SNERR        ; No - Syntax error
      0027C0 23               [ 6] 1275         INC     HL              ; Point to address of next line
      0027C1 7E               [ 7] 1276         LD      A,(HL)          ; Get LSB of line pointer
      0027C2 23               [ 6] 1277         INC     HL
      0027C3 B6               [ 7] 1278         OR      (HL)            ; Is it zero (End of prog)?
      0027C4 CA 42 28         [10] 1279         JP      Z,ENDPRG        ; Yes - Terminate execution
      0027C7 23               [ 6] 1280         INC     HL              ; Point to line number
      0027C8 5E               [ 7] 1281         LD      E,(HL)          ; Get LSB of line number
      0027C9 23               [ 6] 1282         INC     HL
      0027CA 56               [ 7] 1283         LD      D,(HL)          ; Get MSB of line number
      0027CB EB               [ 4] 1284         EX      DE,HL           ; Line number to HL
      0027CC 22 5C 42         [16] 1285         LD      (LINEAT),HL     ; Save as current line number
      0027CF EB               [ 4] 1286         EX      DE,HL           ; Line number back to DE
      0027D0 CD F0 27         [17] 1287 EXCUTE: CALL    GETCHR          ; Get key word
      0027D3 11 B0 27         [10] 1288         LD      DE,#RUNCNT      ; Where to RETurn to
      0027D6 D5               [11] 1289         PUSH    DE              ; Save for RETurn
      0027D7 C8               [11] 1290 IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
      0027D8 D6 80            [ 7] 1291 ONJMP:  SUB     #ZEND           ; Is it a token?
      0027DA DA 9E 29         [10] 1292         JP      C,LET           ; No - try to assign it
      0027DD FE 25            [ 7] 1293         CP      #ZNEW+1-ZEND    ; END to NEW ?
      0027DF D2 98 23         [10] 1294         JP      NC,SNERR        ; Not a key word - ?SN Error
      0027E2 07               [ 4] 1295         RLCA                    ; Double it
      0027E3 4F               [ 4] 1296         LD      C,A             ; BC = Offset into table
      0027E4 06 00            [ 7] 1297         LD      B,#0
      0027E6 EB               [ 4] 1298         EX      DE,HL           ; Save code string address
      0027E7 21 55 22         [10] 1299         LD      HL,#WORDTB      ; Keyword address table
      0027EA 09               [11] 1300         ADD     HL,BC           ; Point to routine address
      0027EB 4E               [ 7] 1301         LD      C,(HL)          ; Get LSB of routine address
      0027EC 23               [ 6] 1302         INC     HL
      0027ED 46               [ 7] 1303         LD      B,(HL)          ; Get MSB of routine address
      0027EE C5               [11] 1304         PUSH    BC              ; Save routine address
      0027EF EB               [ 4] 1305         EX      DE,HL           ; Restore code string address
                                   1306 
      0027F0 23               [ 6] 1307 GETCHR: INC     HL              ; Point to next character
      0027F1 7E               [ 7] 1308         LD      A,(HL)          ; Get next code string byte
      0027F2 FE 3A            [ 7] 1309         CP      #':'            ; Z if ':'
      0027F4 D0               [11] 1310         RET     NC              ; NC if > "9"
      0027F5 FE 20            [ 7] 1311         CP      #' '
      0027F7 CA F0 27         [10] 1312         JP      Z,GETCHR        ; Skip over spaces
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 25.
Hexadecimal [24-Bits]



      0027FA FE 30            [ 7] 1313         CP      #'0'
      0027FC 3F               [ 4] 1314         CCF                     ; NC if < '0'
      0027FD 3C               [ 4] 1315         INC     A               ; Test for zero - Leave carry
      0027FE 3D               [ 4] 1316         DEC     A               ; Z if Null
      0027FF C9               [10] 1317         RET
                                   1318 
      002800 EB               [ 4] 1319 RESTOR: EX      DE,HL           ; Save code string address
      002801 2A 5E 42         [16] 1320         LD      HL,(BASTXT)     ; Point to start of program
      002804 CA 15 28         [10] 1321         JP      Z,RESTNL        ; Just RESTORE - reset pointer
      002807 EB               [ 4] 1322         EX      DE,HL           ; Restore code string address
      002808 CD BC 28         [17] 1323         CALL    ATOH            ; Get line number to DE
      00280B E5               [11] 1324         PUSH    HL              ; Save code string address
      00280C CD 84 24         [17] 1325         CALL    SRCHLN          ; Search for line number in DE
      00280F 60               [ 4] 1326         LD      H,B             ; HL = Address of line
      002810 69               [ 4] 1327         LD      L,C
      002811 D1               [10] 1328         POP     DE              ; Restore code string address
      002812 D2 5D 29         [10] 1329         JP      NC,ULERR        ; ?UL Error if not found
      002815 2B               [ 6] 1330 RESTNL: DEC     HL              ; Byte before DATA statement
      002816 22 DC 42         [16] 1331 UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
      002819 EB               [ 4] 1332         EX      DE,HL           ; Restore code string address
      00281A C9               [10] 1333         RET
                                   1334 
                                   1335 
      00281B DF               [11] 1336 TSTBRK: RST     0x18            ; Check input status
      00281C C8               [11] 1337         RET     Z               ; No key, go back
      00281D D7               [11] 1338         RST     0x10            ; Get the key into A
      00281E FE 1B            [ 7] 1339         CP      #ESC            ; Escape key?
      002820 28 11            [12] 1340         JR      Z,BRK           ; Yes, break
      002822 FE 03            [ 7] 1341         CP      #CTRLC          ; <Ctrl-C>
      002824 28 0D            [12] 1342         JR      Z,BRK           ; Yes, break
      002826 FE 13            [ 7] 1343         CP      #CTRLS          ; Stop scrolling?
      002828 C0               [11] 1344         RET     NZ              ; Other key, ignore
                                   1345 
                                   1346 
      002829 D7               [11] 1347 STALL:  RST     0x10            ; Wait for key
      00282A FE 11            [ 7] 1348         CP      #CTRLQ          ; Resume scrolling?
      00282C C8               [11] 1349         RET     Z               ; Release the chokehold
      00282D FE 03            [ 7] 1350         CP      #CTRLC          ; Second break?
      00282F 28 07            [12] 1351         JR      Z,STOP          ; Break during hold exits prog
      002831 18 F6            [12] 1352         JR      STALL           ; Loop until <Ctrl-Q> or <brk>
                                   1353 
      002833 3E FF            [ 7] 1354 BRK:    LD      A,#0xFF         ; Set BRKFLG
      002835 32 4D 42         [13] 1355         LD      (BRKFLG),A      ; Store it
                                   1356 
                                   1357 
      002838 C0               [11] 1358 STOP:   RET     NZ              ; Exit if anything else
      002839 F6                    1359         .BYTE   0xF6            ; Flag "STOP"
      00283A C0               [11] 1360 PEND:   RET     NZ              ; Exit if anything else
      00283B 22 CE 42         [16] 1361         LD      (BRKLIN),HL     ; Save point of break
      00283E 21                    1362         .BYTE   0x21            ; Skip "OR 11111111B"
      00283F F6 FF            [ 7] 1363 INPBRK: OR      #0b11111111     ; Flag "Break" wanted
      002841 C1               [10] 1364         POP     BC              ; Return not needed and more
      002842 2A 5C 42         [16] 1365 ENDPRG: LD      HL,(LINEAT)     ; Get current line number
      002845 F5               [11] 1366         PUSH    AF              ; Save STOP / END status
      002846 7D               [ 4] 1367         LD      A,L             ; Is it direct break?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 26.
Hexadecimal [24-Bits]



      002847 A4               [ 4] 1368         AND     H
      002848 3C               [ 4] 1369         INC     A               ; Line is -1 if direct break
      002849 CA 55 28         [10] 1370         JP      Z,NOLIN         ; Yes - No line number
      00284C 22 D2 42         [16] 1371         LD      (ERRLIN),HL     ; Save line of break
      00284F 2A CE 42         [16] 1372         LD      HL,(BRKLIN)     ; Get point of break
      002852 22 D4 42         [16] 1373         LD      (CONTAD),HL     ; Save point to CONTinue
      002855 AF               [ 4] 1374 NOLIN:  XOR     A
      002856 32 45 42         [13] 1375         LD      (CTLOFG),A      ; Enable output
      002859 CD 8B 2A         [17] 1376         CALL    STTLIN          ; Start a new line
      00285C F1               [10] 1377         POP     AF              ; Restore STOP / END status
      00285D 21 3B 23         [10] 1378         LD      HL,#BRKMSG      ; "Break" message
      002860 C2 CC 23         [10] 1379         JP      NZ,ERRIN        ; "in line" wanted?
      002863 C3 E3 23         [10] 1380         JP      PRNTOK          ; Go to command mode
                                   1381 
      002866 2A D4 42         [16] 1382 CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
      002869 7C               [ 4] 1383         LD      A,H             ; Is it zero?
      00286A B5               [ 4] 1384         OR      L
      00286B 1E 20            [ 7] 1385         LD      E,#CN           ; ?CN Error
      00286D CA AC 23         [10] 1386         JP      Z,ERROR         ; Yes - output "?CN Error"
      002870 EB               [ 4] 1387         EX      DE,HL           ; Save code string address
      002871 2A D2 42         [16] 1388         LD      HL,(ERRLIN)     ; Get line of last break
      002874 22 5C 42         [16] 1389         LD      (LINEAT),HL     ; Set up current line number
      002877 EB               [ 4] 1390         EX      DE,HL           ; Restore code string address
      002878 C9               [10] 1391         RET                     ; CONTinue where left off
                                   1392 
      002879 CD BE 33         [17] 1393 NULL:   CALL    GETINT          ; Get integer 0-255
      00287C C0               [11] 1394         RET     NZ              ; Return if bad value
      00287D 32 41 42         [13] 1395         LD      (NULLS),A       ; Set nulls number
      002880 C9               [10] 1396         RET
                                   1397 
                                   1398 
      002881 E5               [11] 1399 ACCSUM: PUSH    HL              ; Save address in array
      002882 2A 4A 42         [16] 1400         LD      HL,(CHKSUM)     ; Get check sum
      002885 06 00            [ 7] 1401         LD      B,#0            ; BC - Value of byte
      002887 4F               [ 4] 1402         LD      C,A
      002888 09               [11] 1403         ADD     HL,BC           ; Add byte to check sum
      002889 22 4A 42         [16] 1404         LD      (CHKSUM),HL     ; Re-save check sum
      00288C E1               [10] 1405         POP     HL              ; Restore address in array
      00288D C9               [10] 1406         RET
                                   1407 
      00288E 7E               [ 7] 1408 CHKLTR: LD      A,(HL)          ; Get byte
      00288F FE 41            [ 7] 1409         CP      #'A'            ; < 'a' ?
      002891 D8               [11] 1410         RET     C               ; Carry set if not letter
      002892 FE 5B            [ 7] 1411         CP      #'Z'+1          ; > 'z' ?
      002894 3F               [ 4] 1412         CCF
      002895 C9               [10] 1413         RET                     ; Carry set if not letter
                                   1414 
      002896 CD F0 27         [17] 1415 FPSINT: CALL    GETCHR          ; Get next character
      002899 CD 5D 2C         [17] 1416 POSINT: CALL    GETNUM          ; Get integer 0 to 32767
      00289C CD 3F 36         [17] 1417 DEPINT: CALL    TSTSGN          ; Test sign of FPREG
      00289F FA B7 28         [10] 1418         JP      M,FCERR         ; Negative - ?FC Error
      0028A2 3A E7 42         [13] 1419 DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
      0028A5 FE 90            [ 7] 1420         CP      #0x80+16        ; Exponent in range (16 bits)?
      0028A7 DA E7 36         [10] 1421         JP      C,FPINT         ; Yes - convert it
      0028AA 01 80 90         [10] 1422         LD      BC,#0x9080      ; BCDE = -32768
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 27.
Hexadecimal [24-Bits]



      0028AD 11 00 00         [10] 1423         LD      DE,#0x0000
      0028B0 E5               [11] 1424         PUSH    HL              ; Save code string address
      0028B1 CD BA 36         [17] 1425         CALL    CMPNUM          ; Compare FPREG with BCDE
      0028B4 E1               [10] 1426         POP     HL              ; Restore code string address
      0028B5 51               [ 4] 1427         LD      D,C             ; MSB to D
      0028B6 C8               [11] 1428         RET     Z               ; Return if in range
      0028B7 1E 08            [ 7] 1429 FCERR:  LD      E,#FC           ; ?FC Error
      0028B9 C3 AC 23         [10] 1430         JP      ERROR           ; Output error-
                                   1431 
      0028BC 2B               [ 6] 1432 ATOH:   DEC     HL              ; ASCII number to DE binary
      0028BD 11 00 00         [10] 1433 GETLN:  LD      DE,#0           ; Get number to DE
      0028C0 CD F0 27         [17] 1434 GTLNLP: CALL    GETCHR          ; Get next character
      0028C3 D0               [11] 1435         RET     NC              ; Exit if not a digit
      0028C4 E5               [11] 1436         PUSH    HL              ; Save code string address
      0028C5 F5               [11] 1437         PUSH    AF              ; Save digit
      0028C6 21 98 19         [10] 1438         LD      HL,#65529/10     ; Largest number 65529
      0028C9 CD 60 26         [17] 1439         CALL    CPDEHL          ; Number in range?
      0028CC DA 98 23         [10] 1440         JP      C,SNERR         ; No - ?SN Error
      0028CF 62               [ 4] 1441         LD      H,D             ; HL = Number
      0028D0 6B               [ 4] 1442         LD      L,E
      0028D1 19               [11] 1443         ADD     HL,DE           ; Times 2
      0028D2 29               [11] 1444         ADD     HL,HL           ; Times 4
      0028D3 19               [11] 1445         ADD     HL,DE           ; Times 5
      0028D4 29               [11] 1446         ADD     HL,HL           ; Times 10
      0028D5 F1               [10] 1447         POP     AF              ; Restore digit
      0028D6 D6 30            [ 7] 1448         SUB     #'0'             ; Make it 0 to 9
      0028D8 5F               [ 4] 1449         LD      E,A             ; DE = Value of digit
      0028D9 16 00            [ 7] 1450         LD      D,#0
      0028DB 19               [11] 1451         ADD     HL,DE           ; Add to number
      0028DC EB               [ 4] 1452         EX      DE,HL           ; Number to DE
      0028DD E1               [10] 1453         POP     HL              ; Restore code string address
      0028DE C3 C0 28         [10] 1454         JP      GTLNLP          ; Go to next character
                                   1455 
      0028E1 CA B4 24         [10] 1456 CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
      0028E4 CD 99 28         [17] 1457         CALL    POSINT          ; Get integer 0 to 32767 to DE
      0028E7 2B               [ 6] 1458         DEC     HL              ; Cancel increment
      0028E8 CD F0 27         [17] 1459         CALL    GETCHR          ; Get next character
      0028EB E5               [11] 1460         PUSH    HL              ; Save code string address
      0028EC 2A AF 42         [16] 1461         LD      HL,(LSTRAM)     ; Get end of RAM
      0028EF CA 04 29         [10] 1462         JP      Z,STORED        ; No value given - Use stored
      0028F2 E1               [10] 1463         POP     HL              ; Restore code string address
      0028F3 CD 66 26         [17] 1464         CALL    CHKSYN          ; Check for comma
      0028F6 2C                    1465         .BYTE      ','
      0028F7 D5               [11] 1466         PUSH    DE              ; Save number
      0028F8 CD 99 28         [17] 1467         CALL    POSINT          ; Get integer 0 to 32767
      0028FB 2B               [ 6] 1468         DEC     HL              ; Cancel increment
      0028FC CD F0 27         [17] 1469         CALL    GETCHR          ; Get next character
      0028FF C2 98 23         [10] 1470         JP      NZ,SNERR        ; ?SN Error if more on line
      002902 E3               [19] 1471         EX      (SP),HL         ; Save code string address
      002903 EB               [ 4] 1472         EX      DE,HL           ; Number to DE
      002904 7D               [ 4] 1473 STORED: LD      A,L             ; Get LSB of new RAM top
      002905 93               [ 4] 1474         SUB     E               ; Subtract LSB of string space
      002906 5F               [ 4] 1475         LD      E,A             ; Save LSB
      002907 7C               [ 4] 1476         LD      A,H             ; Get MSB of new RAM top
      002908 9A               [ 4] 1477         SBC     A,D             ; Subtract MSB of string space
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 28.
Hexadecimal [24-Bits]



      002909 57               [ 4] 1478         LD      D,A             ; Save MSB
      00290A DA 8D 23         [10] 1479         JP      C,OMERR         ; ?OM Error if not enough mem
      00290D E5               [11] 1480         PUSH    HL              ; Save RAM top
      00290E 2A D6 42         [16] 1481         LD      HL,(PROGND)     ; Get program end
      002911 01 28 00         [10] 1482         LD      BC,#40          ; 40 Bytes minimum working RAM
      002914 09               [11] 1483         ADD     HL,BC           ; Get lowest address
      002915 CD 60 26         [17] 1484         CALL    CPDEHL          ; Enough memory?
      002918 D2 8D 23         [10] 1485         JP      NC,OMERR        ; No - ?OM Error
      00291B EB               [ 4] 1486         EX      DE,HL           ; RAM top to HL
      00291C 22 5A 42         [16] 1487         LD      (STRSPC),HL     ; Set new string space
      00291F E1               [10] 1488         POP     HL              ; End of memory to use
      002920 22 AF 42         [16] 1489         LD      (LSTRAM),HL     ; Set new top of RAM
      002923 E1               [10] 1490         POP     HL              ; Restore code string address
      002924 C3 B4 24         [10] 1491         JP      INTVAR          ; Initialise variables
                                   1492 
      002927 CA B0 24         [10] 1493 RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
      00292A CD B4 24         [17] 1494         CALL    INTVAR          ; Initialise variables
      00292D 01 B0 27         [10] 1495         LD      BC,#RUNCNT      ; Execution driver loop
      002930 C3 43 29         [10] 1496         JP      RUNLIN          ; RUN from line number
                                   1497 
      002933 0E 03            [ 7] 1498 GOSUB:  LD      C,#3            ; 3 Levels of stack needed
      002935 CD 75 23         [17] 1499         CALL    CHKSTK          ; Check for 3 levels of stack
      002938 C1               [10] 1500         POP     BC              ; Get return address
      002939 E5               [11] 1501         PUSH    HL              ; Save code string for RETURN
      00293A E5               [11] 1502         PUSH    HL              ; And for GOSUB routine
      00293B 2A 5C 42         [16] 1503         LD      HL,(LINEAT)     ; Get current line
      00293E E3               [19] 1504         EX      (SP),HL         ; Into stack - Code string out
      00293F 3E 8C            [ 7] 1505         LD      A,#ZGOSUB       ; "GOSUB" token
      002941 F5               [11] 1506         PUSH    AF              ; Save token
      002942 33               [ 6] 1507         INC     SP              ; Don't save flags
                                   1508 
      002943 C5               [11] 1509 RUNLIN: PUSH    BC              ; Save return address
      002944 CD BC 28         [17] 1510 GOTO:   CALL    ATOH            ; ASCII number to DE binary
      002947 CD 89 29         [17] 1511         CALL    REM             ; Get end of line
      00294A E5               [11] 1512         PUSH    HL              ; Save end of line
      00294B 2A 5C 42         [16] 1513         LD      HL,(LINEAT)     ; Get current line
      00294E CD 60 26         [17] 1514         CALL    CPDEHL          ; Line after current?
      002951 E1               [10] 1515         POP     HL              ; Restore end of line
      002952 23               [ 6] 1516         INC     HL              ; Start of next line
      002953 DC 87 24         [17] 1517         CALL    C,SRCHLP        ; Line is after current line
      002956 D4 84 24         [17] 1518         CALL    NC,SRCHLN       ; Line is before current line
      002959 60               [ 4] 1519         LD      H,B             ; Set up code string address
      00295A 69               [ 4] 1520         LD      L,C
      00295B 2B               [ 6] 1521         DEC     HL              ; Incremented after
      00295C D8               [11] 1522         RET     C               ; Line found
      00295D 1E 0E            [ 7] 1523 ULERR:  LD      E,#UL           ; ?UL Error
      00295F C3 AC 23         [10] 1524         JP      ERROR           ; Output error message
                                   1525 
      002962 C0               [11] 1526 RETURN: RET     NZ              ; Return if not just RETURN
      002963 16 FF            [ 7] 1527         LD      D,#-1           ; Flag "GOSUB" search
      002965 CD 41 23         [17] 1528         CALL    BAKSTK          ; Look "GOSUB" block
      002968 F9               [ 6] 1529         LD      SP,HL           ; Kill all FORs in subroutine
      002969 FE 8C            [ 7] 1530         CP      #ZGOSUB         ; Test for "GOSUB" token
      00296B 1E 04            [ 7] 1531         LD      E,#RG           ; ?RG Error
      00296D C2 AC 23         [10] 1532         JP      NZ,ERROR        ; Error if no "GOSUB" found
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 29.
Hexadecimal [24-Bits]



      002970 E1               [10] 1533         POP     HL              ; Get RETURN line number
      002971 22 5C 42         [16] 1534         LD      (LINEAT),HL     ; Save as current
      002974 23               [ 6] 1535         INC     HL              ; Was it from direct statement?
      002975 7C               [ 4] 1536         LD      A,H
      002976 B5               [ 4] 1537         OR      L               ; Return to line
      002977 C2 81 29         [10] 1538         JP      NZ,RETLIN       ; No - Return to line
      00297A 3A CC 42         [13] 1539         LD      A,(LSTBIN)      ; Any INPUT in subroutine?
      00297D B7               [ 4] 1540         OR      A               ; If so buffer is corrupted
      00297E C2 E2 23         [10] 1541         JP      NZ,POPNOK       ; Yes - Go to command mode
      002981 21 B0 27         [10] 1542 RETLIN: LD      HL,#RUNCNT      ; Execution driver loop
      002984 E3               [19] 1543         EX      (SP),HL         ; Into stack - Code string out
      002985 3E                    1544         .BYTE      0x3E         ; Skip "POP HL"
      002986 E1               [10] 1545 NXTDTA: POP     HL              ; Restore code string address
                                   1546 
      002987 01 3A                 1547 DATA:   .BYTE   0x01,0x3A       ; ':' End of statement
      002989 0E 00            [ 7] 1548 REM:    LD      C,#0            ; 00  End of statement
      00298B 06 00            [ 7] 1549         LD      B,#0
      00298D 79               [ 4] 1550 NXTSTL: LD      A,C             ; Statement and byte
      00298E 48               [ 4] 1551         LD      C,B
      00298F 47               [ 4] 1552         LD      B,A             ; Statement end byte
      002990 7E               [ 7] 1553 NXTSTT: LD      A,(HL)          ; Get byte
      002991 B7               [ 4] 1554         OR      A               ; End of line?
      002992 C8               [11] 1555         RET     Z               ; Yes - Exit
      002993 B8               [ 4] 1556         CP      B               ; End of statement?
      002994 C8               [11] 1557         RET     Z               ; Yes - Exit
      002995 23               [ 6] 1558         INC     HL              ; Next byte
      002996 FE 22            [ 7] 1559         CP      #'"'            ; Literal string?
      002998 CA 8D 29         [10] 1560         JP      Z,NXTSTL        ; Yes - Look for another '"'
      00299B C3 90 29         [10] 1561         JP      NXTSTT          ; Keep looking
                                   1562 
      00299E CD 53 2E         [17] 1563 LET:    CALL    GETVAR          ; Get variable name
      0029A1 CD 66 26         [17] 1564         CALL    CHKSYN          ; Make sure "=" follows
      0029A4 B4                    1565         .BYTE      ZEQUAL          ; "=" token
      0029A5 D5               [11] 1566         PUSH    DE              ; Save address of variable
      0029A6 3A AD 42         [13] 1567         LD      A,(TYPE)        ; Get data type
      0029A9 F5               [11] 1568         PUSH    AF              ; Save type
      0029AA CD 6F 2C         [17] 1569         CALL    EVAL            ; Evaluate expression
      0029AD F1               [10] 1570         POP     AF              ; Restore type
      0029AE E3               [19] 1571         EX      (SP),HL         ; Save code - Get var addr
      0029AF 22 CE 42         [16] 1572         LD      (BRKLIN),HL     ; Save address of variable
      0029B2 1F               [ 4] 1573         RRA                     ; Adjust type
      0029B3 CD 62 2C         [17] 1574         CALL    CHKTYP          ; Check types are the same
      0029B6 CA F1 29         [10] 1575         JP      Z,LETNUM        ; Numeric - Move value
      0029B9 E5               [11] 1576 LETSTR: PUSH    HL              ; Save address of string var
      0029BA 2A E4 42         [16] 1577         LD      HL,(FPREG)      ; Pointer to string entry
      0029BD E5               [11] 1578         PUSH    HL              ; Save it on stack
      0029BE 23               [ 6] 1579         INC     HL              ; Skip over length
      0029BF 23               [ 6] 1580         INC     HL
      0029C0 5E               [ 7] 1581         LD      E,(HL)          ; LSB of string address
      0029C1 23               [ 6] 1582         INC     HL
      0029C2 56               [ 7] 1583         LD      D,(HL)          ; MSB of string address
      0029C3 2A 5E 42         [16] 1584         LD      HL,(BASTXT)     ; Point to start of program
      0029C6 CD 60 26         [17] 1585         CALL    CPDEHL          ; Is string before program?
      0029C9 D2 E0 29         [10] 1586         JP      NC,CRESTR       ; Yes - Create string entry
      0029CC 2A 5A 42         [16] 1587         LD      HL,(STRSPC)     ; Point to string space
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 30.
Hexadecimal [24-Bits]



      0029CF CD 60 26         [17] 1588         CALL    CPDEHL          ; Is string literal in program?
      0029D2 D1               [10] 1589         POP     DE              ; Restore address of string
      0029D3 D2 E8 29         [10] 1590         JP      NC,MVSTPT       ; Yes - Set up pointer
      0029D6 21 BF 42         [10] 1591         LD      HL,#TMPSTR      ; Temporary string pool
      0029D9 CD 60 26         [17] 1592         CALL    CPDEHL          ; Is string in temporary pool?
      0029DC D2 E8 29         [10] 1593         JP      NC,MVSTPT       ; No - Set up pointer
      0029DF 3E                    1594         .BYTE   0x3E            ; Skip "POP DE"
      0029E0 D1               [10] 1595 CRESTR: POP     DE              ; Restore address of string
      0029E1 CD 97 32         [17] 1596         CALL    BAKTMP          ; Back to last tmp-str entry
      0029E4 EB               [ 4] 1597         EX      DE,HL           ; Address of string entry
      0029E5 CD D0 30         [17] 1598         CALL    SAVSTR          ; Save string in string area
      0029E8 CD 97 32         [17] 1599 MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
      0029EB E1               [10] 1600         POP     HL              ; Get string pointer
      0029EC CD 9A 36         [17] 1601         CALL    DETHL4          ; Move string pointer to var
      0029EF E1               [10] 1602         POP     HL              ; Restore code string address
      0029F0 C9               [10] 1603         RET
                                   1604 
      0029F1 E5               [11] 1605 LETNUM: PUSH    HL              ; Save address of variable
      0029F2 CD 97 36         [17] 1606         CALL    FPTHL           ; Move value to variable
      0029F5 D1               [10] 1607         POP     DE              ; Restore address of variable
      0029F6 E1               [10] 1608         POP     HL              ; Restore code string address
      0029F7 C9               [10] 1609         RET
                                   1610 
      0029F8 CD BE 33         [17] 1611 ON:     CALL    GETINT          ; Get integer 0-255
      0029FB 7E               [ 7] 1612         LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
      0029FC 47               [ 4] 1613         LD      B,A             ; Save in B
      0029FD FE 8C            [ 7] 1614         CP      #ZGOSUB         ; "GOSUB" token?
      0029FF CA 07 2A         [10] 1615         JP      Z,ONGO          ; Yes - Find line number
      002A02 CD 66 26         [17] 1616         CALL    CHKSYN          ; Make sure it's "GOTO"
      002A05 88                    1617         .BYTE   ZGOTO           ; "GOTO" token
      002A06 2B               [ 6] 1618         DEC     HL              ; Cancel increment
      002A07 4B               [ 4] 1619 ONGO:   LD      C,E             ; Integer of branch value
      002A08 0D               [ 4] 1620 ONGOLP: DEC     C               ; Count branches
      002A09 78               [ 4] 1621         LD      A,B             ; Get "GOTO" or "GOSUB" token
      002A0A CA D8 27         [10] 1622         JP      Z,ONJMP         ; Go to that line if right one
      002A0D CD BD 28         [17] 1623         CALL    GETLN           ; Get line number to DE
      002A10 FE 2C            [ 7] 1624         CP      #','            ; Another line number?
      002A12 C0               [11] 1625         RET     NZ              ; No - Drop through
      002A13 C3 08 2A         [10] 1626         JP      ONGOLP          ; Yes - loop
                                   1627 
      002A16 CD 6F 2C         [17] 1628 IF:     CALL    EVAL            ; Evaluate expression
      002A19 7E               [ 7] 1629         LD      A,(HL)          ; Get token
      002A1A FE 88            [ 7] 1630         CP      #ZGOTO          ; "GOTO" token?
      002A1C CA 24 2A         [10] 1631         JP      Z,IFGO          ; Yes - Get line
      002A1F CD 66 26         [17] 1632         CALL    CHKSYN          ; Make sure it's "THEN"
      002A22 A9                    1633         .BYTE      ZTHEN           ; "THEN" token
      002A23 2B               [ 6] 1634         DEC     HL              ; Cancel increment
      002A24 CD 60 2C         [17] 1635 IFGO:   CALL    TSTNUM          ; Make sure it's numeric
      002A27 CD 3F 36         [17] 1636         CALL    TSTSGN          ; Test state of expression
      002A2A CA 89 29         [10] 1637         JP      Z,REM           ; False - Drop through
      002A2D CD F0 27         [17] 1638         CALL    GETCHR          ; Get next character
      002A30 DA 44 29         [10] 1639         JP      C,GOTO          ; Number - GOTO that line
      002A33 C3 D7 27         [10] 1640         JP      IFJMP           ; Otherwise do statement
                                   1641 
      002A36 2B               [ 6] 1642 MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 31.
Hexadecimal [24-Bits]



      002A37 CD F0 27         [17] 1643         CALL    GETCHR          ; Get next character
      002A3A CA 98 2A         [10] 1644 PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
      002A3D C8               [11] 1645 PRNTLP: RET     Z               ; End of list - Exit
      002A3E FE A5            [ 7] 1646         CP      #ZTAB           ; "TAB(" token?
      002A40 CA CB 2A         [10] 1647         JP      Z,DOTAB         ; Yes - Do TAB routine
      002A43 FE A8            [ 7] 1648         CP      #ZSPC           ; "SPC(" token?
      002A45 CA CB 2A         [10] 1649         JP      Z,DOTAB         ; Yes - Do SPC routine
      002A48 E5               [11] 1650         PUSH    HL              ; Save code string address
      002A49 FE 2C            [ 7] 1651         CP      #','            ; Comma?
      002A4B CA B4 2A         [10] 1652         JP      Z,DOCOM         ; Yes - Move to next zone
      002A4E FE 3B            [ 7] 1653         CP      #59 ;";"        ; Semi-colon?
      002A50 CA EE 2A         [10] 1654         JP      Z,NEXITM        ; Do semi-colon routine
      002A53 C1               [10] 1655         POP     BC              ; Code string address to BC
      002A54 CD 6F 2C         [17] 1656         CALL    EVAL            ; Evaluate expression
      002A57 E5               [11] 1657         PUSH    HL              ; Save code string address
      002A58 3A AD 42         [13] 1658         LD      A,(TYPE)        ; Get variable type
      002A5B B7               [ 4] 1659         OR      A               ; Is it a string variable?
      002A5C C2 84 2A         [10] 1660         JP      NZ,PRNTST       ; Yes - Output string contents
      002A5F CD E4 37         [17] 1661         CALL    NUMASC          ; Convert number to text
      002A62 CD F4 30         [17] 1662         CALL    CRTST           ; Create temporary string
      002A65 36 20            [10] 1663         LD      (HL),#' '       ; Followed by a space
      002A67 2A E4 42         [16] 1664         LD      HL,(FPREG)      ; Get length of output
      002A6A 34               [11] 1665         INC     (HL)            ; Plus 1 for the space
      002A6B 2A E4 42         [16] 1666         LD      HL,(FPREG)      ; < Not needed >
      002A6E 3A 42 42         [13] 1667         LD      A,(LWIDTH)      ; Get width of line
      002A71 47               [ 4] 1668         LD      B,A             ; To B
      002A72 04               [ 4] 1669         INC     B               ; Width 255 (No limit)?
      002A73 CA 80 2A         [10] 1670         JP      Z,PRNTNB        ; Yes - Output number string
      002A76 04               [ 4] 1671         INC     B               ; Adjust it
      002A77 3A AB 42         [13] 1672         LD      A,(CURPOS)      ; Get cursor position
      002A7A 86               [ 7] 1673         ADD     A,(HL)          ; Add length of string
      002A7B 3D               [ 4] 1674         DEC     A               ; Adjust it
      002A7C B8               [ 4] 1675         CP      B               ; Will output fit on this line?
      002A7D D4 98 2A         [17] 1676         CALL    NC,PRNTCRLF     ; No - CRLF first
      002A80 CD 39 31         [17] 1677 PRNTNB: CALL    PRS1            ; Output string at (HL)
      002A83 AF               [ 4] 1678         XOR     A               ; Skip CALL by setting 'z' flag
      002A84 C4 39 31         [17] 1679 PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
      002A87 E1               [10] 1680         POP     HL              ; Restore code string address
      002A88 C3 36 2A         [10] 1681         JP      MRPRNT          ; See if more to PRINT
                                   1682 
      002A8B 3A AB 42         [13] 1683 STTLIN: LD      A,(CURPOS)      ; Make sure on new line
      002A8E B7               [ 4] 1684         OR      A               ; Already at start?
      002A8F C8               [11] 1685         RET     Z               ; Yes - Do nothing
      002A90 C3 98 2A         [10] 1686         JP      PRNTCRLF        ; Start a new line
                                   1687 
      002A93 36 00            [10] 1688 ENDINP: LD      (HL),#0         ; Mark end of buffer
      002A95 21 60 42         [10] 1689         LD      HL,#BUFFER-1    ; Point to buffer
      002A98 3E 0D            [ 7] 1690 PRNTCRLF: LD    A,#CR           ; Load a CR
      002A9A CD 71 26         [17] 1691         CALL    OUTC            ; Output character
      002A9D 3E 0A            [ 7] 1692         LD      A,#LF           ; Load a LF
      002A9F CD 71 26         [17] 1693         CALL    OUTC            ; Output character
      002AA2 AF               [ 4] 1694 DONULL: XOR     A               ; Set to position 0
      002AA3 32 AB 42         [13] 1695         LD      (CURPOS),A      ; Store it
      002AA6 3A 41 42         [13] 1696         LD      A,(NULLS)       ; Get number of nulls
      002AA9 3D               [ 4] 1697 NULLP:  DEC     A               ; Count them
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 32.
Hexadecimal [24-Bits]



      002AAA C8               [11] 1698         RET     Z               ; Return if done
      002AAB F5               [11] 1699         PUSH    AF              ; Save count
      002AAC AF               [ 4] 1700         XOR     A               ; Load a null
      002AAD CD 71 26         [17] 1701         CALL    OUTC            ; Output it
      002AB0 F1               [10] 1702         POP     AF              ; Restore count
      002AB1 C3 A9 2A         [10] 1703         JP      NULLP           ; Keep counting
                                   1704 
      002AB4 3A 43 42         [13] 1705 DOCOM:  LD      A,(COMMAN)      ; Get comma width
      002AB7 47               [ 4] 1706         LD      B,A             ; Save in B
      002AB8 3A AB 42         [13] 1707         LD      A,(CURPOS)      ; Get current position
      002ABB B8               [ 4] 1708         CP      B               ; Within the limit?
      002ABC D4 98 2A         [17] 1709         CALL    NC,PRNTCRLF     ; No - output CRLF
      002ABF D2 EE 2A         [10] 1710         JP      NC,NEXITM       ; Get next item
      002AC2 D6 0E            [ 7] 1711 ZONELP: SUB     #14             ; Next zone of 14 characters
      002AC4 D2 C2 2A         [10] 1712         JP      NC,ZONELP       ; Repeat if more zones
      002AC7 2F               [ 4] 1713         CPL                     ; Number of spaces to output
      002AC8 C3 E3 2A         [10] 1714         JP      ASPCS           ; Output them
                                   1715 
      002ACB F5               [11] 1716 DOTAB:  PUSH    AF              ; Save token
      002ACC CD BB 33         [17] 1717         CALL    FNDNUM          ; Evaluate expression
      002ACF CD 66 26         [17] 1718         CALL    CHKSYN          ; Make sure ")" follows
      002AD2 29                    1719         .BYTE   ")"
      002AD3 2B               [ 6] 1720         DEC     HL              ; Back space on to ")"
      002AD4 F1               [10] 1721         POP     AF              ; Restore token
      002AD5 D6 A8            [ 7] 1722         SUB     #ZSPC           ; Was it "SPC(" ?
      002AD7 E5               [11] 1723         PUSH    HL              ; Save code string address
      002AD8 CA DE 2A         [10] 1724         JP      Z,DOSPC         ; Yes - Do 'E' spaces
      002ADB 3A AB 42         [13] 1725         LD      A,(CURPOS)      ; Get current position
      002ADE 2F               [ 4] 1726 DOSPC:  CPL                     ; Number of spaces to print to
      002ADF 83               [ 4] 1727         ADD     A,E             ; Total number to print
      002AE0 D2 EE 2A         [10] 1728         JP      NC,NEXITM       ; TAB < Current POS(X)
      002AE3 3C               [ 4] 1729 ASPCS:  INC     A               ; Output A spaces
      002AE4 47               [ 4] 1730         LD      B,A             ; Save number to print
      002AE5 3E 20            [ 7] 1731         LD      A,#' '          ; Space
      002AE7 CD 71 26         [17] 1732 SPCLP:  CALL    OUTC            ; Output character in A
      002AEA 05               [ 4] 1733         DEC     B               ; Count them
      002AEB C2 E7 2A         [10] 1734         JP      NZ,SPCLP        ; Repeat if more
      002AEE E1               [10] 1735 NEXITM: POP     HL              ; Restore code string address
      002AEF CD F0 27         [17] 1736         CALL    GETCHR          ; Get next character
      002AF2 C3 3D 2A         [10] 1737         JP      PRNTLP          ; More to print
                                   1738 
      002AF5 3F 52 65 64 6F 20 66  1739 REDO:   .ASCII	"?Redo from start"
             72 6F 6D 20 73 74 61
             72 74
      002B05 0D 0A 00              1740         .DB	CR,LF,0
                                   1741 
      002B08 3A CD 42         [13] 1742 BADINP: LD      A,(READFG)      ; READ or INPUT?
      002B0B B7               [ 4] 1743         OR      A
      002B0C C2 92 23         [10] 1744         JP      NZ,DATSNR       ; READ - ?SN Error
      002B0F C1               [10] 1745         POP     BC              ; Throw away code string addr
      002B10 21 F5 2A         [10] 1746         LD      HL,#REDO        ; "Redo from start" message
      002B13 CD 36 31         [17] 1747         CALL    PRS             ; Output string
      002B16 C3 E3 24         [10] 1748         JP      DOAGN           ; Do last INPUT again
                                   1749 
      002B19 CD A1 30         [17] 1750 INPUT:  CALL    IDTEST          ; Test for illegal direct
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 33.
Hexadecimal [24-Bits]



      002B1C 7E               [ 7] 1751         LD      A,(HL)          ; Get character after "INPUT"
      002B1D FE 22            [ 7] 1752         CP      #'"'            ; Is there a prompt string?
      002B1F 3E 00            [ 7] 1753         LD      A,#0            ; Clear A and leave flags
      002B21 32 45 42         [13] 1754         LD      (CTLOFG),A      ; Enable output
      002B24 C2 33 2B         [10] 1755         JP      NZ,NOPMPT       ; No prompt - get input
      002B27 CD F5 30         [17] 1756         CALL    QTSTR           ; Get string terminated by '"'
      002B2A CD 66 26         [17] 1757         CALL    CHKSYN          ; Check for ';' after prompt
      002B2D 3B                    1758         .BYTE   ';'
      002B2E E5               [11] 1759         PUSH    HL              ; Save code string address
      002B2F CD 39 31         [17] 1760         CALL    PRS1            ; Output prompt string
      002B32 3E                    1761         .BYTE   0x3E            ; Skip "PUSH HL"
      002B33 E5               [11] 1762 NOPMPT: PUSH    HL              ; Save code string address
      002B34 CD E7 24         [17] 1763         CALL    PROMPT          ; Get input with "? " prompt
      002B37 C1               [10] 1764         POP     BC              ; Restore code string address
      002B38 DA 3F 28         [10] 1765         JP      C,INPBRK        ; Break pressed - Exit
      002B3B 23               [ 6] 1766         INC     HL              ; Next byte
      002B3C 7E               [ 7] 1767         LD      A,(HL)          ; Get it
      002B3D B7               [ 4] 1768         OR      A               ; End of line?
      002B3E 2B               [ 6] 1769         DEC     HL              ; Back again
      002B3F C5               [11] 1770         PUSH    BC              ; Re-save code string address
      002B40 CA 86 29         [10] 1771         JP      Z,NXTDTA        ; Yes - Find next DATA stmt
      002B43 36 2C            [10] 1772         LD      (HL),#','       ; Store comma as separator
      002B45 C3 4D 2B         [10] 1773         JP      NXTITM          ; Get next item
                                   1774 
      002B48 E5               [11] 1775 READ:   PUSH    HL              ; Save code string address
      002B49 2A DC 42         [16] 1776         LD      HL,(NXTDAT)     ; Next DATA statement
      002B4C F6                    1777         .BYTE   0xF6            ; Flag "READ"
      002B4D AF               [ 4] 1778 NXTITM: XOR     A               ; Flag "INPUT"
      002B4E 32 CD 42         [13] 1779         LD      (READFG),A      ; Save "READ"/"INPUT" flag
      002B51 E3               [19] 1780         EX      (SP),HL         ; Get code str' , Save pointer
      002B52 C3 59 2B         [10] 1781         JP      GTVLUS          ; Get values
                                   1782 
      002B55 CD 66 26         [17] 1783 NEDMOR: CALL    CHKSYN          ; Check for comma between items
      002B58 2C                    1784         .BYTE   ','
      002B59 CD 53 2E         [17] 1785 GTVLUS: CALL    GETVAR          ; Get variable name
      002B5C E3               [19] 1786         EX      (SP),HL         ; Save code str" , Get pointer
      002B5D D5               [11] 1787         PUSH    DE              ; Save variable address
      002B5E 7E               [ 7] 1788         LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
      002B5F FE 2C            [ 7] 1789         CP      #','            ; Comma?
      002B61 CA 81 2B         [10] 1790         JP      Z,ANTVLU        ; Yes - Get another value
      002B64 3A CD 42         [13] 1791         LD      A,(READFG)      ; Is it READ?
      002B67 B7               [ 4] 1792         OR      A
      002B68 C2 EE 2B         [10] 1793         JP      NZ,FDTLP        ; Yes - Find next DATA stmt
      002B6B 3E 3F            [ 7] 1794         LD      A,#'?'          ; More INPUT needed
      002B6D CD 71 26         [17] 1795         CALL    OUTC            ; Output character
      002B70 CD E7 24         [17] 1796         CALL    PROMPT          ; Get INPUT with prompt
      002B73 D1               [10] 1797         POP     DE              ; Variable address
      002B74 C1               [10] 1798         POP     BC              ; Code string address
      002B75 DA 3F 28         [10] 1799         JP      C,INPBRK        ; Break pressed
      002B78 23               [ 6] 1800         INC     HL              ; Point to next DATA byte
      002B79 7E               [ 7] 1801         LD      A,(HL)          ; Get byte
      002B7A B7               [ 4] 1802         OR      A               ; Is it zero (No input) ?
      002B7B 2B               [ 6] 1803         DEC     HL              ; Back space INPUT pointer
      002B7C C5               [11] 1804         PUSH    BC              ; Save code string address
      002B7D CA 86 29         [10] 1805         JP      Z,NXTDTA        ; Find end of buffer
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 34.
Hexadecimal [24-Bits]



      002B80 D5               [11] 1806         PUSH    DE              ; Save variable address
      002B81 3A AD 42         [13] 1807 ANTVLU: LD      A,(TYPE)        ; Check data type
      002B84 B7               [ 4] 1808         OR      A               ; Is it numeric?
      002B85 CA AB 2B         [10] 1809         JP      Z,INPBIN        ; Yes - Convert to binary
      002B88 CD F0 27         [17] 1810         CALL    GETCHR          ; Get next character
      002B8B 57               [ 4] 1811         LD      D,A             ; Save input character
      002B8C 47               [ 4] 1812         LD      B,A             ; Again
      002B8D FE 22            [ 7] 1813         CP      #'"'            ; Start of literal sting?
      002B8F CA 9F 2B         [10] 1814         JP      Z,STRENT        ; Yes - Create string entry
      002B92 3A CD 42         [13] 1815         LD      A,(READFG)      ; "READ" or "INPUT" ?
      002B95 B7               [ 4] 1816         OR      A
      002B96 57               [ 4] 1817         LD      D,A             ; Save 00 if "INPUT"
      002B97 CA 9C 2B         [10] 1818         JP      Z,ITMSEP        ; "INPUT" - End with 00
      002B9A 16 3A            [ 7] 1819         LD      D,#':'          ; "DATA" - End with 00 or ':'
      002B9C 06 2C            [ 7] 1820 ITMSEP: LD      B,#','          ; Item separator
      002B9E 2B               [ 6] 1821         DEC     HL              ; Back space for DTSTR
      002B9F CD F8 30         [17] 1822 STRENT: CALL    DTSTR           ; Get string terminated by D
      002BA2 EB               [ 4] 1823         EX      DE,HL           ; String address to DE
      002BA3 21 B6 2B         [10] 1824         LD      HL,#LTSTND      ; Where to go after LETSTR
      002BA6 E3               [19] 1825         EX      (SP),HL         ; Save HL , get input pointer
      002BA7 D5               [11] 1826         PUSH    DE              ; Save address of string
      002BA8 C3 B9 29         [10] 1827         JP      LETSTR          ; Assign string to variable
                                   1828 
      002BAB CD F0 27         [17] 1829 INPBIN: CALL    GETCHR          ; Get next character
      002BAE CD 46 37         [17] 1830         CALL    ASCTFP          ; Convert ASCII to FP number
      002BB1 E3               [19] 1831         EX      (SP),HL         ; Save input ptr, Get var addr
      002BB2 CD 97 36         [17] 1832         CALL    FPTHL           ; Move FPREG to variable
      002BB5 E1               [10] 1833         POP     HL              ; Restore input pointer
      002BB6 2B               [ 6] 1834 LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
      002BB7 CD F0 27         [17] 1835         CALL    GETCHR          ; Get next character
      002BBA CA C2 2B         [10] 1836         JP      Z,MORDT         ; End of line - More needed?
      002BBD FE 2C            [ 7] 1837         CP      #','            ; Another value?
      002BBF C2 08 2B         [10] 1838         JP      NZ,BADINP       ; No - Bad input
      002BC2 E3               [19] 1839 MORDT:  EX      (SP),HL         ; Get code string address
      002BC3 2B               [ 6] 1840         DEC     HL              ; DEC 'cos GETCHR INCs
      002BC4 CD F0 27         [17] 1841         CALL    GETCHR          ; Get next character
      002BC7 C2 55 2B         [10] 1842         JP      NZ,NEDMOR       ; More needed - Get it
      002BCA D1               [10] 1843         POP     DE              ; Restore DATA pointer
      002BCB 3A CD 42         [13] 1844         LD      A,(READFG)      ; "READ" or "INPUT" ?
      002BCE B7               [ 4] 1845         OR      A
      002BCF EB               [ 4] 1846         EX      DE,HL           ; DATA pointer to HL
      002BD0 C2 16 28         [10] 1847         JP      NZ,UPDATA       ; Update DATA pointer if "READ"
      002BD3 D5               [11] 1848         PUSH    DE              ; Save code string address
      002BD4 B6               [ 7] 1849         OR      (HL)            ; More input given?
      002BD5 21 DD 2B         [10] 1850         LD      HL,#EXTIG       ; "?Extra ignored" message
      002BD8 C4 36 31         [17] 1851         CALL    NZ,PRS          ; Output string if extra given
      002BDB E1               [10] 1852         POP     HL              ; Restore code string address
      002BDC C9               [10] 1853         RET
                                   1854 
      002BDD 3F 45 78 74 72 61 20  1855 EXTIG:  .ASCII	"?Extra ignored"
             69 67 6E 6F 72 65 64
      002BEB 0D 0A 00              1856 	.DB	CR,LF,0
                                   1857 
      002BEE CD 87 29         [17] 1858 FDTLP:  CALL    DATA            ; Get next statement
      002BF1 B7               [ 4] 1859         OR      A               ; End of line?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 35.
Hexadecimal [24-Bits]



      002BF2 C2 07 2C         [10] 1860         JP      NZ,FANDT        ; No - See if DATA statement
      002BF5 23               [ 6] 1861         INC     HL
      002BF6 7E               [ 7] 1862         LD      A,(HL)          ; End of program?
      002BF7 23               [ 6] 1863         INC     HL
      002BF8 B6               [ 7] 1864         OR      (HL)            ; 00 00 Ends program
      002BF9 1E 06            [ 7] 1865         LD      E,#OD           ; ?OD Error
      002BFB CA AC 23         [10] 1866         JP      Z,ERROR         ; Yes - Out of DATA
      002BFE 23               [ 6] 1867         INC     HL
      002BFF 5E               [ 7] 1868         LD      E,(HL)          ; LSB of line number
      002C00 23               [ 6] 1869         INC     HL
      002C01 56               [ 7] 1870         LD      D,(HL)          ; MSB of line number
      002C02 EB               [ 4] 1871         EX      DE,HL
      002C03 22 C9 42         [16] 1872         LD      (DATLIN),HL     ; Set line of current DATA item
      002C06 EB               [ 4] 1873         EX      DE,HL
      002C07 CD F0 27         [17] 1874 FANDT:  CALL    GETCHR          ; Get next character
      002C0A FE 83            [ 7] 1875         CP      #ZDATA          ; "DATA" token
      002C0C C2 EE 2B         [10] 1876         JP      NZ,FDTLP        ; No "DATA" - Keep looking
      002C0F C3 81 2B         [10] 1877         JP      ANTVLU          ; Found - Convert input
                                   1878 
      002C12 11 00 00         [10] 1879 NEXT:   LD      DE,#0           ; In case no index given
      002C15 C4 53 2E         [17] 1880 NEXT1:  CALL    NZ,GETVAR       ; Get index address
      002C18 22 CE 42         [16] 1881         LD      (BRKLIN),HL     ; Save code string address
      002C1B CD 41 23         [17] 1882         CALL    BAKSTK          ; Look for "FOR" block
      002C1E C2 9E 23         [10] 1883         JP      NZ,NFERR        ; No "FOR" - ?NF Error
      002C21 F9               [ 6] 1884         LD      SP,HL           ; Clear nested loops
      002C22 D5               [11] 1885         PUSH    DE              ; Save index address
      002C23 7E               [ 7] 1886         LD      A,(HL)          ; Get sign of STEP
      002C24 23               [ 6] 1887         INC     HL
      002C25 F5               [11] 1888         PUSH    AF              ; Save sign of STEP
      002C26 D5               [11] 1889         PUSH    DE              ; Save index address
      002C27 CD 7D 36         [17] 1890         CALL    PHLTFP          ; Move index value to FPREG
      002C2A E3               [19] 1891         EX      (SP),HL         ; Save address of TO value
      002C2B E5               [11] 1892         PUSH    HL              ; Save address of index
      002C2C CD EA 33         [17] 1893         CALL    ADDPHL          ; Add STEP to index value
      002C2F E1               [10] 1894         POP     HL              ; Restore address of index
      002C30 CD 97 36         [17] 1895         CALL    FPTHL           ; Move value to index variable
      002C33 E1               [10] 1896         POP     HL              ; Restore address of TO value
      002C34 CD 8E 36         [17] 1897         CALL    LOADFP          ; Move TO value to BCDE
      002C37 E5               [11] 1898         PUSH    HL              ; Save address of line of FOR
      002C38 CD BA 36         [17] 1899         CALL    CMPNUM          ; Compare index with TO value
      002C3B E1               [10] 1900         POP     HL              ; Restore address of line num
      002C3C C1               [10] 1901         POP     BC              ; Address of sign of STEP
      002C3D 90               [ 4] 1902         SUB     B               ; Compare with expected sign
      002C3E CD 8E 36         [17] 1903         CALL    LOADFP          ; BC = Loop stmt,DE = Line num
      002C41 CA 4D 2C         [10] 1904         JP      Z,KILFOR        ; Loop finished - Terminate it
      002C44 EB               [ 4] 1905         EX      DE,HL           ; Loop statement line number
      002C45 22 5C 42         [16] 1906         LD      (LINEAT),HL     ; Set loop line number
      002C48 69               [ 4] 1907         LD      L,C             ; Set code string to loop
      002C49 60               [ 4] 1908         LD      H,B
      002C4A C3 AC 27         [10] 1909         JP      PUTFID          ; Put back "FOR" and continue
                                   1910 
      002C4D F9               [ 6] 1911 KILFOR: LD      SP,HL           ; Remove "FOR" block
      002C4E 2A CE 42         [16] 1912         LD      HL,(BRKLIN)     ; Code string after "NEXT"
      002C51 7E               [ 7] 1913         LD      A,(HL)          ; Get next byte in code string
      002C52 FE 2C            [ 7] 1914         CP      #','            ; More NEXTs ?
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 36.
Hexadecimal [24-Bits]



      002C54 C2 B0 27         [10] 1915         JP      NZ,RUNCNT       ; No - Do next statement
      002C57 CD F0 27         [17] 1916         CALL    GETCHR          ; Position to index name
      002C5A CD 15 2C         [17] 1917         CALL    NEXT1           ; Re-enter NEXT routine
                                   1918 ; < will not RETurn to here , Exit to RUNCNT or Loop >
                                   1919 
      002C5D CD 6F 2C         [17] 1920 GETNUM: CALL    EVAL            ; Get a numeric expression
      002C60 F6                    1921 TSTNUM: .BYTE	0xF6            ; Clear carry (numeric)
      002C61 37               [ 4] 1922 TSTSTR: SCF                     ; Set carry (string)
      002C62 3A AD 42         [13] 1923 CHKTYP: LD      A,(TYPE)        ; Check types match
      002C65 8F               [ 4] 1924         ADC     A,A             ; Expected + actual
      002C66 B7               [ 4] 1925         OR      A               ; Clear carry , set parity
      002C67 E8               [11] 1926         RET     PE              ; Even parity - Types match
      002C68 C3 AA 23         [10] 1927         JP      TMERR           ; Different types - Error
                                   1928 
      002C6B CD 66 26         [17] 1929 OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
      002C6E 28                    1930         .BYTE   "("
      002C6F 2B               [ 6] 1931 EVAL:   DEC     HL              ; Evaluate expression & save
      002C70 16 00            [ 7] 1932         LD      D,#0            ; Precedence value
      002C72 D5               [11] 1933 EVAL1:  PUSH    DE              ; Save precedence
      002C73 0E 01            [ 7] 1934         LD      C,#1
      002C75 CD 75 23         [17] 1935         CALL    CHKSTK          ; Check for 1 level of stack
      002C78 CD E6 2C         [17] 1936         CALL    OPRND           ; Get next expression value
      002C7B 22 D0 42         [16] 1937 EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
      002C7E 2A D0 42         [16] 1938 EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
      002C81 C1               [10] 1939         POP     BC              ; Precedence value and operator
      002C82 78               [ 4] 1940         LD      A,B             ; Get precedence value
      002C83 FE 78            [ 7] 1941         CP      #0x78           ; "AND" or "OR" ?
      002C85 D4 60 2C         [17] 1942         CALL    NC,TSTNUM       ; No - Make sure it's a number
      002C88 7E               [ 7] 1943         LD      A,(HL)          ; Get next operator / function
      002C89 16 00            [ 7] 1944         LD      D,#0            ; Clear Last relation
      002C8B D6 B3            [ 7] 1945 RLTLP:  SUB     #ZGTR           ; ">" Token
      002C8D DA A7 2C         [10] 1946         JP      C,FOPRND        ; + - * / ^ AND OR - Test it
      002C90 FE 03            [ 7] 1947         CP      #ZLTH+1-ZGTR    ; < = >
      002C92 D2 A7 2C         [10] 1948         JP      NC,FOPRND       ; Function - Call it
      002C95 FE 01            [ 7] 1949         CP      #ZEQUAL-ZGTR    ; "="
      002C97 17               [ 4] 1950         RLA                     ; <- Test for legal
      002C98 AA               [ 4] 1951         XOR     D               ; <- combinations of < = >
      002C99 BA               [ 4] 1952         CP      D               ; <- by combining last token
      002C9A 57               [ 4] 1953         LD      D,A             ; <- with current one
      002C9B DA 98 23         [10] 1954         JP      C,SNERR         ; Error if "<<' '==" or ">>"
      002C9E 22 C5 42         [16] 1955         LD      (CUROPR),HL     ; Save address of current token
      002CA1 CD F0 27         [17] 1956         CALL    GETCHR          ; Get next character
      002CA4 C3 8B 2C         [10] 1957         JP      RLTLP           ; Treat the two as one
                                   1958 
      002CA7 7A               [ 4] 1959 FOPRND: LD      A,D             ; < = > found ?
      002CA8 B7               [ 4] 1960         OR      A
      002CA9 C2 CE 2D         [10] 1961         JP      NZ,TSTRED       ; Yes - Test for reduction
      002CAC 7E               [ 7] 1962         LD      A,(HL)          ; Get operator token
      002CAD 22 C5 42         [16] 1963         LD      (CUROPR),HL     ; Save operator address
      002CB0 D6 AC            [ 7] 1964         SUB     #ZPLUS          ; Operator or function?
      002CB2 D8               [11] 1965         RET     C               ; Neither - Exit
      002CB3 FE 07            [ 7] 1966         CP      #ZOR+1-ZPLUS    ; Is it + - * / ^ AND OR ?
      002CB5 D0               [11] 1967         RET     NC              ; No - Exit
      002CB6 5F               [ 4] 1968         LD      E,A             ; Coded operator
      002CB7 3A AD 42         [13] 1969         LD      A,(TYPE)        ; Get data type
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 37.
Hexadecimal [24-Bits]



      002CBA 3D               [ 4] 1970         DEC     A               ; FF = numeric , 00 = string
      002CBB B3               [ 4] 1971         OR      E               ; Combine with coded operator
      002CBC 7B               [ 4] 1972         LD      A,E             ; Get coded operator
      002CBD CA 2C 32         [10] 1973         JP      Z,CONCAT        ; String concatenation
      002CC0 07               [ 4] 1974         RLCA                    ; Times 2
      002CC1 83               [ 4] 1975         ADD     A,E             ; Times 3
      002CC2 5F               [ 4] 1976         LD      E,A             ; To DE (D is 0)
      002CC3 21 9F 22         [10] 1977         LD      HL,#PRITAB      ; Precedence table
      002CC6 19               [11] 1978         ADD     HL,DE           ; To the operator concerned
      002CC7 78               [ 4] 1979         LD      A,B             ; Last operator precedence
      002CC8 56               [ 7] 1980         LD      D,(HL)          ; Get evaluation precedence
      002CC9 BA               [ 4] 1981         CP      D               ; Compare with eval precedence
      002CCA D0               [11] 1982         RET     NC              ; Exit if higher precedence
      002CCB 23               [ 6] 1983         INC     HL              ; Point to routine address
      002CCC CD 60 2C         [17] 1984         CALL    TSTNUM          ; Make sure it's a number
                                   1985 
      002CCF C5               [11] 1986 STKTHS: PUSH    BC              ; Save last precedence & token
      002CD0 01 7E 2C         [10] 1987         LD      BC,#EVAL3       ; Where to go on prec' break
      002CD3 C5               [11] 1988         PUSH    BC              ; Save on stack for return
      002CD4 43               [ 4] 1989         LD      B,E             ; Save operator
      002CD5 4A               [ 4] 1990         LD      C,D             ; Save precedence
      002CD6 CD 70 36         [17] 1991         CALL    STAKFP          ; Move value to stack
      002CD9 58               [ 4] 1992         LD      E,B             ; Restore operator
      002CDA 51               [ 4] 1993         LD      D,C             ; Restore precedence
      002CDB 4E               [ 7] 1994         LD      C,(HL)          ; Get LSB of routine address
      002CDC 23               [ 6] 1995         INC     HL
      002CDD 46               [ 7] 1996         LD      B,(HL)          ; Get MSB of routine address
      002CDE 23               [ 6] 1997         INC     HL
      002CDF C5               [11] 1998         PUSH    BC              ; Save routine address
      002CE0 2A C5 42         [16] 1999         LD      HL,(CUROPR)     ; Address of current operator
      002CE3 C3 72 2C         [10] 2000         JP      EVAL1           ; Loop until prec' break
                                   2001 
      002CE6 AF               [ 4] 2002 OPRND:  XOR     A               ; Get operand routine
      002CE7 32 AD 42         [13] 2003         LD      (TYPE),A        ; Set numeric expected
      002CEA CD F0 27         [17] 2004         CALL    GETCHR          ; Get next character
      002CED 1E 24            [ 7] 2005         LD      E,#MO           ; ?MO Error
      002CEF CA AC 23         [10] 2006         JP      Z,ERROR         ; No operand - Error
      002CF2 DA 46 37         [10] 2007         JP      C,ASCTFP        ; Number - Get value
      002CF5 CD 8E 28         [17] 2008         CALL    CHKLTR          ; See if a letter
      002CF8 D2 4D 2D         [10] 2009         JP      NC,CONVAR       ; Letter - Find variable
      002CFB FE 26            [ 7] 2010         CP	#'&'		; &H = HEX, &B = BINARY
      002CFD 20 12            [12] 2011         JR	NZ, NOTAMP
      002CFF CD F0 27         [17] 2012         CALL    GETCHR          ; Get next character
      002D02 FE 48            [ 7] 2013         CP      #'H'            ; Hex number indicated? [function added]
      002D04 CA 8A 3B         [10] 2014         JP      Z,HEXTFP        ; Convert Hex to FPREG
      002D07 FE 42            [ 7] 2015         CP      #'B'            ; Binary number indicated? [function added]
      002D09 CA FA 3B         [10] 2016         JP      Z,BINTFP        ; Convert Bin to FPREG
      002D0C 1E 02            [ 7] 2017         LD      E,#SN           ; If neither then a ?SN Error
      002D0E CA AC 23         [10] 2018         JP      Z,ERROR         ; 
      002D11 FE AC            [ 7] 2019 NOTAMP: CP      #ZPLUS          ; '+' Token ?
      002D13 CA E6 2C         [10] 2020         JP      Z,OPRND         ; Yes - Look for operand
      002D16 FE 2E            [ 7] 2021         CP      #'.'            ; '.' ?
      002D18 CA 46 37         [10] 2022         JP      Z,ASCTFP        ; Yes - Create FP number
      002D1B FE AD            [ 7] 2023         CP      #ZMINUS         ; '-' Token ?
      002D1D CA 3C 2D         [10] 2024         JP      Z,MINUS         ; Yes - Do minus
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 38.
Hexadecimal [24-Bits]



      002D20 FE 22            [ 7] 2025         CP      #'"'            ; Literal string ?
      002D22 CA F5 30         [10] 2026         JP      Z,QTSTR         ; Get string terminated by '"'
      002D25 FE AA            [ 7] 2027         CP      #ZNOT           ; "NOT" Token ?
      002D27 CA 2E 2E         [10] 2028         JP      Z,EVNOT         ; Yes - Eval NOT expression
      002D2A FE A7            [ 7] 2029         CP      #ZFN            ; "FN" Token ?
      002D2C CA 59 30         [10] 2030         JP      Z,DOFN          ; Yes - Do FN routine
      002D2F D6 B6            [ 7] 2031         SUB     #ZSGN           ; Is it a function?
      002D31 D2 5E 2D         [10] 2032         JP      NC,FNOFST       ; Yes - Evaluate function
      002D34 CD 6B 2C         [17] 2033 EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
      002D37 CD 66 26         [17] 2034         CALL    CHKSYN          ; Make sure ")" follows
      002D3A 29                    2035         .BYTE   ")"
      002D3B C9               [10] 2036         RET
                                   2037 
      002D3C 16 7D            [ 7] 2038 MINUS:  LD      D,#0x7D         ; '-' precedence
      002D3E CD 72 2C         [17] 2039         CALL    EVAL1           ; Evaluate until prec' break
      002D41 2A D0 42         [16] 2040         LD      HL,(NXTOPR)     ; Get next operator address
      002D44 E5               [11] 2041         PUSH    HL              ; Save next operator address
      002D45 CD 68 36         [17] 2042         CALL    INVSGN          ; Negate value
      002D48 CD 60 2C         [17] 2043 RETNUM: CALL    TSTNUM          ; Make sure it's a number
      002D4B E1               [10] 2044         POP     HL              ; Restore next operator address
      002D4C C9               [10] 2045         RET
                                   2046 
      002D4D CD 53 2E         [17] 2047 CONVAR: CALL    GETVAR          ; Get variable address to DE
      002D50 E5               [11] 2048 FRMEVL: PUSH    HL              ; Save code string address
      002D51 EB               [ 4] 2049         EX      DE,HL           ; Variable address to HL
      002D52 22 E4 42         [16] 2050         LD      (FPREG),HL      ; Save address of variable
      002D55 3A AD 42         [13] 2051         LD      A,(TYPE)        ; Get type
      002D58 B7               [ 4] 2052         OR      A               ; Numeric?
      002D59 CC 7D 36         [17] 2053         CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
      002D5C E1               [10] 2054         POP     HL              ; Restore code string address
      002D5D C9               [10] 2055         RET
                                   2056 
      002D5E 06 00            [ 7] 2057 FNOFST: LD      B,#0            ; Get address of function
      002D60 07               [ 4] 2058         RLCA                    ; Double function offset
      002D61 4F               [ 4] 2059         LD      C,A             ; BC = Offset in function table
      002D62 C5               [11] 2060         PUSH    BC              ; Save adjusted token value
      002D63 CD F0 27         [17] 2061         CALL    GETCHR          ; Get next character
      002D66 79               [ 4] 2062         LD      A,C             ; Get adjusted token value
      002D67 FE 31            [ 7] 2063         CP      #2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
      002D69 DA 85 2D         [10] 2064         JP      C,FNVAL         ; No - Do function
      002D6C CD 6B 2C         [17] 2065         CALL    OPNPAR          ; Evaluate expression  (X,...
      002D6F CD 66 26         [17] 2066         CALL    CHKSYN          ; Make sure ',' follows
      002D72 2C                    2067         .BYTE      ','
      002D73 CD 61 2C         [17] 2068         CALL    TSTSTR          ; Make sure it's a string
      002D76 EB               [ 4] 2069         EX      DE,HL           ; Save code string address
      002D77 2A E4 42         [16] 2070         LD      HL,(FPREG)      ; Get address of string
      002D7A E3               [19] 2071         EX      (SP),HL         ; Save address of string
      002D7B E5               [11] 2072         PUSH    HL              ; Save adjusted token value
      002D7C EB               [ 4] 2073         EX      DE,HL           ; Restore code string address
      002D7D CD BE 33         [17] 2074         CALL    GETINT          ; Get integer 0-255
      002D80 EB               [ 4] 2075         EX      DE,HL           ; Save code string address
      002D81 E3               [19] 2076         EX      (SP),HL         ; Save integer,HL = adj' token
      002D82 C3 8D 2D         [10] 2077         JP      GOFUNC          ; Jump to string function
                                   2078 
      002D85 CD 34 2D         [17] 2079 FNVAL:  CALL    EVLPAR          ; Evaluate expression
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 39.
Hexadecimal [24-Bits]



      002D88 E3               [19] 2080         EX      (SP),HL         ; HL = Adjusted token value
      002D89 11 48 2D         [10] 2081         LD      DE,#RETNUM      ; Return number from function
      002D8C D5               [11] 2082         PUSH    DE              ; Save on stack
      002D8D 01 FE 20         [10] 2083 GOFUNC: LD      BC,#FNCTAB      ; Function routine addresses
      002D90 09               [11] 2084         ADD     HL,BC           ; Point to right address
      002D91 4E               [ 7] 2085         LD      C,(HL)          ; Get LSB of address
      002D92 23               [ 6] 2086         INC     HL              ;
      002D93 66               [ 7] 2087         LD      H,(HL)          ; Get MSB of address
      002D94 69               [ 4] 2088         LD      L,C             ; Address to HL
      002D95 E9               [ 4] 2089         JP      (HL)            ; Jump to function
                                   2090 
      002D96 15               [ 4] 2091 SGNEXP: DEC     D               ; Dee to flag negative exponent
      002D97 FE AD            [ 7] 2092         CP      #ZMINUS         ; '-' token ?
      002D99 C8               [11] 2093         RET     Z               ; Yes - Return
      002D9A FE 2D            [ 7] 2094         CP      #'-'            ; '-' ASCII ?
      002D9C C8               [11] 2095         RET     Z               ; Yes - Return
      002D9D 14               [ 4] 2096         INC     D               ; Inc to flag positive exponent
      002D9E FE 2B            [ 7] 2097         CP      #'+'            ; '+' ASCII ?
      002DA0 C8               [11] 2098         RET     Z               ; Yes - Return
      002DA1 FE AC            [ 7] 2099         CP      #ZPLUS          ; '+' token ?
      002DA3 C8               [11] 2100         RET     Z               ; Yes - Return
      002DA4 2B               [ 6] 2101         DEC     HL              ; DEC 'cos GETCHR INCs
      002DA5 C9               [10] 2102         RET                     ; Return "NZ"
                                   2103 
      002DA6 F6                    2104 POR:    .BYTE   0xF6            ; Flag "OR"
      002DA7 AF               [ 4] 2105 PAND:   XOR     A               ; Flag "AND"
      002DA8 F5               [11] 2106         PUSH    AF              ; Save "AND" / "OR" flag
      002DA9 CD 60 2C         [17] 2107         CALL    TSTNUM          ; Make sure it's a number
      002DAC CD A2 28         [17] 2108         CALL    DEINT           ; Get integer -32768 to 32767
      002DAF F1               [10] 2109         POP     AF              ; Restore "AND" / "OR" flag
      002DB0 EB               [ 4] 2110         EX      DE,HL           ; <- Get last
      002DB1 C1               [10] 2111         POP     BC              ; <-  value
      002DB2 E3               [19] 2112         EX      (SP),HL         ; <-  from
      002DB3 EB               [ 4] 2113         EX      DE,HL           ; <-  stack
      002DB4 CD 80 36         [17] 2114         CALL    FPBCDE          ; Move last value to FPREG
      002DB7 F5               [11] 2115         PUSH    AF              ; Save "AND" / "OR" flag
      002DB8 CD A2 28         [17] 2116         CALL    DEINT           ; Get integer -32768 to 32767
      002DBB F1               [10] 2117         POP     AF              ; Restore "AND" / "OR" flag
      002DBC C1               [10] 2118         POP     BC              ; Get value
      002DBD 79               [ 4] 2119         LD      A,C             ; Get LSB
      002DBE 21 17 30         [10] 2120         LD      HL,#ACPASS      ; Address of save AC as current
      002DC1 C2 C9 2D         [10] 2121         JP      NZ,POR1         ; Jump if OR
      002DC4 A3               [ 4] 2122         AND     E               ; "AND" LSBs
      002DC5 4F               [ 4] 2123         LD      C,A             ; Save LSB
      002DC6 78               [ 4] 2124         LD      A,B             ; Get MBS
      002DC7 A2               [ 4] 2125         AND     D               ; "AND" MSBs
      002DC8 E9               [ 4] 2126         JP      (HL)            ; Save AC as current (ACPASS)
                                   2127 
      002DC9 B3               [ 4] 2128 POR1:   OR      E               ; "OR" LSBs
      002DCA 4F               [ 4] 2129         LD      C,A             ; Save LSB
      002DCB 78               [ 4] 2130         LD      A,B             ; Get MSB
      002DCC B2               [ 4] 2131         OR      D               ; "OR" MSBs
      002DCD E9               [ 4] 2132         JP      (HL)            ; Save AC as current (ACPASS)
                                   2133 
      002DCE 21 E0 2D         [10] 2134 TSTRED: LD      HL,#CMPLOG      ; Logical compare routine
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 40.
Hexadecimal [24-Bits]



      002DD1 3A AD 42         [13] 2135         LD      A,(TYPE)        ; Get data type
      002DD4 1F               [ 4] 2136         RRA                     ; Carry set = string
      002DD5 7A               [ 4] 2137         LD      A,D             ; Get last precedence value
      002DD6 17               [ 4] 2138         RLA                     ; Times 2 plus carry
      002DD7 5F               [ 4] 2139         LD      E,A             ; To E
      002DD8 16 64            [ 7] 2140         LD      D,#0x64         ; Relational precedence
      002DDA 78               [ 4] 2141         LD      A,B             ; Get current precedence
      002DDB BA               [ 4] 2142         CP      D               ; Compare with last
      002DDC D0               [11] 2143         RET     NC              ; Eval if last was rel' or log'
      002DDD C3 CF 2C         [10] 2144         JP      STKTHS          ; Stack this one and get next
                                   2145 
      002DE0 E2 2D                 2146 CMPLOG: .WORD   CMPLG1          ; Compare two values / strings
      002DE2 79               [ 4] 2147 CMPLG1: LD      A,C             ; Get data type
      002DE3 B7               [ 4] 2148         OR      A
      002DE4 1F               [ 4] 2149         RRA
      002DE5 C1               [10] 2150         POP     BC              ; Get last expression to BCDE
      002DE6 D1               [10] 2151         POP     DE
      002DE7 F5               [11] 2152         PUSH    AF              ; Save status
      002DE8 CD 62 2C         [17] 2153         CALL    CHKTYP          ; Check that types match
      002DEB 21 24 2E         [10] 2154         LD      HL,#CMPRES      ; Result to comparison
      002DEE E5               [11] 2155         PUSH    HL              ; Save for RETurn
      002DEF CA BA 36         [10] 2156         JP      Z,CMPNUM        ; Compare values if numeric
      002DF2 AF               [ 4] 2157         XOR     A               ; Compare two strings
      002DF3 32 AD 42         [13] 2158         LD      (TYPE),A        ; Set type to numeric
      002DF6 D5               [11] 2159         PUSH    DE              ; Save string name
      002DF7 CD 79 32         [17] 2160         CALL    GSTRCU          ; Get current string
      002DFA 7E               [ 7] 2161         LD      A,(HL)          ; Get length of string
      002DFB 23               [ 6] 2162         INC     HL
      002DFC 23               [ 6] 2163         INC     HL
      002DFD 4E               [ 7] 2164         LD      C,(HL)          ; Get LSB of address
      002DFE 23               [ 6] 2165         INC     HL
      002DFF 46               [ 7] 2166         LD      B,(HL)          ; Get MSB of address
      002E00 D1               [10] 2167         POP     DE              ; Restore string name
      002E01 C5               [11] 2168         PUSH    BC              ; Save address of string
      002E02 F5               [11] 2169         PUSH    AF              ; Save length of string
      002E03 CD 7D 32         [17] 2170         CALL    GSTRDE          ; Get second string
      002E06 CD 8E 36         [17] 2171         CALL    LOADFP          ; Get address of second string
      002E09 F1               [10] 2172         POP     AF              ; Restore length of string 1
      002E0A 57               [ 4] 2173         LD      D,A             ; Length to D
      002E0B E1               [10] 2174         POP     HL              ; Restore address of string 1
      002E0C 7B               [ 4] 2175 CMPSTR: LD      A,E             ; Bytes of string 2 to do
      002E0D B2               [ 4] 2176         OR      D               ; Bytes of string 1 to do
      002E0E C8               [11] 2177         RET     Z               ; Exit if all bytes compared
      002E0F 7A               [ 4] 2178         LD      A,D             ; Get bytes of string 1 to do
      002E10 D6 01            [ 7] 2179         SUB     #1
      002E12 D8               [11] 2180         RET     C               ; Exit if end of string 1
      002E13 AF               [ 4] 2181         XOR     A
      002E14 BB               [ 4] 2182         CP      E               ; Bytes of string 2 to do
      002E15 3C               [ 4] 2183         INC     A
      002E16 D0               [11] 2184         RET     NC              ; Exit if end of string 2
      002E17 15               [ 4] 2185         DEC     D               ; Count bytes in string 1
      002E18 1D               [ 4] 2186         DEC     E               ; Count bytes in string 2
      002E19 0A               [ 7] 2187         LD      A,(BC)          ; Byte in string 2
      002E1A BE               [ 7] 2188         CP      (HL)            ; Compare to byte in string 1
      002E1B 23               [ 6] 2189         INC     HL              ; Move up string 1
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 41.
Hexadecimal [24-Bits]



      002E1C 03               [ 6] 2190         INC     BC              ; Move up string 2
      002E1D CA 0C 2E         [10] 2191         JP      Z,CMPSTR        ; Same - Try next bytes
      002E20 3F               [ 4] 2192         CCF                     ; Flag difference (">" or "<")
      002E21 C3 4A 36         [10] 2193         JP      FLGDIF          ; "<" gives -1 , ">" gives +1
                                   2194 
      002E24 3C               [ 4] 2195 CMPRES: INC     A               ; Increment current value
      002E25 8F               [ 4] 2196         ADC     A,A             ; Double plus carry
      002E26 C1               [10] 2197         POP     BC              ; Get other value
      002E27 A0               [ 4] 2198         AND     B               ; Combine them
      002E28 C6 FF            [ 7] 2199         ADD     A,#-1           ; Carry set if different
      002E2A 9F               [ 4] 2200         SBC     A,A             ; 00 - Equal , FF - Different
      002E2B C3 51 36         [10] 2201         JP      FLGREL          ; Set current value & continue
                                   2202 
      002E2E 16 5A            [ 7] 2203 EVNOT:  LD      D,#0x5A         ; Precedence value for "NOT"
      002E30 CD 72 2C         [17] 2204         CALL    EVAL1           ; Eval until precedence break
      002E33 CD 60 2C         [17] 2205         CALL    TSTNUM          ; Make sure it's a number
      002E36 CD A2 28         [17] 2206         CALL    DEINT           ; Get integer -32768 - 32767
      002E39 7B               [ 4] 2207         LD      A,E             ; Get LSB
      002E3A 2F               [ 4] 2208         CPL                     ; Invert LSB
      002E3B 4F               [ 4] 2209         LD      C,A             ; Save "NOT" of LSB
      002E3C 7A               [ 4] 2210         LD      A,D             ; Get MSB
      002E3D 2F               [ 4] 2211         CPL                     ; Invert MSB
      002E3E CD 17 30         [17] 2212         CALL    ACPASS          ; Save AC as current
      002E41 C1               [10] 2213         POP     BC              ; Clean up stack
      002E42 C3 7E 2C         [10] 2214         JP      EVAL3           ; Continue evaluation
                                   2215 
      002E45 2B               [ 6] 2216 DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
      002E46 CD F0 27         [17] 2217         CALL    GETCHR          ; Get next character
      002E49 C8               [11] 2218         RET     Z               ; End of DIM statement
      002E4A CD 66 26         [17] 2219         CALL    CHKSYN          ; Make sure ',' follows
      002E4D 2C                    2220         .BYTE      ','
      002E4E 01 45 2E         [10] 2221 DIM:    LD      BC,#DIMRET      ; Return to "DIMRET"
      002E51 C5               [11] 2222         PUSH    BC              ; Save on stack
      002E52 F6                    2223         .BYTE      0xF6         ; Flag "Create" variable
      002E53 AF               [ 4] 2224 GETVAR: XOR     A               ; Find variable address,to DE
      002E54 32 AC 42         [13] 2225         LD      (LCRFLG),A      ; Set locate / create flag
      002E57 46               [ 7] 2226         LD      B,(HL)          ; Get First byte of name
      002E58 CD 8E 28         [17] 2227 GTFNAM: CALL    CHKLTR          ; See if a letter
      002E5B DA 98 23         [10] 2228         JP      C,SNERR         ; ?SN Error if not a letter
      002E5E AF               [ 4] 2229         XOR     A
      002E5F 4F               [ 4] 2230         LD      C,A             ; Clear second byte of name
      002E60 32 AD 42         [13] 2231         LD      (TYPE),A        ; Set type to numeric
      002E63 CD F0 27         [17] 2232         CALL    GETCHR          ; Get next character
      002E66 DA 6F 2E         [10] 2233         JP      C,SVNAM2        ; Numeric - Save in name
      002E69 CD 8E 28         [17] 2234         CALL    CHKLTR          ; See if a letter
      002E6C DA 7C 2E         [10] 2235         JP      C,CHARTY        ; Not a letter - Check type
      002E6F 4F               [ 4] 2236 SVNAM2: LD      C,A             ; Save second byte of name
      002E70 CD F0 27         [17] 2237 ENDNAM: CALL    GETCHR          ; Get next character
      002E73 DA 70 2E         [10] 2238         JP      C,ENDNAM        ; Numeric - Get another
      002E76 CD 8E 28         [17] 2239         CALL    CHKLTR          ; See if a letter
      002E79 D2 70 2E         [10] 2240         JP      NC,ENDNAM       ; Letter - Get another
      002E7C D6 24            [ 7] 2241 CHARTY: SUB     #'$'            ; String variable?
      002E7E C2 8B 2E         [10] 2242         JP      NZ,NOTSTR       ; No - Numeric variable
      002E81 3C               [ 4] 2243         INC     A               ; A = 1 (string type)
      002E82 32 AD 42         [13] 2244         LD      (TYPE),A        ; Set type to string
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 42.
Hexadecimal [24-Bits]



      002E85 0F               [ 4] 2245         RRCA                    ; A = 80H , Flag for string
      002E86 81               [ 4] 2246         ADD     A,C             ; 2nd byte of name has bit 7 on
      002E87 4F               [ 4] 2247         LD      C,A             ; Resave second byte on name
      002E88 CD F0 27         [17] 2248         CALL    GETCHR          ; Get next character
      002E8B 3A CB 42         [13] 2249 NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
      002E8E 3D               [ 4] 2250         DEC     A
      002E8F CA 38 2F         [10] 2251         JP      Z,ARLDSV        ; Yes - Get array name
      002E92 F2 9B 2E         [10] 2252         JP      P,NSCFOR        ; No array with "FOR" or "FN"
      002E95 7E               [ 7] 2253         LD      A,(HL)          ; Get byte again
      002E96 D6 28            [ 7] 2254         SUB     #'('            ; Subscripted variable?
      002E98 CA 10 2F         [10] 2255         JP      Z,SBSCPT        ; Yes - Sort out subscript
                                   2256 
      002E9B AF               [ 4] 2257 NSCFOR: XOR     A               ; Simple variable
      002E9C 32 CB 42         [13] 2258         LD      (FORFLG),A      ; Clear "FOR" flag
      002E9F E5               [11] 2259         PUSH    HL              ; Save code string address
      002EA0 50               [ 4] 2260         LD      D,B             ; DE = Variable name to find
      002EA1 59               [ 4] 2261         LD      E,C
      002EA2 2A DE 42         [16] 2262         LD      HL,(FNRGNM)     ; FN argument name
      002EA5 CD 60 26         [17] 2263         CALL    CPDEHL          ; Is it the FN argument?
      002EA8 11 E0 42         [10] 2264         LD      DE,#FNARG       ; Point to argument value
      002EAB CA 80 35         [10] 2265         JP      Z,POPHRT        ; Yes - Return FN argument value
      002EAE 2A D8 42         [16] 2266         LD      HL,(VAREND)     ; End of variables
      002EB1 EB               [ 4] 2267         EX      DE,HL           ; Address of end of search
      002EB2 2A D6 42         [16] 2268         LD      HL,(PROGND)     ; Start of variables address
      002EB5 CD 60 26         [17] 2269 FNDVAR: CALL    CPDEHL          ; End of variable list table?
      002EB8 CA CE 2E         [10] 2270         JP      Z,CFEVAL        ; Yes - Called from EVAL?
      002EBB 79               [ 4] 2271         LD      A,C             ; Get second byte of name
      002EBC 96               [ 7] 2272         SUB     (HL)            ; Compare with name in list
      002EBD 23               [ 6] 2273         INC     HL              ; Move on to first byte
      002EBE C2 C3 2E         [10] 2274         JP      NZ,FNTHR        ; Different - Find another
      002EC1 78               [ 4] 2275         LD      A,B             ; Get first byte of name
      002EC2 96               [ 7] 2276         SUB     (HL)            ; Compare with name in list
      002EC3 23               [ 6] 2277 FNTHR:  INC     HL              ; Move on to LSB of value
      002EC4 CA 02 2F         [10] 2278         JP      Z,RETADR        ; Found - Return address
      002EC7 23               [ 6] 2279         INC     HL              ; <- Skip
      002EC8 23               [ 6] 2280         INC     HL              ; <- over
      002EC9 23               [ 6] 2281         INC     HL              ; <- F.P.
      002ECA 23               [ 6] 2282         INC     HL              ; <- value
      002ECB C3 B5 2E         [10] 2283         JP      FNDVAR          ; Keep looking
                                   2284 
      002ECE E1               [10] 2285 CFEVAL: POP     HL              ; Restore code string address
      002ECF E3               [19] 2286         EX      (SP),HL         ; Get return address
      002ED0 D5               [11] 2287         PUSH    DE              ; Save address of variable
      002ED1 11 50 2D         [10] 2288         LD      DE,#FRMEVL      ; Return address in EVAL
      002ED4 CD 60 26         [17] 2289         CALL    CPDEHL          ; Called from EVAL ?
      002ED7 D1               [10] 2290         POP     DE              ; Restore address of variable
      002ED8 CA 05 2F         [10] 2291         JP      Z,RETNUL        ; Yes - Return null variable
      002EDB E3               [19] 2292         EX      (SP),HL         ; Put back return
      002EDC E5               [11] 2293         PUSH    HL              ; Save code string address
      002EDD C5               [11] 2294         PUSH    BC              ; Save variable name
      002EDE 01 06 00         [10] 2295         LD      BC,#6           ; 2 byte name plus 4 byte data
      002EE1 2A DA 42         [16] 2296         LD      HL,(ARREND)     ; End of arrays
      002EE4 E5               [11] 2297         PUSH    HL              ; Save end of arrays
      002EE5 09               [11] 2298         ADD     HL,BC           ; Move up 6 bytes
      002EE6 C1               [10] 2299         POP     BC              ; Source address in BC
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 43.
Hexadecimal [24-Bits]



      002EE7 E5               [11] 2300         PUSH    HL              ; Save new end address
      002EE8 CD 64 23         [17] 2301         CALL    MOVUP           ; Move arrays up
      002EEB E1               [10] 2302         POP     HL              ; Restore new end address
      002EEC 22 DA 42         [16] 2303         LD      (ARREND),HL     ; Set new end address
      002EEF 60               [ 4] 2304         LD      H,B             ; End of variables to HL
      002EF0 69               [ 4] 2305         LD      L,C
      002EF1 22 D8 42         [16] 2306         LD      (VAREND),HL     ; Set new end address
                                   2307 
      002EF4 2B               [ 6] 2308 ZEROLP: DEC     HL              ; Back through to zero variable
      002EF5 36 00            [10] 2309         LD      (HL),#0         ; Zero byte in variable
      002EF7 CD 60 26         [17] 2310         CALL    CPDEHL          ; Done them all?
      002EFA C2 F4 2E         [10] 2311         JP      NZ,ZEROLP       ; No - Keep on going
      002EFD D1               [10] 2312         POP     DE              ; Get variable name
      002EFE 73               [ 7] 2313         LD      (HL),E          ; Store second character
      002EFF 23               [ 6] 2314         INC     HL
      002F00 72               [ 7] 2315         LD      (HL),D          ; Store first character
      002F01 23               [ 6] 2316         INC     HL
      002F02 EB               [ 4] 2317 RETADR: EX      DE,HL           ; Address of variable in DE
      002F03 E1               [10] 2318         POP     HL              ; Restore code string address
      002F04 C9               [10] 2319         RET
                                   2320 
      002F05 32 E7 42         [13] 2321 RETNUL: LD      (FPEXP),A       ; Set result to zero
      002F08 21 34 23         [10] 2322         LD      HL,#ZERBYT      ; Also set a null string
      002F0B 22 E4 42         [16] 2323         LD      (FPREG),HL      ; Save for EVAL
      002F0E E1               [10] 2324         POP     HL              ; Restore code string address
      002F0F C9               [10] 2325         RET
                                   2326 
      002F10 E5               [11] 2327 SBSCPT: PUSH    HL              ; Save code string address
      002F11 2A AC 42         [16] 2328         LD      HL,(LCRFLG)     ; Locate/Create and Type
      002F14 E3               [19] 2329         EX      (SP),HL         ; Save and get code string
      002F15 57               [ 4] 2330         LD      D,A             ; Zero number of dimensions
      002F16 D5               [11] 2331 SCPTLP: PUSH    DE              ; Save number of dimensions
      002F17 C5               [11] 2332         PUSH    BC              ; Save array name
      002F18 CD 96 28         [17] 2333         CALL    FPSINT          ; Get subscript (0-32767)
      002F1B C1               [10] 2334         POP     BC              ; Restore array name
      002F1C F1               [10] 2335         POP     AF              ; Get number of dimensions
      002F1D EB               [ 4] 2336         EX      DE,HL
      002F1E E3               [19] 2337         EX      (SP),HL         ; Save subscript value
      002F1F E5               [11] 2338         PUSH    HL              ; Save LCRFLG and TYPE
      002F20 EB               [ 4] 2339         EX      DE,HL
      002F21 3C               [ 4] 2340         INC     A               ; Count dimensions
      002F22 57               [ 4] 2341         LD      D,A             ; Save in D
      002F23 7E               [ 7] 2342         LD      A,(HL)          ; Get next byte in code string
      002F24 FE 2C            [ 7] 2343         CP      #','            ; Comma (more to come)?
      002F26 CA 16 2F         [10] 2344         JP      Z,SCPTLP        ; Yes - More subscripts
      002F29 CD 66 26         [17] 2345         CALL    CHKSYN          ; Make sure ")" follows
      002F2C 29                    2346         .BYTE      ")"
      002F2D 22 D0 42         [16] 2347         LD      (NXTOPR),HL     ; Save code string address
      002F30 E1               [10] 2348         POP     HL              ; Get LCRFLG and TYPE
      002F31 22 AC 42         [16] 2349         LD      (LCRFLG),HL     ; Restore Locate/create & type
      002F34 1E 00            [ 7] 2350         LD      E,#0            ; Flag not CSAVE* or CLOAD*
      002F36 D5               [11] 2351         PUSH    DE              ; Save number of dimensions (D)
      002F37 11                    2352         .BYTE      0x11         ; Skip "PUSH HL" and "PUSH AF'
                                   2353 
      002F38 E5               [11] 2354 ARLDSV: PUSH    HL              ; Save code string address
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 44.
Hexadecimal [24-Bits]



      002F39 F5               [11] 2355         PUSH    AF              ; A = 00 , Flags set = Z,N
      002F3A 2A D8 42         [16] 2356         LD      HL,(VAREND)     ; Start of arrays
      002F3D 3E                    2357         .BYTE      0x3E         ; Skip "ADD HL,DE"
      002F3E 19               [11] 2358 FNDARY: ADD     HL,DE           ; Move to next array start
      002F3F EB               [ 4] 2359         EX      DE,HL
      002F40 2A DA 42         [16] 2360         LD      HL,(ARREND)     ; End of arrays
      002F43 EB               [ 4] 2361         EX      DE,HL           ; Current array pointer
      002F44 CD 60 26         [17] 2362         CALL    CPDEHL          ; End of arrays found?
      002F47 CA 70 2F         [10] 2363         JP      Z,CREARY        ; Yes - Create array
      002F4A 7E               [ 7] 2364         LD      A,(HL)          ; Get second byte of name
      002F4B B9               [ 4] 2365         CP      C               ; Compare with name given
      002F4C 23               [ 6] 2366         INC     HL              ; Move on
      002F4D C2 52 2F         [10] 2367         JP      NZ,NXTARY       ; Different - Find next array
      002F50 7E               [ 7] 2368         LD      A,(HL)          ; Get first byte of name
      002F51 B8               [ 4] 2369         CP      B               ; Compare with name given
      002F52 23               [ 6] 2370 NXTARY: INC     HL              ; Move on
      002F53 5E               [ 7] 2371         LD      E,(HL)          ; Get LSB of next array address
      002F54 23               [ 6] 2372         INC     HL
      002F55 56               [ 7] 2373         LD      D,(HL)          ; Get MSB of next array address
      002F56 23               [ 6] 2374         INC     HL
      002F57 C2 3E 2F         [10] 2375         JP      NZ,FNDARY       ; Not found - Keep looking
      002F5A 3A AC 42         [13] 2376         LD      A,(LCRFLG)      ; Found Locate or Create it?
      002F5D B7               [ 4] 2377         OR      A
      002F5E C2 A1 23         [10] 2378         JP      NZ,DDERR        ; Create - ?DD Error
      002F61 F1               [10] 2379         POP     AF              ; Locate - Get number of dim'ns
      002F62 44               [ 4] 2380         LD      B,H             ; BC Points to array dim'ns
      002F63 4D               [ 4] 2381         LD      C,L
      002F64 CA 80 35         [10] 2382         JP      Z,POPHRT        ; Jump if array load/save
      002F67 96               [ 7] 2383         SUB     (HL)            ; Same number of dimensions?
      002F68 CA CE 2F         [10] 2384         JP      Z,FINDEL        ; Yes - Find element
      002F6B 1E 10            [ 7] 2385 BSERR:  LD      E,#BS           ; ?BS Error
      002F6D C3 AC 23         [10] 2386         JP      ERROR           ; Output error
                                   2387 
      002F70 11 04 00         [10] 2388 CREARY: LD      DE,#4           ; 4 Bytes per entry
      002F73 F1               [10] 2389         POP     AF              ; Array to save or 0 dim'ns?
      002F74 CA B7 28         [10] 2390         JP      Z,FCERR         ; Yes - ?FC Error
      002F77 71               [ 7] 2391         LD      (HL),C          ; Save second byte of name
      002F78 23               [ 6] 2392         INC     HL
      002F79 70               [ 7] 2393         LD      (HL),B          ; Save first byte of name
      002F7A 23               [ 6] 2394         INC     HL
      002F7B 4F               [ 4] 2395         LD      C,A             ; Number of dimensions to C
      002F7C CD 75 23         [17] 2396         CALL    CHKSTK          ; Check if enough memory
      002F7F 23               [ 6] 2397         INC     HL              ; Point to number of dimensions
      002F80 23               [ 6] 2398         INC     HL
      002F81 22 C5 42         [16] 2399         LD      (CUROPR),HL     ; Save address of pointer
      002F84 71               [ 7] 2400         LD      (HL),C          ; Set number of dimensions
      002F85 23               [ 6] 2401         INC     HL
      002F86 3A AC 42         [13] 2402         LD      A,(LCRFLG)      ; Locate of Create?
      002F89 17               [ 4] 2403         RLA                     ; Carry set = Create
      002F8A 79               [ 4] 2404         LD      A,C             ; Get number of dimensions
      002F8B 01 0B 00         [10] 2405 CRARLP: LD      BC,#10+1        ; Default dimension size 10
      002F8E D2 93 2F         [10] 2406         JP      NC,DEFSIZ       ; Locate - Set default size
      002F91 C1               [10] 2407         POP     BC              ; Get specified dimension size
      002F92 03               [ 6] 2408         INC     BC              ; Include zero element
      002F93 71               [ 7] 2409 DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 45.
Hexadecimal [24-Bits]



      002F94 23               [ 6] 2410         INC     HL
      002F95 70               [ 7] 2411         LD      (HL),B          ; Save MSB of dimension size
      002F96 23               [ 6] 2412         INC     HL
      002F97 F5               [11] 2413         PUSH    AF              ; Save num' of dim'ns an status
      002F98 E5               [11] 2414         PUSH    HL              ; Save address of dim'n size
      002F99 CD 2B 37         [17] 2415         CALL    MLDEBC          ; Multiply DE by BC to find
      002F9C EB               [ 4] 2416         EX      DE,HL           ; amount of mem needed (to DE)
      002F9D E1               [10] 2417         POP     HL              ; Restore address of dimension
      002F9E F1               [10] 2418         POP     AF              ; Restore number of dimensions
      002F9F 3D               [ 4] 2419         DEC     A               ; Count them
      002FA0 C2 8B 2F         [10] 2420         JP      NZ,CRARLP       ; Do next dimension if more
      002FA3 F5               [11] 2421         PUSH    AF              ; Save locate/create flag
      002FA4 42               [ 4] 2422         LD      B,D             ; MSB of memory needed
      002FA5 4B               [ 4] 2423         LD      C,E             ; LSB of memory needed
      002FA6 EB               [ 4] 2424         EX      DE,HL
      002FA7 19               [11] 2425         ADD     HL,DE           ; Add bytes to array start
      002FA8 DA 8D 23         [10] 2426         JP      C,OMERR         ; Too big - Error
      002FAB CD 7E 23         [17] 2427         CALL    ENFMEM          ; See if enough memory
      002FAE 22 DA 42         [16] 2428         LD      (ARREND),HL     ; Save new end of array
                                   2429 
      002FB1 2B               [ 6] 2430 ZERARY: DEC     HL              ; Back through array data
      002FB2 36 00            [10] 2431         LD      (HL),#0         ; Set array element to zero
      002FB4 CD 60 26         [17] 2432         CALL    CPDEHL          ; All elements zeroed?
      002FB7 C2 B1 2F         [10] 2433         JP      NZ,ZERARY       ; No - Keep on going
      002FBA 03               [ 6] 2434         INC     BC              ; Number of bytes + 1
      002FBB 57               [ 4] 2435         LD      D,A             ; A=0
      002FBC 2A C5 42         [16] 2436         LD      HL,(CUROPR)     ; Get address of array
      002FBF 5E               [ 7] 2437         LD      E,(HL)          ; Number of dimensions
      002FC0 EB               [ 4] 2438         EX      DE,HL           ; To HL
      002FC1 29               [11] 2439         ADD     HL,HL           ; Two bytes per dimension size
      002FC2 09               [11] 2440         ADD     HL,BC           ; Add number of bytes
      002FC3 EB               [ 4] 2441         EX      DE,HL           ; Bytes needed to DE
      002FC4 2B               [ 6] 2442         DEC     HL
      002FC5 2B               [ 6] 2443         DEC     HL
      002FC6 73               [ 7] 2444         LD      (HL),E          ; Save LSB of bytes needed
      002FC7 23               [ 6] 2445         INC     HL
      002FC8 72               [ 7] 2446         LD      (HL),D          ; Save MSB of bytes needed
      002FC9 23               [ 6] 2447         INC     HL
      002FCA F1               [10] 2448         POP     AF              ; Locate / Create?
      002FCB DA F2 2F         [10] 2449         JP      C,ENDDIM        ; A is 0 , End if create
      002FCE 47               [ 4] 2450 FINDEL: LD      B,A             ; Find array element
      002FCF 4F               [ 4] 2451         LD      C,A
      002FD0 7E               [ 7] 2452         LD      A,(HL)          ; Number of dimensions
      002FD1 23               [ 6] 2453         INC     HL
      002FD2 16                    2454         .BYTE      0x16         ; Skip "POP HL"
      002FD3 E1               [10] 2455 FNDELP: POP     HL              ; Address of next dim' size
      002FD4 5E               [ 7] 2456         LD      E,(HL)          ; Get LSB of dim'n size
      002FD5 23               [ 6] 2457         INC     HL
      002FD6 56               [ 7] 2458         LD      D,(HL)          ; Get MSB of dim'n size
      002FD7 23               [ 6] 2459         INC     HL
      002FD8 E3               [19] 2460         EX      (SP),HL         ; Save address - Get index
      002FD9 F5               [11] 2461         PUSH    AF              ; Save number of dim'ns
      002FDA CD 60 26         [17] 2462         CALL    CPDEHL          ; Dimension too large?
      002FDD D2 6B 2F         [10] 2463         JP      NC,BSERR        ; Yes - ?BS Error
      002FE0 E5               [11] 2464         PUSH    HL              ; Save index
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 46.
Hexadecimal [24-Bits]



      002FE1 CD 2B 37         [17] 2465         CALL    MLDEBC          ; Multiply previous by size
      002FE4 D1               [10] 2466         POP     DE              ; Index supplied to DE
      002FE5 19               [11] 2467         ADD     HL,DE           ; Add index to pointer
      002FE6 F1               [10] 2468         POP     AF              ; Number of dimensions
      002FE7 3D               [ 4] 2469         DEC     A               ; Count them
      002FE8 44               [ 4] 2470         LD      B,H             ; MSB of pointer
      002FE9 4D               [ 4] 2471         LD      C,L             ; LSB of pointer
      002FEA C2 D3 2F         [10] 2472         JP      NZ,FNDELP       ; More - Keep going
      002FED 29               [11] 2473         ADD     HL,HL           ; 4 Bytes per element
      002FEE 29               [11] 2474         ADD     HL,HL
      002FEF C1               [10] 2475         POP     BC              ; Start of array
      002FF0 09               [11] 2476         ADD     HL,BC           ; Point to element
      002FF1 EB               [ 4] 2477         EX      DE,HL           ; Address of element to DE
      002FF2 2A D0 42         [16] 2478 ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
      002FF5 C9               [10] 2479         RET
                                   2480 
      002FF6 2A DA 42         [16] 2481 FRE:    LD      HL,(ARREND)     ; Start of free memory
      002FF9 EB               [ 4] 2482         EX      DE,HL           ; To DE
      002FFA 21 00 00         [10] 2483         LD      HL,#0           ; End of free memory
      002FFD 39               [11] 2484         ADD     HL,SP           ; Current stack value
      002FFE 3A AD 42         [13] 2485         LD      A,(TYPE)        ; Dummy argument type
      003001 B7               [ 4] 2486         OR      A
      003002 CA 12 30         [10] 2487         JP      Z,FRENUM        ; Numeric - Free variable space
      003005 CD 79 32         [17] 2488         CALL    GSTRCU          ; Current string to pool
      003008 CD 79 31         [17] 2489         CALL    GARBGE          ; Garbage collection
      00300B 2A 5A 42         [16] 2490         LD      HL,(STRSPC)     ; Bottom of string space in use
      00300E EB               [ 4] 2491         EX      DE,HL           ; To DE
      00300F 2A C3 42         [16] 2492         LD      HL,(STRBOT)     ; Bottom of string space
      003012 7D               [ 4] 2493 FRENUM: LD      A,L             ; Get LSB of end
      003013 93               [ 4] 2494         SUB     E               ; Subtract LSB of beginning
      003014 4F               [ 4] 2495         LD      C,A             ; Save difference if C
      003015 7C               [ 4] 2496         LD      A,H             ; Get MSB of end
      003016 9A               [ 4] 2497         SBC     A,D             ; Subtract MSB of beginning
      003017 41               [ 4] 2498 ACPASS: LD      B,C             ; Return integer AC
      003018 50               [ 4] 2499 ABPASS: LD      D,B             ; Return integer AB
      003019 1E 00            [ 7] 2500         LD      E,#0
      00301B 21 AD 42         [10] 2501         LD      HL,#TYPE        ; Point to type
      00301E 73               [ 7] 2502         LD      (HL),E          ; Set type to numeric
      00301F 06 90            [ 7] 2503         LD      B,#0x80+16       ; 16 bit integer
      003021 C3 56 36         [10] 2504         JP      RETINT          ; Return the integr
                                   2505 
      003024 3A AB 42         [13] 2506 POS:    LD      A,(CURPOS)      ; Get cursor position
      003027 47               [ 4] 2507 PASSA:  LD      B,A             ; Put A into AB
      003028 AF               [ 4] 2508         XOR     A               ; Zero A
      003029 C3 18 30         [10] 2509         JP      ABPASS          ; Return integer AB
                                   2510 
      00302C CD AF 30         [17] 2511 DEF:    CALL    CHEKFN          ; Get "FN" and name
      00302F CD A1 30         [17] 2512         CALL    IDTEST          ; Test for illegal direct
      003032 01 87 29         [10] 2513         LD      BC,#DATA        ; To get next statement
      003035 C5               [11] 2514         PUSH    BC              ; Save address for RETurn
      003036 D5               [11] 2515         PUSH    DE              ; Save address of function ptr
      003037 CD 66 26         [17] 2516         CALL    CHKSYN          ; Make sure "(" follows
      00303A 28                    2517         .BYTE      "("
      00303B CD 53 2E         [17] 2518         CALL    GETVAR          ; Get argument variable name
      00303E E5               [11] 2519         PUSH    HL              ; Save code string address
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 47.
Hexadecimal [24-Bits]



      00303F EB               [ 4] 2520         EX      DE,HL           ; Argument address to HL
      003040 2B               [ 6] 2521         DEC     HL
      003041 56               [ 7] 2522         LD      D,(HL)          ; Get first byte of arg name
      003042 2B               [ 6] 2523         DEC     HL
      003043 5E               [ 7] 2524         LD      E,(HL)          ; Get second byte of arg name
      003044 E1               [10] 2525         POP     HL              ; Restore code string address
      003045 CD 60 2C         [17] 2526         CALL    TSTNUM          ; Make sure numeric argument
      003048 CD 66 26         [17] 2527         CALL    CHKSYN          ; Make sure ")" follows
      00304B 29                    2528         .BYTE      ")"
      00304C CD 66 26         [17] 2529         CALL    CHKSYN          ; Make sure "=" follows
      00304F B4                    2530         .BYTE      ZEQUAL          ; "=" token
      003050 44               [ 4] 2531         LD      B,H             ; Code string address to BC
      003051 4D               [ 4] 2532         LD      C,L
      003052 E3               [19] 2533         EX      (SP),HL         ; Save code str , Get FN ptr
      003053 71               [ 7] 2534         LD      (HL),C          ; Save LSB of FN code string
      003054 23               [ 6] 2535         INC     HL
      003055 70               [ 7] 2536         LD      (HL),B          ; Save MSB of FN code string
      003056 C3 EE 30         [10] 2537         JP      SVSTAD          ; Save address and do function
                                   2538 
      003059 CD AF 30         [17] 2539 DOFN:   CALL    CHEKFN          ; Make sure FN follows
      00305C D5               [11] 2540         PUSH    DE              ; Save function pointer address
      00305D CD 34 2D         [17] 2541         CALL    EVLPAR          ; Evaluate expression in "()"
      003060 CD 60 2C         [17] 2542         CALL    TSTNUM          ; Make sure numeric result
      003063 E3               [19] 2543         EX      (SP),HL         ; Save code str , Get FN ptr
      003064 5E               [ 7] 2544         LD      E,(HL)          ; Get LSB of FN code string
      003065 23               [ 6] 2545         INC     HL
      003066 56               [ 7] 2546         LD      D,(HL)          ; Get MSB of FN code string
      003067 23               [ 6] 2547         INC     HL
      003068 7A               [ 4] 2548         LD      A,D             ; And function DEFined?
      003069 B3               [ 4] 2549         OR      E
      00306A CA A4 23         [10] 2550         JP      Z,UFERR         ; No - ?UF Error
      00306D 7E               [ 7] 2551         LD      A,(HL)          ; Get LSB of argument address
      00306E 23               [ 6] 2552         INC     HL
      00306F 66               [ 7] 2553         LD      H,(HL)          ; Get MSB of argument address
      003070 6F               [ 4] 2554         LD      L,A             ; HL = Arg variable address
      003071 E5               [11] 2555         PUSH    HL              ; Save it
      003072 2A DE 42         [16] 2556         LD      HL,(FNRGNM)     ; Get old argument name
      003075 E3               [19] 2557         EX      (SP),HL ;       ; Save old , Get new
      003076 22 DE 42         [16] 2558         LD      (FNRGNM),HL     ; Set new argument name
      003079 2A E2 42         [16] 2559         LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
      00307C E5               [11] 2560         PUSH    HL              ; Save it
      00307D 2A E0 42         [16] 2561         LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
      003080 E5               [11] 2562         PUSH    HL              ; Save it
      003081 21 E0 42         [10] 2563         LD      HL,#FNARG       ; HL = Value of argument
      003084 D5               [11] 2564         PUSH    DE              ; Save FN code string address
      003085 CD 97 36         [17] 2565         CALL    FPTHL           ; Move FPREG to argument
      003088 E1               [10] 2566         POP     HL              ; Get FN code string address
      003089 CD 5D 2C         [17] 2567         CALL    GETNUM          ; Get value from function
      00308C 2B               [ 6] 2568         DEC     HL              ; DEC 'cos GETCHR INCs
      00308D CD F0 27         [17] 2569         CALL    GETCHR          ; Get next character
      003090 C2 98 23         [10] 2570         JP      NZ,SNERR        ; Bad character in FN - Error
      003093 E1               [10] 2571         POP     HL              ; Get MSB,EXP of old arg
      003094 22 E0 42         [16] 2572         LD      (FNARG),HL      ; Restore it
      003097 E1               [10] 2573         POP     HL              ; Get LSB,NLSB of old arg
      003098 22 E2 42         [16] 2574         LD      (FNARG+2),HL    ; Restore it
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 48.
Hexadecimal [24-Bits]



      00309B E1               [10] 2575         POP     HL              ; Get name of old arg
      00309C 22 DE 42         [16] 2576         LD      (FNRGNM),HL     ; Restore it
      00309F E1               [10] 2577         POP     HL              ; Restore code string address
      0030A0 C9               [10] 2578         RET
                                   2579 
      0030A1 E5               [11] 2580 IDTEST: PUSH    HL              ; Save code string address
      0030A2 2A 5C 42         [16] 2581         LD      HL,(LINEAT)     ; Get current line number
      0030A5 23               [ 6] 2582         INC     HL              ; -1 means direct statement
      0030A6 7C               [ 4] 2583         LD      A,H
      0030A7 B5               [ 4] 2584         OR      L
      0030A8 E1               [10] 2585         POP     HL              ; Restore code string address
      0030A9 C0               [11] 2586         RET     NZ              ; Return if in program
      0030AA 1E 16            [ 7] 2587         LD      E,#ID           ; ?ID Error
      0030AC C3 AC 23         [10] 2588         JP      ERROR
                                   2589 
      0030AF CD 66 26         [17] 2590 CHEKFN: CALL    CHKSYN          ; Make sure FN follows
      0030B2 A7                    2591         .BYTE      ZFN             ; "FN" token
      0030B3 3E 80            [ 7] 2592         LD      A,#0x80
      0030B5 32 CB 42         [13] 2593         LD      (FORFLG),A      ; Flag FN name to find
      0030B8 B6               [ 7] 2594         OR      (HL)            ; FN name has bit 7 set
      0030B9 47               [ 4] 2595         LD      B,A             ; in first byte of name
      0030BA CD 58 2E         [17] 2596         CALL    GTFNAM          ; Get FN name
      0030BD C3 60 2C         [10] 2597         JP      TSTNUM          ; Make sure numeric function
                                   2598 
      0030C0 CD 60 2C         [17] 2599 STR:    CALL    TSTNUM          ; Make sure it's a number
      0030C3 CD E4 37         [17] 2600         CALL    NUMASC          ; Turn number into text
      0030C6 CD F4 30         [17] 2601 STR1:   CALL    CRTST           ; Create string entry for it
      0030C9 CD 79 32         [17] 2602         CALL    GSTRCU          ; Current string to pool
      0030CC 01 D4 32         [10] 2603         LD      BC,#TOPOOL      ; Save in string pool
      0030CF C5               [11] 2604         PUSH    BC              ; Save address on stack
                                   2605 
      0030D0 7E               [ 7] 2606 SAVSTR: LD      A,(HL)          ; Get string length
      0030D1 23               [ 6] 2607         INC     HL
      0030D2 23               [ 6] 2608         INC     HL
      0030D3 E5               [11] 2609         PUSH    HL              ; Save pointer to string
      0030D4 CD 4F 31         [17] 2610         CALL    TESTR           ; See if enough string space
      0030D7 E1               [10] 2611         POP     HL              ; Restore pointer to string
      0030D8 4E               [ 7] 2612         LD      C,(HL)          ; Get LSB of address
      0030D9 23               [ 6] 2613         INC     HL
      0030DA 46               [ 7] 2614         LD      B,(HL)          ; Get MSB of address
      0030DB CD E8 30         [17] 2615         CALL    CRTMST          ; Create string entry
      0030DE E5               [11] 2616         PUSH    HL              ; Save pointer to MSB of addr
      0030DF 6F               [ 4] 2617         LD      L,A             ; Length of string
      0030E0 CD 6C 32         [17] 2618         CALL    TOSTRA          ; Move to string area
      0030E3 D1               [10] 2619         POP     DE              ; Restore pointer to MSB
      0030E4 C9               [10] 2620         RET
                                   2621 
      0030E5 CD 4F 31         [17] 2622 MKTMST: CALL    TESTR           ; See if enough string space
      0030E8 21 BF 42         [10] 2623 CRTMST: LD      HL,#TMPSTR      ; Temporary string
      0030EB E5               [11] 2624         PUSH    HL              ; Save it
      0030EC 77               [ 7] 2625         LD      (HL),A          ; Save length of string
      0030ED 23               [ 6] 2626         INC     HL
      0030EE 23               [ 6] 2627 SVSTAD: INC     HL
      0030EF 73               [ 7] 2628         LD      (HL),E          ; Save LSB of address
      0030F0 23               [ 6] 2629         INC     HL
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 49.
Hexadecimal [24-Bits]



      0030F1 72               [ 7] 2630         LD      (HL),D          ; Save MSB of address
      0030F2 E1               [10] 2631         POP     HL              ; Restore pointer
      0030F3 C9               [10] 2632         RET
                                   2633 
      0030F4 2B               [ 6] 2634 CRTST:  DEC     HL              ; DEC - INCed after
      0030F5 06 22            [ 7] 2635 QTSTR:  LD      B,#'"'          ; Terminating quote
      0030F7 50               [ 4] 2636         LD      D,B             ; Quote to D
      0030F8 E5               [11] 2637 DTSTR:  PUSH    HL              ; Save start
      0030F9 0E FF            [ 7] 2638         LD      C,#-1           ; Set counter to -1
      0030FB 23               [ 6] 2639 QTSTLP: INC     HL              ; Move on
      0030FC 7E               [ 7] 2640         LD      A,(HL)          ; Get byte
      0030FD 0C               [ 4] 2641         INC     C               ; Count bytes
      0030FE B7               [ 4] 2642         OR      A               ; End of line?
      0030FF CA 0A 31         [10] 2643         JP      Z,CRTSTE        ; Yes - Create string entry
      003102 BA               [ 4] 2644         CP      D               ; Terminator D found?
      003103 CA 0A 31         [10] 2645         JP      Z,CRTSTE        ; Yes - Create string entry
      003106 B8               [ 4] 2646         CP      B               ; Terminator B found?
      003107 C2 FB 30         [10] 2647         JP      NZ,QTSTLP       ; No - Keep looking
      00310A FE 22            [ 7] 2648 CRTSTE: CP      #'"'            ; End with '"'?
      00310C CC F0 27         [17] 2649         CALL    Z,GETCHR        ; Yes - Get next character
      00310F E3               [19] 2650         EX      (SP),HL         ; Starting quote
      003110 23               [ 6] 2651         INC     HL              ; First byte of string
      003111 EB               [ 4] 2652         EX      DE,HL           ; To DE
      003112 79               [ 4] 2653         LD      A,C             ; Get length
      003113 CD E8 30         [17] 2654         CALL    CRTMST          ; Create string entry
      003116 11 BF 42         [10] 2655 TSTOPL: LD      DE,#TMPSTR      ; Temporary string
      003119 2A B1 42         [16] 2656         LD      HL,(TMSTPT)     ; Temporary string pool pointer
      00311C 22 E4 42         [16] 2657         LD      (FPREG),HL      ; Save address of string ptr
      00311F 3E 01            [ 7] 2658         LD      A,#1
      003121 32 AD 42         [13] 2659         LD      (TYPE),A        ; Set type to string
      003124 CD 9A 36         [17] 2660         CALL    DETHL4          ; Move string to pool
      003127 CD 60 26         [17] 2661         CALL    CPDEHL          ; Out of string pool?
      00312A 22 B1 42         [16] 2662         LD      (TMSTPT),HL     ; Save new pointer
      00312D E1               [10] 2663         POP     HL              ; Restore code string address
      00312E 7E               [ 7] 2664         LD      A,(HL)          ; Get next code byte
      00312F C0               [11] 2665         RET     NZ              ; Return if pool OK
      003130 1E 1E            [ 7] 2666         LD      E,#ST           ; ?ST Error
      003132 C3 AC 23         [10] 2667         JP      ERROR           ; String pool overflow
                                   2668 
      003135 23               [ 6] 2669 PRNUMS: INC     HL              ; Skip leading space
      003136 CD F4 30         [17] 2670 PRS:    CALL    CRTST           ; Create string entry for it
      003139 CD 79 32         [17] 2671 PRS1:   CALL    GSTRCU          ; Current string to pool
      00313C CD 8E 36         [17] 2672         CALL    LOADFP          ; Move string block to BCDE
      00313F 1C               [ 4] 2673         INC     E               ; Length + 1
      003140 1D               [ 4] 2674 PRSLP:  DEC     E               ; Count characters
      003141 C8               [11] 2675         RET     Z               ; End of string
      003142 0A               [ 7] 2676         LD      A,(BC)          ; Get byte to output
      003143 CD 71 26         [17] 2677         CALL    OUTC            ; Output character in A
      003146 FE 0D            [ 7] 2678         CP      #CR             ; Return?
      003148 CC A2 2A         [17] 2679         CALL    Z,DONULL        ; Yes - Do nulls
      00314B 03               [ 6] 2680         INC     BC              ; Next byte in string
      00314C C3 40 31         [10] 2681         JP      PRSLP           ; More characters to output
                                   2682 
      00314F B7               [ 4] 2683 TESTR:  OR      A               ; Test if enough room
      003150 0E                    2684         .BYTE      0x0E         ; No garbage collection done
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 50.
Hexadecimal [24-Bits]



      003151 F1               [10] 2685 GRBDON: POP     AF              ; Garbage collection done
      003152 F5               [11] 2686         PUSH    AF              ; Save status
      003153 2A 5A 42         [16] 2687         LD      HL,(STRSPC)     ; Bottom of string space in use
      003156 EB               [ 4] 2688         EX      DE,HL           ; To DE
      003157 2A C3 42         [16] 2689         LD      HL,(STRBOT)     ; Bottom of string area
      00315A 2F               [ 4] 2690         CPL                     ; Negate length (Top down)
      00315B 4F               [ 4] 2691         LD      C,A             ; -Length to BC
      00315C 06 FF            [ 7] 2692         LD      B,#-1           ; BC = -ve length of string
      00315E 09               [11] 2693         ADD     HL,BC           ; Add to bottom of space in use
      00315F 23               [ 6] 2694         INC     HL              ; Plus one for 2's complement
      003160 CD 60 26         [17] 2695         CALL    CPDEHL          ; Below string RAM area?
      003163 DA 6D 31         [10] 2696         JP      C,TESTOS        ; Tidy up if not done else err
      003166 22 C3 42         [16] 2697         LD      (STRBOT),HL     ; Save new bottom of area
      003169 23               [ 6] 2698         INC     HL              ; Point to first byte of string
      00316A EB               [ 4] 2699         EX      DE,HL           ; Address to DE
      00316B F1               [10] 2700 POPAF:  POP     AF              ; Throw away status push
      00316C C9               [10] 2701         RET
                                   2702 
      00316D F1               [10] 2703 TESTOS: POP     AF              ; Garbage collect been done?
      00316E 1E 1A            [ 7] 2704         LD      E,#OS           ; ?OS Error
      003170 CA AC 23         [10] 2705         JP      Z,ERROR         ; Yes - Not enough string apace
      003173 BF               [ 4] 2706         CP      A               ; Flag garbage collect done
      003174 F5               [11] 2707         PUSH    AF              ; Save status
      003175 01 51 31         [10] 2708         LD      BC,#GRBDON      ; Garbage collection done
      003178 C5               [11] 2709         PUSH    BC              ; Save for RETurn
      003179 2A AF 42         [16] 2710 GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
      00317C 22 C3 42         [16] 2711 GARBLP: LD      (STRBOT),HL     ; Reset string pointer
      00317F 21 00 00         [10] 2712         LD      HL,#0
      003182 E5               [11] 2713         PUSH    HL              ; Flag no string found
      003183 2A 5A 42         [16] 2714         LD      HL,(STRSPC)     ; Get bottom of string space
      003186 E5               [11] 2715         PUSH    HL              ; Save bottom of string space
      003187 21 B3 42         [10] 2716         LD      HL,#TMSTPL      ; Temporary string pool
      00318A EB               [ 4] 2717 GRBLP:  EX      DE,HL
      00318B 2A B1 42         [16] 2718         LD      HL,(TMSTPT)     ; Temporary string pool pointer
      00318E EB               [ 4] 2719         EX      DE,HL
      00318F CD 60 26         [17] 2720         CALL    CPDEHL          ; Temporary string pool done?
      003192 01 8A 31         [10] 2721         LD      BC,#GRBLP       ; Loop until string pool done
      003195 C2 DE 31         [10] 2722         JP      NZ,STPOOL       ; No - See if in string area
      003198 2A D6 42         [16] 2723         LD      HL,(PROGND)     ; Start of simple variables
      00319B EB               [ 4] 2724 SMPVAR: EX      DE,HL
      00319C 2A D8 42         [16] 2725         LD      HL,(VAREND)     ; End of simple variables
      00319F EB               [ 4] 2726         EX      DE,HL
      0031A0 CD 60 26         [17] 2727         CALL    CPDEHL          ; All simple strings done?
      0031A3 CA B1 31         [10] 2728         JP      Z,ARRLP         ; Yes - Do string arrays
      0031A6 7E               [ 7] 2729         LD      A,(HL)          ; Get type of variable
      0031A7 23               [ 6] 2730         INC     HL
      0031A8 23               [ 6] 2731         INC     HL
      0031A9 B7               [ 4] 2732         OR      A               ; "S" flag set if string
      0031AA CD E1 31         [17] 2733         CALL    STRADD          ; See if string in string area
      0031AD C3 9B 31         [10] 2734         JP      SMPVAR          ; Loop until simple ones done
                                   2735 
      0031B0 C1               [10] 2736 GNXARY: POP     BC              ; Scrap address of this array
      0031B1 EB               [ 4] 2737 ARRLP:  EX      DE,HL
      0031B2 2A DA 42         [16] 2738         LD      HL,(ARREND)     ; End of string arrays
      0031B5 EB               [ 4] 2739         EX      DE,HL
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 51.
Hexadecimal [24-Bits]



      0031B6 CD 60 26         [17] 2740         CALL    CPDEHL          ; All string arrays done?
      0031B9 CA 07 32         [10] 2741         JP      Z,SCNEND        ; Yes - Move string if found
      0031BC CD 8E 36         [17] 2742         CALL    LOADFP          ; Get array name to BCDE
      0031BF 7B               [ 4] 2743         LD      A,E             ; Get type of array     
      0031C0 E5               [11] 2744         PUSH    HL              ; Save address of num of dim'ns
      0031C1 09               [11] 2745         ADD     HL,BC           ; Start of next array
      0031C2 B7               [ 4] 2746         OR      A               ; Test type of array
      0031C3 F2 B0 31         [10] 2747         JP      P,GNXARY        ; Numeric array - Ignore it
      0031C6 22 C5 42         [16] 2748         LD      (CUROPR),HL     ; Save address of next array
      0031C9 E1               [10] 2749         POP     HL              ; Get address of num of dim'ns
      0031CA 4E               [ 7] 2750         LD      C,(HL)          ; BC = Number of dimensions
      0031CB 06 00            [ 7] 2751         LD      B,#0
      0031CD 09               [11] 2752         ADD     HL,BC           ; Two bytes per dimension size
      0031CE 09               [11] 2753         ADD     HL,BC
      0031CF 23               [ 6] 2754         INC     HL              ; Plus one for number of dim'ns
      0031D0 EB               [ 4] 2755 GRBARY: EX      DE,HL
      0031D1 2A C5 42         [16] 2756         LD      HL,(CUROPR)     ; Get address of next array
      0031D4 EB               [ 4] 2757         EX      DE,HL
      0031D5 CD 60 26         [17] 2758         CALL    CPDEHL          ; Is this array finished?
      0031D8 CA B1 31         [10] 2759         JP      Z,ARRLP         ; Yes - Get next one
      0031DB 01 D0 31         [10] 2760         LD      BC,#GRBARY      ; Loop until array all done
      0031DE C5               [11] 2761 STPOOL: PUSH    BC              ; Save return address
      0031DF F6 80            [ 7] 2762         OR      #0x80           ; Flag string type
      0031E1 7E               [ 7] 2763 STRADD: LD      A,(HL)          ; Get string length
      0031E2 23               [ 6] 2764         INC     HL
      0031E3 23               [ 6] 2765         INC     HL
      0031E4 5E               [ 7] 2766         LD      E,(HL)          ; Get LSB of string address
      0031E5 23               [ 6] 2767         INC     HL
      0031E6 56               [ 7] 2768         LD      D,(HL)          ; Get MSB of string address
      0031E7 23               [ 6] 2769         INC     HL
      0031E8 F0               [11] 2770         RET     P               ; Not a string - Return
      0031E9 B7               [ 4] 2771         OR      A               ; Set flags on string length
      0031EA C8               [11] 2772         RET     Z               ; Null string - Return
      0031EB 44               [ 4] 2773         LD      B,H             ; Save variable pointer
      0031EC 4D               [ 4] 2774         LD      C,L
      0031ED 2A C3 42         [16] 2775         LD      HL,(STRBOT)     ; Bottom of new area
      0031F0 CD 60 26         [17] 2776         CALL    CPDEHL          ; String been done?
      0031F3 60               [ 4] 2777         LD      H,B             ; Restore variable pointer
      0031F4 69               [ 4] 2778         LD      L,C
      0031F5 D8               [11] 2779         RET     C               ; String done - Ignore
      0031F6 E1               [10] 2780         POP     HL              ; Return address
      0031F7 E3               [19] 2781         EX      (SP),HL         ; Lowest available string area
      0031F8 CD 60 26         [17] 2782         CALL    CPDEHL          ; String within string area?
      0031FB E3               [19] 2783         EX      (SP),HL         ; Lowest available string area
      0031FC E5               [11] 2784         PUSH    HL              ; Re-save return address
      0031FD 60               [ 4] 2785         LD      H,B             ; Restore variable pointer
      0031FE 69               [ 4] 2786         LD      L,C
      0031FF D0               [11] 2787         RET     NC              ; Outside string area - Ignore
      003200 C1               [10] 2788         POP     BC              ; Get return , Throw 2 away
      003201 F1               [10] 2789         POP     AF              ; 
      003202 F1               [10] 2790         POP     AF              ; 
      003203 E5               [11] 2791         PUSH    HL              ; Save variable pointer
      003204 D5               [11] 2792         PUSH    DE              ; Save address of current
      003205 C5               [11] 2793         PUSH    BC              ; Put back return address
      003206 C9               [10] 2794         RET                     ; Go to it
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 52.
Hexadecimal [24-Bits]



                                   2795 
      003207 D1               [10] 2796 SCNEND: POP     DE              ; Addresses of strings
      003208 E1               [10] 2797         POP     HL              ; 
      003209 7D               [ 4] 2798         LD      A,L             ; HL = 0 if no more to do
      00320A B4               [ 4] 2799         OR      H
      00320B C8               [11] 2800         RET     Z               ; No more to do - Return
      00320C 2B               [ 6] 2801         DEC     HL
      00320D 46               [ 7] 2802         LD      B,(HL)          ; MSB of address of string
      00320E 2B               [ 6] 2803         DEC     HL
      00320F 4E               [ 7] 2804         LD      C,(HL)          ; LSB of address of string
      003210 E5               [11] 2805         PUSH    HL              ; Save variable address
      003211 2B               [ 6] 2806         DEC     HL
      003212 2B               [ 6] 2807         DEC     HL
      003213 6E               [ 7] 2808         LD      L,(HL)          ; HL = Length of string
      003214 26 00            [ 7] 2809         LD      H,#0
      003216 09               [11] 2810         ADD     HL,BC           ; Address of end of string+1
      003217 50               [ 4] 2811         LD      D,B             ; String address to DE
      003218 59               [ 4] 2812         LD      E,C
      003219 2B               [ 6] 2813         DEC     HL              ; Last byte in string
      00321A 44               [ 4] 2814         LD      B,H             ; Address to BC
      00321B 4D               [ 4] 2815         LD      C,L
      00321C 2A C3 42         [16] 2816         LD      HL,(STRBOT)     ; Current bottom of string area
      00321F CD 67 23         [17] 2817         CALL    MOVSTR          ; Move string to new address
      003222 E1               [10] 2818         POP     HL              ; Restore variable address
      003223 71               [ 7] 2819         LD      (HL),C          ; Save new LSB of address
      003224 23               [ 6] 2820         INC     HL
      003225 70               [ 7] 2821         LD      (HL),B          ; Save new MSB of address
      003226 69               [ 4] 2822         LD      L,C             ; Next string area+1 to HL
      003227 60               [ 4] 2823         LD      H,B
      003228 2B               [ 6] 2824         DEC     HL              ; Next string area address
      003229 C3 7C 31         [10] 2825         JP      GARBLP          ; Look for more strings
                                   2826 
      00322C C5               [11] 2827 CONCAT: PUSH    BC              ; Save prec' opr & code string
      00322D E5               [11] 2828         PUSH    HL              ; 
      00322E 2A E4 42         [16] 2829         LD      HL,(FPREG)      ; Get first string
      003231 E3               [19] 2830         EX      (SP),HL         ; Save first string
      003232 CD E6 2C         [17] 2831         CALL    OPRND           ; Get second string
      003235 E3               [19] 2832         EX      (SP),HL         ; Restore first string
      003236 CD 61 2C         [17] 2833         CALL    TSTSTR          ; Make sure it's a string
      003239 7E               [ 7] 2834         LD      A,(HL)          ; Get length of second string
      00323A E5               [11] 2835         PUSH    HL              ; Save first string
      00323B 2A E4 42         [16] 2836         LD      HL,(FPREG)      ; Get second string
      00323E E5               [11] 2837         PUSH    HL              ; Save second string
      00323F 86               [ 7] 2838         ADD     A,(HL)          ; Add length of second string
      003240 1E 1C            [ 7] 2839         LD      E,#LS           ; ?LS Error
      003242 DA AC 23         [10] 2840         JP      C,ERROR         ; String too long - Error
      003245 CD E5 30         [17] 2841         CALL    MKTMST          ; Make temporary string
      003248 D1               [10] 2842         POP     DE              ; Get second string to DE
      003249 CD 7D 32         [17] 2843         CALL    GSTRDE          ; Move to string pool if needed
      00324C E3               [19] 2844         EX      (SP),HL         ; Get first string
      00324D CD 7C 32         [17] 2845         CALL    GSTRHL          ; Move to string pool if needed
      003250 E5               [11] 2846         PUSH    HL              ; Save first string
      003251 2A C1 42         [16] 2847         LD      HL,(TMPSTR+2)   ; Temporary string address
      003254 EB               [ 4] 2848         EX      DE,HL           ; To DE
      003255 CD 63 32         [17] 2849         CALL    SSTSA           ; First string to string area
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 53.
Hexadecimal [24-Bits]



      003258 CD 63 32         [17] 2850         CALL    SSTSA           ; Second string to string area
      00325B 21 7B 2C         [10] 2851         LD      HL,#EVAL2       ; Return to evaluation loop
      00325E E3               [19] 2852         EX      (SP),HL         ; Save return,get code string
      00325F E5               [11] 2853         PUSH    HL              ; Save code string address
      003260 C3 16 31         [10] 2854         JP      TSTOPL          ; To temporary string to pool
                                   2855 
      003263 E1               [10] 2856 SSTSA:  POP     HL              ; Return address
      003264 E3               [19] 2857         EX      (SP),HL         ; Get string block,save return
      003265 7E               [ 7] 2858         LD      A,(HL)          ; Get length of string
      003266 23               [ 6] 2859         INC     HL
      003267 23               [ 6] 2860         INC     HL
      003268 4E               [ 7] 2861         LD      C,(HL)          ; Get LSB of string address
      003269 23               [ 6] 2862         INC     HL
      00326A 46               [ 7] 2863         LD      B,(HL)          ; Get MSB of string address
      00326B 6F               [ 4] 2864         LD      L,A             ; Length to L
      00326C 2C               [ 4] 2865 TOSTRA: INC     L               ; INC - DECed after
      00326D 2D               [ 4] 2866 TSALP:  DEC     L               ; Count bytes moved
      00326E C8               [11] 2867         RET     Z               ; End of string - Return
      00326F 0A               [ 7] 2868         LD      A,(BC)          ; Get source
      003270 12               [ 7] 2869         LD      (DE),A          ; Save destination
      003271 03               [ 6] 2870         INC     BC              ; Next source
      003272 13               [ 6] 2871         INC     DE              ; Next destination
      003273 C3 6D 32         [10] 2872         JP      TSALP           ; Loop until string moved
                                   2873 
      003276 CD 61 2C         [17] 2874 GETSTR: CALL    TSTSTR          ; Make sure it's a string
      003279 2A E4 42         [16] 2875 GSTRCU: LD      HL,(FPREG)      ; Get current string
      00327C EB               [ 4] 2876 GSTRHL: EX      DE,HL           ; Save DE
      00327D CD 97 32         [17] 2877 GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
      003280 EB               [ 4] 2878         EX      DE,HL           ; Restore DE
      003281 C0               [11] 2879         RET     NZ              ; No - Return
      003282 D5               [11] 2880         PUSH    DE              ; Save string
      003283 50               [ 4] 2881         LD      D,B             ; String block address to DE
      003284 59               [ 4] 2882         LD      E,C
      003285 1B               [ 6] 2883         DEC     DE              ; Point to length
      003286 4E               [ 7] 2884         LD      C,(HL)          ; Get string length
      003287 2A C3 42         [16] 2885         LD      HL,(STRBOT)     ; Current bottom of string area
      00328A CD 60 26         [17] 2886         CALL    CPDEHL          ; Last one in string area?
      00328D C2 95 32         [10] 2887         JP      NZ,POPHL        ; No - Return
      003290 47               [ 4] 2888         LD      B,A             ; Clear B (A=0)
      003291 09               [11] 2889         ADD     HL,BC           ; Remove string from str' area
      003292 22 C3 42         [16] 2890         LD      (STRBOT),HL     ; Save new bottom of str' area
      003295 E1               [10] 2891 POPHL:  POP     HL              ; Restore string
      003296 C9               [10] 2892         RET
                                   2893 
      003297 2A B1 42         [16] 2894 BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
      00329A 2B               [ 6] 2895         DEC     HL              ; Back
      00329B 46               [ 7] 2896         LD      B,(HL)          ; Get MSB of address
      00329C 2B               [ 6] 2897         DEC     HL              ; Back
      00329D 4E               [ 7] 2898         LD      C,(HL)          ; Get LSB of address
      00329E 2B               [ 6] 2899         DEC     HL              ; Back
      00329F 2B               [ 6] 2900         DEC     HL              ; Back
      0032A0 CD 60 26         [17] 2901         CALL    CPDEHL          ; String last in string pool?
      0032A3 C0               [11] 2902         RET     NZ              ; Yes - Leave it
      0032A4 22 B1 42         [16] 2903         LD      (TMSTPT),HL     ; Save new string pool top
      0032A7 C9               [10] 2904         RET
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 54.
Hexadecimal [24-Bits]



                                   2905 
      0032A8 01 27 30         [10] 2906 LEN:    LD      BC,#PASSA       ; To return integer A
      0032AB C5               [11] 2907         PUSH    BC              ; Save address
      0032AC CD 76 32         [17] 2908 GETLEN: CALL    GETSTR          ; Get string and its length
      0032AF AF               [ 4] 2909         XOR     A
      0032B0 57               [ 4] 2910         LD      D,A             ; Clear D
      0032B1 32 AD 42         [13] 2911         LD      (TYPE),A        ; Set type to numeric
      0032B4 7E               [ 7] 2912         LD      A,(HL)          ; Get length of string
      0032B5 B7               [ 4] 2913         OR      A               ; Set status flags
      0032B6 C9               [10] 2914         RET
                                   2915 
      0032B7 01 27 30         [10] 2916 ASC:    LD      BC,#PASSA       ; To return integer A
      0032BA C5               [11] 2917         PUSH    BC              ; Save address
      0032BB CD AC 32         [17] 2918 GTFLNM: CALL    GETLEN          ; Get length of string
      0032BE CA B7 28         [10] 2919         JP      Z,FCERR         ; Null string - Error
      0032C1 23               [ 6] 2920         INC     HL
      0032C2 23               [ 6] 2921         INC     HL
      0032C3 5E               [ 7] 2922         LD      E,(HL)          ; Get LSB of address
      0032C4 23               [ 6] 2923         INC     HL
      0032C5 56               [ 7] 2924         LD      D,(HL)          ; Get MSB of address
      0032C6 1A               [ 7] 2925         LD      A,(DE)          ; Get first byte of string
      0032C7 C9               [10] 2926         RET
                                   2927 
      0032C8 3E 01            [ 7] 2928 CHR:    LD      A,#1            ; One character string
      0032CA CD E5 30         [17] 2929         CALL    MKTMST          ; Make a temporary string
      0032CD CD C1 33         [17] 2930         CALL    MAKINT          ; Make it integer A
      0032D0 2A C1 42         [16] 2931         LD      HL,(TMPSTR+2)   ; Get address of string
      0032D3 73               [ 7] 2932         LD      (HL),E          ; Save character
      0032D4 C1               [10] 2933 TOPOOL: POP     BC              ; Clean up stack
      0032D5 C3 16 31         [10] 2934         JP      TSTOPL          ; Temporary string to pool
                                   2935 
      0032D8 CD 71 33         [17] 2936 LEFT:   CALL    LFRGNM          ; Get number and ending ")"
      0032DB AF               [ 4] 2937         XOR     A               ; Start at first byte in string
      0032DC E3               [19] 2938 RIGHT1: EX      (SP),HL         ; Save code string,Get string
      0032DD 4F               [ 4] 2939         LD      C,A             ; Starting position in string
      0032DE E5               [11] 2940 MID1:   PUSH    HL              ; Save string block address
      0032DF 7E               [ 7] 2941         LD      A,(HL)          ; Get length of string
      0032E0 B8               [ 4] 2942         CP      B               ; Compare with number given
      0032E1 DA E6 32         [10] 2943         JP      C,ALLFOL        ; All following bytes required
      0032E4 78               [ 4] 2944         LD      A,B             ; Get new length
      0032E5 11                    2945         .BYTE      0x11         ; Skip "LD C,0"
      0032E6 0E 00            [ 7] 2946 ALLFOL: LD      C,#0            ; First byte of string
      0032E8 C5               [11] 2947         PUSH    BC              ; Save position in string
      0032E9 CD 4F 31         [17] 2948         CALL    TESTR           ; See if enough string space
      0032EC C1               [10] 2949         POP     BC              ; Get position in string
      0032ED E1               [10] 2950         POP     HL              ; Restore string block address
      0032EE E5               [11] 2951         PUSH    HL              ; And re-save it
      0032EF 23               [ 6] 2952         INC     HL
      0032F0 23               [ 6] 2953         INC     HL
      0032F1 46               [ 7] 2954         LD      B,(HL)          ; Get LSB of address
      0032F2 23               [ 6] 2955         INC     HL
      0032F3 66               [ 7] 2956         LD      H,(HL)          ; Get MSB of address
      0032F4 68               [ 4] 2957         LD      L,B             ; HL = address of string
      0032F5 06 00            [ 7] 2958         LD      B,#0            ; BC = starting address
      0032F7 09               [11] 2959         ADD     HL,BC           ; Point to that byte
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 55.
Hexadecimal [24-Bits]



      0032F8 44               [ 4] 2960         LD      B,H             ; BC = source string
      0032F9 4D               [ 4] 2961         LD      C,L
      0032FA CD E8 30         [17] 2962         CALL    CRTMST          ; Create a string entry
      0032FD 6F               [ 4] 2963         LD      L,A             ; Length of new string
      0032FE CD 6C 32         [17] 2964         CALL    TOSTRA          ; Move string to string area
      003301 D1               [10] 2965         POP     DE              ; Clear stack
      003302 CD 7D 32         [17] 2966         CALL    GSTRDE          ; Move to string pool if needed
      003305 C3 16 31         [10] 2967         JP      TSTOPL          ; Temporary string to pool
                                   2968 
      003308 CD 71 33         [17] 2969 RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
      00330B D1               [10] 2970         POP     DE              ; Get string length
      00330C D5               [11] 2971         PUSH    DE              ; And re-save
      00330D 1A               [ 7] 2972         LD      A,(DE)          ; Get length
      00330E 90               [ 4] 2973         SUB     B               ; Move back N bytes
      00330F C3 DC 32         [10] 2974         JP      RIGHT1          ; Go and get sub-string
                                   2975 
      003312 EB               [ 4] 2976 MID:    EX      DE,HL           ; Get code string address
      003313 7E               [ 7] 2977         LD      A,(HL)          ; Get next byte ',' or ")"
      003314 CD 76 33         [17] 2978         CALL    MIDNUM          ; Get number supplied
      003317 04               [ 4] 2979         INC     B               ; Is it character zero?
      003318 05               [ 4] 2980         DEC     B
      003319 CA B7 28         [10] 2981         JP      Z,FCERR         ; Yes - Error
      00331C C5               [11] 2982         PUSH    BC              ; Save starting position
      00331D 1E FF            [ 7] 2983         LD      E,#255          ; All of string
      00331F FE 29            [ 7] 2984         CP      #')'            ; Any length given?
      003321 CA 2B 33         [10] 2985         JP      Z,RSTSTR        ; No - Rest of string
      003324 CD 66 26         [17] 2986         CALL    CHKSYN          ; Make sure ',' follows
      003327 2C                    2987         .BYTE      ','
      003328 CD BE 33         [17] 2988         CALL    GETINT          ; Get integer 0-255
      00332B CD 66 26         [17] 2989 RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
      00332E 29                    2990         .BYTE      ")"
      00332F F1               [10] 2991         POP     AF              ; Restore starting position
      003330 E3               [19] 2992         EX      (SP),HL         ; Get string,8ave code string
      003331 01 DE 32         [10] 2993         LD      BC,#MID1        ; Continuation of MID$ routine
      003334 C5               [11] 2994         PUSH    BC              ; Save for return
      003335 3D               [ 4] 2995         DEC     A               ; Starting position-1
      003336 BE               [ 7] 2996         CP      (HL)            ; Compare with length
      003337 06 00            [ 7] 2997         LD      B,#0            ; Zero bytes length
      003339 D0               [11] 2998         RET     NC              ; Null string if start past end
      00333A 4F               [ 4] 2999         LD      C,A             ; Save starting position-1
      00333B 7E               [ 7] 3000         LD      A,(HL)          ; Get length of string
      00333C 91               [ 4] 3001         SUB     C               ; Subtract start
      00333D BB               [ 4] 3002         CP      E               ; Enough string for it?
      00333E 47               [ 4] 3003         LD      B,A             ; Save maximum length available
      00333F D8               [11] 3004         RET     C               ; Truncate string if needed
      003340 43               [ 4] 3005         LD      B,E             ; Set specified length
      003341 C9               [10] 3006         RET                     ; Go and create string
                                   3007 
      003342 CD AC 32         [17] 3008 VAL:    CALL    GETLEN          ; Get length of string
      003345 CA 5F 34         [10] 3009         JP      Z,RESZER        ; Result zero
      003348 5F               [ 4] 3010         LD      E,A             ; Save length
      003349 23               [ 6] 3011         INC     HL
      00334A 23               [ 6] 3012         INC     HL
      00334B 7E               [ 7] 3013         LD      A,(HL)          ; Get LSB of address
      00334C 23               [ 6] 3014         INC     HL
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 56.
Hexadecimal [24-Bits]



      00334D 66               [ 7] 3015         LD      H,(HL)          ; Get MSB of address
      00334E 6F               [ 4] 3016         LD      L,A             ; HL = String address
      00334F E5               [11] 3017         PUSH    HL              ; Save string address
      003350 19               [11] 3018         ADD     HL,DE
      003351 46               [ 7] 3019         LD      B,(HL)          ; Get end of string+1 byte
      003352 72               [ 7] 3020         LD      (HL),D          ; Zero it to terminate
      003353 E3               [19] 3021         EX      (SP),HL         ; Save string end,get start
      003354 C5               [11] 3022         PUSH    BC              ; Save end+1 byte
      003355 7E               [ 7] 3023         LD      A,(HL)          ; Get starting byte
      003356 FE 24            [ 7] 3024     CP	#'$'		; Hex number indicated? [function added]
      003358 C2 60 33         [10] 3025     JP	NZ,VAL1
      00335B CD 8A 3B         [17] 3026     CALL	HEXTFP		; Convert Hex to FPREG
      00335E 18 0D            [12] 3027     JR	VAL3
      003360 FE 25            [ 7] 3028 VAL1:	CP	#'%'		; Binary number indicated? [function added]
      003362 C2 6A 33         [10] 3029     JP	NZ,VAL2
      003365 CD FA 3B         [17] 3030     CALL	BINTFP		; Convert Bin to FPREG
      003368 18 03            [12] 3031     JR	VAL3
      00336A CD 46 37         [17] 3032 VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
      00336D C1               [10] 3033 VAL3:   POP     BC              ; Restore end+1 byte
      00336E E1               [10] 3034         POP     HL              ; Restore end+1 address
      00336F 70               [ 7] 3035         LD      (HL),B          ; Put back original byte
      003370 C9               [10] 3036         RET
                                   3037 
      003371 EB               [ 4] 3038 LFRGNM: EX      DE,HL           ; Code string address to HL
      003372 CD 66 26         [17] 3039         CALL    CHKSYN          ; Make sure ")" follows
      003375 29                    3040         .BYTE      ")"
      003376 C1               [10] 3041 MIDNUM: POP     BC              ; Get return address
      003377 D1               [10] 3042         POP     DE              ; Get number supplied
      003378 C5               [11] 3043         PUSH    BC              ; Re-save return address
      003379 43               [ 4] 3044         LD      B,E             ; Number to B
      00337A C9               [10] 3045         RET
                                   3046 
      00337B CD C1 33         [17] 3047 INP:    CALL    MAKINT          ; Make it integer A
      00337E 32 3F 42         [13] 3048         LD      (INPORT),A      ; Set input port
      003381 CD 3E 42         [17] 3049         CALL    INPSUB          ; Get input from port
      003384 C3 27 30         [10] 3050         JP      PASSA           ; Return integer A
                                   3051 
      003387 CD AB 33         [17] 3052 POUT:   CALL    SETIO           ; Set up port number
      00338A C3 06 42         [10] 3053         JP      OUTSUB          ; Output data and return
                                   3054 
      00338D CD AB 33         [17] 3055 WAIT:   CALL    SETIO           ; Set up port number
      003390 F5               [11] 3056         PUSH    AF              ; Save AND mask
      003391 1E 00            [ 7] 3057         LD      E,#0            ; Assume zero if none given
      003393 2B               [ 6] 3058         DEC     HL              ; DEC 'cos GETCHR INCs
      003394 CD F0 27         [17] 3059         CALL    GETCHR          ; Get next character
      003397 CA A1 33         [10] 3060         JP      Z,NOXOR         ; No XOR byte given
      00339A CD 66 26         [17] 3061         CALL    CHKSYN          ; Make sure ',' follows
      00339D 2C                    3062         .BYTE      ','
      00339E CD BE 33         [17] 3063         CALL    GETINT          ; Get integer 0-255 to XOR with
      0033A1 C1               [10] 3064 NOXOR:  POP     BC              ; Restore AND mask
      0033A2 CD 3E 42         [17] 3065 WAITLP: CALL    INPSUB          ; Get input
      0033A5 AB               [ 4] 3066         XOR     E               ; Flip selected bits
      0033A6 A0               [ 4] 3067         AND     B               ; Result non-zero?
      0033A7 CA A2 33         [10] 3068         JP      Z,WAITLP        ; No = keep waiting
      0033AA C9               [10] 3069         RET
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 57.
Hexadecimal [24-Bits]



                                   3070 
      0033AB CD BE 33         [17] 3071 SETIO:  CALL    GETINT          ; Get integer 0-255
      0033AE 32 3F 42         [13] 3072         LD      (INPORT),A      ; Set input port
      0033B1 32 07 42         [13] 3073         LD      (OTPORT),A      ; Set output port
      0033B4 CD 66 26         [17] 3074         CALL    CHKSYN          ; Make sure ',' follows
      0033B7 2C                    3075         .BYTE      ','
      0033B8 C3 BE 33         [10] 3076         JP      GETINT          ; Get integer 0-255 and return
                                   3077 
      0033BB CD F0 27         [17] 3078 FNDNUM: CALL    GETCHR          ; Get next character
      0033BE CD 5D 2C         [17] 3079 GETINT: CALL    GETNUM          ; Get a number from 0 to 255
      0033C1 CD 9C 28         [17] 3080 MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
      0033C4 7A               [ 4] 3081         LD      A,D             ; Get MSB of number
      0033C5 B7               [ 4] 3082         OR      A               ; Zero?
      0033C6 C2 B7 28         [10] 3083         JP      NZ,FCERR        ; No - Error
      0033C9 2B               [ 6] 3084         DEC     HL              ; DEC 'cos GETCHR INCs
      0033CA CD F0 27         [17] 3085         CALL    GETCHR          ; Get next character
      0033CD 7B               [ 4] 3086         LD      A,E             ; Get number to A
      0033CE C9               [10] 3087         RET
                                   3088 
      0033CF CD A2 28         [17] 3089 PEEK:   CALL    DEINT           ; Get memory address
      0033D2 1A               [ 7] 3090         LD      A,(DE)          ; Get byte in memory
      0033D3 C3 27 30         [10] 3091         JP      PASSA           ; Return integer A
                                   3092 
      0033D6 CD 5D 2C         [17] 3093 POKE:   CALL    GETNUM          ; Get memory address
      0033D9 CD A2 28         [17] 3094         CALL    DEINT           ; Get integer -32768 to 3276
      0033DC D5               [11] 3095         PUSH    DE              ; Save memory address
      0033DD CD 66 26         [17] 3096         CALL    CHKSYN          ; Make sure ',' follows
      0033E0 2C                    3097         .BYTE      ','
      0033E1 CD BE 33         [17] 3098         CALL    GETINT          ; Get integer 0-255
      0033E4 D1               [10] 3099         POP     DE              ; Restore memory address
      0033E5 12               [ 7] 3100         LD      (DE),A          ; Load it into memory
      0033E6 C9               [10] 3101         RET
                                   3102 
      0033E7 21 BD 38         [10] 3103 ROUND:  LD      HL,#HALF        ; Add 0.5 to FPREG
      0033EA CD 8E 36         [17] 3104 ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
      0033ED C3 F9 33         [10] 3105         JP      FPADD           ; Add BCDE to FPREG
                                   3106 
      0033F0 CD 8E 36         [17] 3107 SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
      0033F3 21                    3108         .BYTE      0x21         ; Skip "POP BC" and "POP DE"
      0033F4 C1               [10] 3109 PSUB:   POP     BC              ; Get FP number from stack
      0033F5 D1               [10] 3110         POP     DE
      0033F6 CD 68 36         [17] 3111 SUBCDE: CALL    INVSGN          ; Negate FPREG
      0033F9 78               [ 4] 3112 FPADD:  LD      A,B             ; Get FP exponent
      0033FA B7               [ 4] 3113         OR      A               ; Is number zero?
      0033FB C8               [11] 3114         RET     Z               ; Yes - Nothing to add
      0033FC 3A E7 42         [13] 3115         LD      A,(FPEXP)       ; Get FPREG exponent
      0033FF B7               [ 4] 3116         OR      A               ; Is this number zero?
      003400 CA 80 36         [10] 3117         JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
      003403 90               [ 4] 3118         SUB     B               ; BCDE number larger?
      003404 D2 13 34         [10] 3119         JP      NC,NOSWAP       ; No - Don't swap them
      003407 2F               [ 4] 3120         CPL                     ; Two's complement
      003408 3C               [ 4] 3121         INC     A               ;  FP exponent
      003409 EB               [ 4] 3122         EX      DE,HL
      00340A CD 70 36         [17] 3123         CALL    STAKFP          ; Put FPREG on stack
      00340D EB               [ 4] 3124         EX      DE,HL
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 58.
Hexadecimal [24-Bits]



      00340E CD 80 36         [17] 3125         CALL    FPBCDE          ; Move BCDE to FPREG
      003411 C1               [10] 3126         POP     BC              ; Restore number from stack
      003412 D1               [10] 3127         POP     DE
      003413 FE 19            [ 7] 3128 NOSWAP: CP      #24+1           ; Second number insignificant?
      003415 D0               [11] 3129         RET     NC              ; Yes - First number is result
      003416 F5               [11] 3130         PUSH    AF              ; Save number of bits to scale
      003417 CD A5 36         [17] 3131         CALL    SIGNS           ; Set MSBs & sign of result
      00341A 67               [ 4] 3132         LD      H,A             ; Save sign of result
      00341B F1               [10] 3133         POP     AF              ; Restore scaling factor
      00341C CD BE 34         [17] 3134         CALL    SCALE           ; Scale BCDE to same exponent
      00341F B4               [ 4] 3135         OR      H               ; Result to be positive?
      003420 21 E4 42         [10] 3136         LD      HL,#FPREG       ; Point to FPREG
      003423 F2 39 34         [10] 3137         JP      P,MINCDE        ; No - Subtract FPREG from CDE
      003426 CD 9E 34         [17] 3138         CALL    PLUCDE          ; Add FPREG to CDE
      003429 D2 7F 34         [10] 3139         JP      NC,RONDUP       ; No overflow - Round it up
      00342C 23               [ 6] 3140         INC     HL              ; Point to exponent
      00342D 34               [11] 3141         INC     (HL)            ; Increment it
      00342E CA A7 23         [10] 3142         JP      Z,OVERR         ; Number overflowed - Error
      003431 2E 01            [ 7] 3143         LD      L,#1            ; 1 bit to shift right
      003433 CD D4 34         [17] 3144         CALL    SHRT1           ; Shift result right
      003436 C3 7F 34         [10] 3145         JP      RONDUP          ; Round it up
                                   3146 
      003439 AF               [ 4] 3147 MINCDE: XOR     A               ; Clear A and carry
      00343A 90               [ 4] 3148         SUB     B               ; Negate exponent
      00343B 47               [ 4] 3149         LD      B,A             ; Re-save exponent
      00343C 7E               [ 7] 3150         LD      A,(HL)          ; Get LSB of FPREG
      00343D 9B               [ 4] 3151         SBC     A, E            ; Subtract LSB of BCDE
      00343E 5F               [ 4] 3152         LD      E,A             ; Save LSB of BCDE
      00343F 23               [ 6] 3153         INC     HL
      003440 7E               [ 7] 3154         LD      A,(HL)          ; Get NMSB of FPREG
      003441 9A               [ 4] 3155         SBC     A,D             ; Subtract NMSB of BCDE
      003442 57               [ 4] 3156         LD      D,A             ; Save NMSB of BCDE
      003443 23               [ 6] 3157         INC     HL
      003444 7E               [ 7] 3158         LD      A,(HL)          ; Get MSB of FPREG
      003445 99               [ 4] 3159         SBC     A,C             ; Subtract MSB of BCDE
      003446 4F               [ 4] 3160         LD      C,A             ; Save MSB of BCDE
      003447 DC AA 34         [17] 3161 CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
                                   3162 
      00344A 68               [ 4] 3163 BNORM:  LD      L,B             ; L = Exponent
      00344B 63               [ 4] 3164         LD      H,E             ; H = LSB
      00344C AF               [ 4] 3165         XOR     A
      00344D 47               [ 4] 3166 BNRMLP: LD      B,A             ; Save bit count
      00344E 79               [ 4] 3167         LD      A,C             ; Get MSB
      00344F B7               [ 4] 3168         OR      A               ; Is it zero?
      003450 C2 6C 34         [10] 3169         JP      NZ,PNORM        ; No - Do it bit at a time
      003453 4A               [ 4] 3170         LD      C,D             ; MSB = NMSB
      003454 54               [ 4] 3171         LD      D,H             ; NMSB= LSB
      003455 65               [ 4] 3172         LD      H,L             ; LSB = VLSB
      003456 6F               [ 4] 3173         LD      L,A             ; VLSB= 0
      003457 78               [ 4] 3174         LD      A,B             ; Get exponent
      003458 D6 08            [ 7] 3175         SUB     #8              ; Count 8 bits
      00345A FE E0            [ 7] 3176         CP      #-24-8          ; Was number zero?
      00345C C2 4D 34         [10] 3177         JP      NZ,BNRMLP       ; No - Keep normalising
      00345F AF               [ 4] 3178 RESZER: XOR     A               ; Result is zero
      003460 32 E7 42         [13] 3179 SAVEXP: LD      (FPEXP),A       ; Save result as zero
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 59.
Hexadecimal [24-Bits]



      003463 C9               [10] 3180         RET
                                   3181 
      003464 05               [ 4] 3182 NORMAL: DEC     B               ; Count bits
      003465 29               [11] 3183         ADD     HL,HL           ; Shift HL left
      003466 7A               [ 4] 3184         LD      A,D             ; Get NMSB
      003467 17               [ 4] 3185         RLA                     ; Shift left with last bit
      003468 57               [ 4] 3186         LD      D,A             ; Save NMSB
      003469 79               [ 4] 3187         LD      A,C             ; Get MSB
      00346A 8F               [ 4] 3188         ADC     A,A             ; Shift left with last bit
      00346B 4F               [ 4] 3189         LD      C,A             ; Save MSB
      00346C F2 64 34         [10] 3190 PNORM:  JP      P,NORMAL        ; Not done - Keep going
      00346F 78               [ 4] 3191         LD      A,B             ; Number of bits shifted
      003470 5C               [ 4] 3192         LD      E,H             ; Save HL in EB
      003471 45               [ 4] 3193         LD      B,L
      003472 B7               [ 4] 3194         OR      A               ; Any shifting done?
      003473 CA 7F 34         [10] 3195         JP      Z,RONDUP        ; No - Round it up
      003476 21 E7 42         [10] 3196         LD      HL,#FPEXP       ; Point to exponent
      003479 86               [ 7] 3197         ADD     A,(HL)          ; Add shifted bits
      00347A 77               [ 7] 3198         LD      (HL),A          ; Re-save exponent
      00347B D2 5F 34         [10] 3199         JP      NC,RESZER       ; Underflow - Result is zero
      00347E C8               [11] 3200         RET     Z               ; Result is zero
      00347F 78               [ 4] 3201 RONDUP: LD      A,B             ; Get VLSB of number
      003480 21 E7 42         [10] 3202 RONDB:  LD      HL,#FPEXP       ; Point to exponent
      003483 B7               [ 4] 3203         OR      A               ; Any rounding?
      003484 FC 91 34         [17] 3204         CALL    M,FPROND        ; Yes - Round number up
      003487 46               [ 7] 3205         LD      B,(HL)          ; B = Exponent
      003488 23               [ 6] 3206         INC     HL
      003489 7E               [ 7] 3207         LD      A,(HL)          ; Get sign of result
      00348A E6 80            [ 7] 3208         AND     #0b10000000     ; Only bit 7 needed
      00348C A9               [ 4] 3209         XOR     C               ; Set correct sign
      00348D 4F               [ 4] 3210         LD      C,A             ; Save correct sign in number
      00348E C3 80 36         [10] 3211         JP      FPBCDE          ; Move BCDE to FPREG
                                   3212 
      003491 1C               [ 4] 3213 FPROND: INC     E               ; Round LSB
      003492 C0               [11] 3214         RET     NZ              ; Return if ok
      003493 14               [ 4] 3215         INC     D               ; Round NMSB
      003494 C0               [11] 3216         RET     NZ              ; Return if ok
      003495 0C               [ 4] 3217         INC     C               ; Round MSB
      003496 C0               [11] 3218         RET     NZ              ; Return if ok
      003497 0E 80            [ 7] 3219         LD      C,#0x80         ; Set normal value
      003499 34               [11] 3220         INC     (HL)            ; Increment exponent
      00349A C0               [11] 3221         RET     NZ              ; Return if ok
      00349B C3 A7 23         [10] 3222         JP      OVERR           ; Overflow error
                                   3223 
      00349E 7E               [ 7] 3224 PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
      00349F 83               [ 4] 3225         ADD     A,E             ; Add LSB of BCDE
      0034A0 5F               [ 4] 3226         LD      E,A             ; Save LSB of BCDE
      0034A1 23               [ 6] 3227         INC     HL
      0034A2 7E               [ 7] 3228         LD      A,(HL)          ; Get NMSB of FPREG
      0034A3 8A               [ 4] 3229         ADC     A,D             ; Add NMSB of BCDE
      0034A4 57               [ 4] 3230         LD      D,A             ; Save NMSB of BCDE
      0034A5 23               [ 6] 3231         INC     HL
      0034A6 7E               [ 7] 3232         LD      A,(HL)          ; Get MSB of FPREG
      0034A7 89               [ 4] 3233         ADC     A,C             ; Add MSB of BCDE
      0034A8 4F               [ 4] 3234         LD      C,A             ; Save MSB of BCDE
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 60.
Hexadecimal [24-Bits]



      0034A9 C9               [10] 3235         RET
                                   3236 
      0034AA 21 E8 42         [10] 3237 COMPL:  LD      HL,#SGNRES      ; Sign of result
      0034AD 7E               [ 7] 3238         LD      A,(HL)          ; Get sign of result
      0034AE 2F               [ 4] 3239         CPL                     ; Negate it
      0034AF 77               [ 7] 3240         LD      (HL),A          ; Put it back
      0034B0 AF               [ 4] 3241         XOR     A
      0034B1 6F               [ 4] 3242         LD      L,A             ; Set L to zero
      0034B2 90               [ 4] 3243         SUB     B               ; Negate exponent,set carry
      0034B3 47               [ 4] 3244         LD      B,A             ; Re-save exponent
      0034B4 7D               [ 4] 3245         LD      A,L             ; Load zero
      0034B5 9B               [ 4] 3246         SBC     A,E             ; Negate LSB
      0034B6 5F               [ 4] 3247         LD      E,A             ; Re-save LSB
      0034B7 7D               [ 4] 3248         LD      A,L             ; Load zero
      0034B8 9A               [ 4] 3249         SBC     A,D             ; Negate NMSB
      0034B9 57               [ 4] 3250         LD      D,A             ; Re-save NMSB
      0034BA 7D               [ 4] 3251         LD      A,L             ; Load zero
      0034BB 99               [ 4] 3252         SBC     A,C             ; Negate MSB
      0034BC 4F               [ 4] 3253         LD      C,A             ; Re-save MSB
      0034BD C9               [10] 3254         RET
                                   3255 
      0034BE 06 00            [ 7] 3256 SCALE:  LD      B,#0            ; Clear underflow
      0034C0 D6 08            [ 7] 3257 SCALLP: SUB     #8              ; 8 bits (a whole byte)?
      0034C2 DA CD 34         [10] 3258         JP      C,SHRITE        ; No - Shift right A bits
      0034C5 43               [ 4] 3259         LD      B,E             ; <- Shift
      0034C6 5A               [ 4] 3260         LD      E,D             ; <- right
      0034C7 51               [ 4] 3261         LD      D,C             ; <- eight
      0034C8 0E 00            [ 7] 3262         LD      C,#0            ; <- bits
      0034CA C3 C0 34         [10] 3263         JP      SCALLP          ; More bits to shift
                                   3264 
      0034CD C6 09            [ 7] 3265 SHRITE: ADD     A,#8+1          ; Adjust count
      0034CF 6F               [ 4] 3266         LD      L,A             ; Save bits to shift
      0034D0 AF               [ 4] 3267 SHRLP:  XOR     A               ; Flag for all done
      0034D1 2D               [ 4] 3268         DEC     L               ; All shifting done?
      0034D2 C8               [11] 3269         RET     Z               ; Yes - Return
      0034D3 79               [ 4] 3270         LD      A,C             ; Get MSB
      0034D4 1F               [ 4] 3271 SHRT1:  RRA                     ; Shift it right
      0034D5 4F               [ 4] 3272         LD      C,A             ; Re-save
      0034D6 7A               [ 4] 3273         LD      A,D             ; Get NMSB
      0034D7 1F               [ 4] 3274         RRA                     ; Shift right with last bit
      0034D8 57               [ 4] 3275         LD      D,A             ; Re-save it
      0034D9 7B               [ 4] 3276         LD      A,E             ; Get LSB
      0034DA 1F               [ 4] 3277         RRA                     ; Shift right with last bit
      0034DB 5F               [ 4] 3278         LD      E,A             ; Re-save it
      0034DC 78               [ 4] 3279         LD      A,B             ; Get underflow
      0034DD 1F               [ 4] 3280         RRA                     ; Shift right with last bit
      0034DE 47               [ 4] 3281         LD      B,A             ; Re-save underflow
      0034DF C3 D0 34         [10] 3282         JP      SHRLP           ; More bits to do
                                   3283 
      0034E2 00 00 00 81           3284 UNITY:  .BYTE       0x00,0x00,0x00,0x81    ; 1.00000
                                   3285 
      0034E6 03                    3286 LOGTAB: .BYTE      3                       ; Table used by LOG
      0034E7 AA 56 19 80           3287         .BYTE      0xAA,0x56,0x19,0x80     ; 0.59898
      0034EB F1 22 76 80           3288         .BYTE      0xF1,0x22,0x76,0x80     ; 0.96147
      0034EF 45 AA 38 82           3289         .BYTE      0x45,0xAA,0x38,0x82     ; 2.88539
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 61.
Hexadecimal [24-Bits]



                                   3290 
      0034F3 CD 3F 36         [17] 3291 LOG:    CALL    TSTSGN          ; Test sign of value
      0034F6 B7               [ 4] 3292         OR      A
      0034F7 EA B7 28         [10] 3293         JP      PE,FCERR        ; ?FC Error if <= zero
      0034FA 21 E7 42         [10] 3294         LD      HL,#FPEXP       ; Point to exponent
      0034FD 7E               [ 7] 3295         LD      A,(HL)          ; Get exponent
      0034FE 01 35 80         [10] 3296         LD      BC,#0x8035      ; BCDE = SQR(1/2)
      003501 11 F3 04         [10] 3297         LD      DE,#0x04F3
      003504 90               [ 4] 3298         SUB     B               ; Scale value to be < 1
      003505 F5               [11] 3299         PUSH    AF              ; Save scale factor
      003506 70               [ 7] 3300         LD      (HL),B          ; Save new exponent
      003507 D5               [11] 3301         PUSH    DE              ; Save SQR(1/2)
      003508 C5               [11] 3302         PUSH    BC
      003509 CD F9 33         [17] 3303         CALL    FPADD           ; Add SQR(1/2) to value
      00350C C1               [10] 3304         POP     BC              ; Restore SQR(1/2)
      00350D D1               [10] 3305         POP     DE
      00350E 04               [ 4] 3306         INC     B               ; Make it SQR(2)
      00350F CD 95 35         [17] 3307         CALL    DVBCDE          ; Divide by SQR(2)
      003512 21 E2 34         [10] 3308         LD      HL,#UNITY       ; Point to 1.
      003515 CD F0 33         [17] 3309         CALL    SUBPHL          ; Subtract FPREG from 1
      003518 21 E6 34         [10] 3310         LD      HL,#LOGTAB      ; Coefficient table
      00351B CD 87 39         [17] 3311         CALL    SUMSER          ; Evaluate sum of series
      00351E 01 80 80         [10] 3312         LD      BC,#0x8080      ; BCDE = -0.5
      003521 11 00 00         [10] 3313         LD      DE,#0x0000
      003524 CD F9 33         [17] 3314         CALL    FPADD           ; Subtract 0.5 from FPREG
      003527 F1               [10] 3315         POP     AF              ; Restore scale factor
      003528 CD BA 37         [17] 3316         CALL    RSCALE          ; Re-scale number
      00352B 01 31 80         [10] 3317 MULLN2: LD      BC,#0x8031      ; BCDE = Ln(2)
      00352E 11 18 72         [10] 3318         LD      DE,#0x7218
      003531 21                    3319         .BYTE      0x21         ; Skip "POP BC" and "POP DE"
                                   3320 
      003532 C1               [10] 3321 MULT:   POP     BC              ; Get number from stack
      003533 D1               [10] 3322         POP     DE
      003534 CD 3F 36         [17] 3323 FPMULT: CALL    TSTSGN          ; Test sign of FPREG
      003537 C8               [11] 3324         RET     Z               ; Return zero if zero
      003538 2E 00            [ 7] 3325         LD      L,#0            ; Flag add exponents
      00353A CD FD 35         [17] 3326         CALL    ADDEXP          ; Add exponents
      00353D 79               [ 4] 3327         LD      A,C             ; Get MSB of multiplier
      00353E 32 F6 42         [13] 3328         LD      (MULVAL),A      ; Save MSB of multiplier
      003541 EB               [ 4] 3329         EX      DE,HL
      003542 22 F7 42         [16] 3330         LD      (MULVAL+1),HL   ; Save rest of multiplier
      003545 01 00 00         [10] 3331         LD      BC,#0           ; Partial product (BCDE) = zero
      003548 50               [ 4] 3332         LD      D,B
      003549 58               [ 4] 3333         LD      E,B
      00354A 21 4A 34         [10] 3334         LD      HL,#BNORM       ; Address of normalise
      00354D E5               [11] 3335         PUSH    HL              ; Save for return
      00354E 21 56 35         [10] 3336         LD      HL,#MULT8       ; Address of 8 bit multiply
      003551 E5               [11] 3337         PUSH    HL              ; Save for NMSB,MSB
      003552 E5               [11] 3338         PUSH    HL              ; 
      003553 21 E4 42         [10] 3339         LD      HL,#FPREG       ; Point to number
      003556 7E               [ 7] 3340 MULT8:  LD      A,(HL)          ; Get LSB of number
      003557 23               [ 6] 3341         INC     HL              ; Point to NMSB
      003558 B7               [ 4] 3342         OR      A               ; Test LSB
      003559 CA 82 35         [10] 3343         JP      Z,BYTSFT        ; Zero - shift to next byte
      00355C E5               [11] 3344         PUSH    HL              ; Save address of number
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 62.
Hexadecimal [24-Bits]



      00355D 2E 08            [ 7] 3345         LD      L,#8            ; 8 bits to multiply by
      00355F 1F               [ 4] 3346 MUL8LP: RRA                     ; Shift LSB right
      003560 67               [ 4] 3347         LD      H,A             ; Save LSB
      003561 79               [ 4] 3348         LD      A,C             ; Get MSB
      003562 D2 70 35         [10] 3349         JP      NC,NOMADD       ; Bit was zero - Don't add
      003565 E5               [11] 3350         PUSH    HL              ; Save LSB and count
      003566 2A F7 42         [16] 3351         LD      HL,(MULVAL+1)   ; Get LSB and NMSB
      003569 19               [11] 3352         ADD     HL,DE           ; Add NMSB and LSB
      00356A EB               [ 4] 3353         EX      DE,HL           ; Leave sum in DE
      00356B E1               [10] 3354         POP     HL              ; Restore MSB and count
      00356C 3A F6 42         [13] 3355         LD      A,(MULVAL)      ; Get MSB of multiplier
      00356F 89               [ 4] 3356         ADC     A,C             ; Add MSB
      003570 1F               [ 4] 3357 NOMADD: RRA                     ; Shift MSB right
      003571 4F               [ 4] 3358         LD      C,A             ; Re-save MSB
      003572 7A               [ 4] 3359         LD      A,D             ; Get NMSB
      003573 1F               [ 4] 3360         RRA                     ; Shift NMSB right
      003574 57               [ 4] 3361         LD      D,A             ; Re-save NMSB
      003575 7B               [ 4] 3362         LD      A,E             ; Get LSB
      003576 1F               [ 4] 3363         RRA                     ; Shift LSB right
      003577 5F               [ 4] 3364         LD      E,A             ; Re-save LSB
      003578 78               [ 4] 3365         LD      A,B             ; Get VLSB
      003579 1F               [ 4] 3366         RRA                     ; Shift VLSB right
      00357A 47               [ 4] 3367         LD      B,A             ; Re-save VLSB
      00357B 2D               [ 4] 3368         DEC     L               ; Count bits multiplied
      00357C 7C               [ 4] 3369         LD      A,H             ; Get LSB of multiplier
      00357D C2 5F 35         [10] 3370         JP      NZ,MUL8LP       ; More - Do it
      003580 E1               [10] 3371 POPHRT: POP     HL              ; Restore address of number
      003581 C9               [10] 3372         RET
                                   3373 
      003582 43               [ 4] 3374 BYTSFT: LD      B,E             ; Shift partial product left
      003583 5A               [ 4] 3375         LD      E,D
      003584 51               [ 4] 3376         LD      D,C
      003585 4F               [ 4] 3377         LD      C,A
      003586 C9               [10] 3378         RET
                                   3379 
      003587 CD 70 36         [17] 3380 DIV10:  CALL    STAKFP          ; Save FPREG on stack
      00358A 01 20 84         [10] 3381         LD      BC,#0x8420      ; BCDE = 10.
      00358D 11 00 00         [10] 3382         LD      DE,#0x0000
      003590 CD 80 36         [17] 3383         CALL    FPBCDE          ; Move 10 to FPREG
                                   3384 
      003593 C1               [10] 3385 DIV:    POP     BC              ; Get number from stack
      003594 D1               [10] 3386         POP     DE
      003595 CD 3F 36         [17] 3387 DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
      003598 CA 9B 23         [10] 3388         JP      Z,DZERR         ; Error if division by zero
      00359B 2E FF            [ 7] 3389         LD      L,#-1           ; Flag subtract exponents
      00359D CD FD 35         [17] 3390         CALL    ADDEXP          ; Subtract exponents
      0035A0 34               [11] 3391         INC     (HL)            ; Add 2 to exponent to adjust
      0035A1 34               [11] 3392         INC     (HL)
      0035A2 2B               [ 6] 3393         DEC     HL              ; Point to MSB
      0035A3 7E               [ 7] 3394         LD      A,(HL)          ; Get MSB of dividend
      0035A4 32 12 42         [13] 3395         LD      (DIV3),A        ; Save for subtraction
      0035A7 2B               [ 6] 3396         DEC     HL
      0035A8 7E               [ 7] 3397         LD      A,(HL)          ; Get NMSB of dividend
      0035A9 32 0E 42         [13] 3398         LD      (DIV2),A        ; Save for subtraction
      0035AC 2B               [ 6] 3399         DEC     HL
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 63.
Hexadecimal [24-Bits]



      0035AD 7E               [ 7] 3400         LD      A,(HL)          ; Get MSB of dividend
      0035AE 32 0A 42         [13] 3401         LD      (DIV1),A        ; Save for subtraction
      0035B1 41               [ 4] 3402         LD      B,C             ; Get MSB
      0035B2 EB               [ 4] 3403         EX      DE,HL           ; NMSB,LSB to HL
      0035B3 AF               [ 4] 3404         XOR     A
      0035B4 4F               [ 4] 3405         LD      C,A             ; Clear MSB of quotient
      0035B5 57               [ 4] 3406         LD      D,A             ; Clear NMSB of quotient
      0035B6 5F               [ 4] 3407         LD      E,A             ; Clear LSB of quotient
      0035B7 32 15 42         [13] 3408         LD      (DIV4),A        ; Clear overflow count
      0035BA E5               [11] 3409 DIVLP:  PUSH    HL              ; Save divisor
      0035BB C5               [11] 3410         PUSH    BC
      0035BC 7D               [ 4] 3411         LD      A,L             ; Get LSB of number
      0035BD CD 09 42         [17] 3412         CALL    DIVSUP          ; Subt' divisor from dividend
      0035C0 DE 00            [ 7] 3413         SBC     A,#0            ; Count for overflows
      0035C2 3F               [ 4] 3414         CCF
      0035C3 D2 CD 35         [10] 3415         JP      NC,RESDIV       ; Restore divisor if borrow
      0035C6 32 15 42         [13] 3416         LD      (DIV4),A        ; Re-save overflow count
      0035C9 F1               [10] 3417         POP     AF              ; Scrap divisor
      0035CA F1               [10] 3418         POP     AF
      0035CB 37               [ 4] 3419         SCF                     ; Set carry to
      0035CC D2                    3420         .BYTE      0xD2         ; Skip "POP BC" and "POP HL"
                                   3421 
      0035CD C1               [10] 3422 RESDIV: POP     BC              ; Restore divisor
      0035CE E1               [10] 3423         POP     HL
      0035CF 79               [ 4] 3424         LD      A,C             ; Get MSB of quotient
      0035D0 3C               [ 4] 3425         INC     A
      0035D1 3D               [ 4] 3426         DEC     A
      0035D2 1F               [ 4] 3427         RRA                     ; Bit 0 to bit 7
      0035D3 FA 80 34         [10] 3428         JP      M,RONDB         ; Done - Normalise result
      0035D6 17               [ 4] 3429         RLA                     ; Restore carry
      0035D7 7B               [ 4] 3430         LD      A,E             ; Get LSB of quotient
      0035D8 17               [ 4] 3431         RLA                     ; Double it
      0035D9 5F               [ 4] 3432         LD      E,A             ; Put it back
      0035DA 7A               [ 4] 3433         LD      A,D             ; Get NMSB of quotient
      0035DB 17               [ 4] 3434         RLA                     ; Double it
      0035DC 57               [ 4] 3435         LD      D,A             ; Put it back
      0035DD 79               [ 4] 3436         LD      A,C             ; Get MSB of quotient
      0035DE 17               [ 4] 3437         RLA                     ; Double it
      0035DF 4F               [ 4] 3438         LD      C,A             ; Put it back
      0035E0 29               [11] 3439         ADD     HL,HL           ; Double NMSB,LSB of divisor
      0035E1 78               [ 4] 3440         LD      A,B             ; Get MSB of divisor
      0035E2 17               [ 4] 3441         RLA                     ; Double it
      0035E3 47               [ 4] 3442         LD      B,A             ; Put it back
      0035E4 3A 15 42         [13] 3443         LD      A,(DIV4)        ; Get VLSB of quotient
      0035E7 17               [ 4] 3444         RLA                     ; Double it
      0035E8 32 15 42         [13] 3445         LD      (DIV4),A        ; Put it back
      0035EB 79               [ 4] 3446         LD      A,C             ; Get MSB of quotient
      0035EC B2               [ 4] 3447         OR      D               ; Merge NMSB
      0035ED B3               [ 4] 3448         OR      E               ; Merge LSB
      0035EE C2 BA 35         [10] 3449         JP      NZ,DIVLP        ; Not done - Keep dividing
      0035F1 E5               [11] 3450         PUSH    HL              ; Save divisor
      0035F2 21 E7 42         [10] 3451         LD      HL,#FPEXP       ; Point to exponent
      0035F5 35               [11] 3452         DEC     (HL)            ; Divide by 2
      0035F6 E1               [10] 3453         POP     HL              ; Restore divisor
      0035F7 C2 BA 35         [10] 3454         JP      NZ,DIVLP        ; Ok - Keep going
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 64.
Hexadecimal [24-Bits]



      0035FA C3 A7 23         [10] 3455         JP      OVERR           ; Overflow error
                                   3456 
      0035FD 78               [ 4] 3457 ADDEXP: LD      A,B             ; Get exponent of dividend
      0035FE B7               [ 4] 3458         OR      A               ; Test it
      0035FF CA 21 36         [10] 3459         JP      Z,OVTST3        ; Zero - Result zero
      003602 7D               [ 4] 3460         LD      A,L             ; Get add/subtract flag
      003603 21 E7 42         [10] 3461         LD      HL,#FPEXP       ; Point to exponent
      003606 AE               [ 7] 3462         XOR     (HL)            ; Add or subtract it
      003607 80               [ 4] 3463         ADD     A,B             ; Add the other exponent
      003608 47               [ 4] 3464         LD      B,A             ; Save new exponent
      003609 1F               [ 4] 3465         RRA                     ; Test exponent for overflow
      00360A A8               [ 4] 3466         XOR     B
      00360B 78               [ 4] 3467         LD      A,B             ; Get exponent
      00360C F2 20 36         [10] 3468         JP      P,OVTST2        ; Positive - Test for overflow
      00360F C6 80            [ 7] 3469         ADD     A,#0x80         ; Add excess 128
      003611 77               [ 7] 3470         LD      (HL),A          ; Save new exponent
      003612 CA 80 35         [10] 3471         JP      Z,POPHRT        ; Zero - Result zero
      003615 CD A5 36         [17] 3472         CALL    SIGNS           ; Set MSBs and sign of result
      003618 77               [ 7] 3473         LD      (HL),A          ; Save new exponent
      003619 2B               [ 6] 3474         DEC     HL              ; Point to MSB
      00361A C9               [10] 3475         RET
                                   3476 
      00361B CD 3F 36         [17] 3477 OVTST1: CALL    TSTSGN          ; Test sign of FPREG
      00361E 2F               [ 4] 3478         CPL                     ; Invert sign
      00361F E1               [10] 3479         POP     HL              ; Clean up stack
      003620 B7               [ 4] 3480 OVTST2: OR      A               ; Test if new exponent zero
      003621 E1               [10] 3481 OVTST3: POP     HL              ; Clear off return address
      003622 F2 5F 34         [10] 3482         JP      P,RESZER        ; Result zero
      003625 C3 A7 23         [10] 3483         JP      OVERR           ; Overflow error
                                   3484 
      003628 CD 8B 36         [17] 3485 MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
      00362B 78               [ 4] 3486         LD      A,B             ; Get exponent
      00362C B7               [ 4] 3487         OR      A               ; Is it zero?
      00362D C8               [11] 3488         RET     Z               ; Yes - Result is zero
      00362E C6 02            [ 7] 3489         ADD     A,#2            ; Multiply by 4
      003630 DA A7 23         [10] 3490         JP      C,OVERR         ; Overflow - ?OV Error
      003633 47               [ 4] 3491         LD      B,A             ; Re-save exponent
      003634 CD F9 33         [17] 3492         CALL    FPADD           ; Add BCDE to FPREG (Times 5)
      003637 21 E7 42         [10] 3493         LD      HL,#FPEXP       ; Point to exponent
      00363A 34               [11] 3494         INC     (HL)            ; Double number (Times 10)
      00363B C0               [11] 3495         RET     NZ              ; Ok - Return
      00363C C3 A7 23         [10] 3496         JP      OVERR           ; Overflow error
                                   3497 
      00363F 3A E7 42         [13] 3498 TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
      003642 B7               [ 4] 3499         OR      A
      003643 C8               [11] 3500         RET     Z               ; RETurn if number is zero
      003644 3A E6 42         [13] 3501         LD      A,(FPREG+2)     ; Get MSB of FPREG
      003647 FE                    3502         .BYTE      0xFE         ; Test sign
      003648 2F               [ 4] 3503 RETREL: CPL                     ; Invert sign
      003649 17               [ 4] 3504         RLA                     ; Sign bit to carry
      00364A 9F               [ 4] 3505 FLGDIF: SBC     A,A             ; Carry to all bits of A
      00364B C0               [11] 3506         RET     NZ              ; Return -1 if negative
      00364C 3C               [ 4] 3507         INC     A               ; Bump to +1
      00364D C9               [10] 3508         RET                     ; Positive - Return +1
                                   3509 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 65.
Hexadecimal [24-Bits]



      00364E CD 3F 36         [17] 3510 SGN:    CALL    TSTSGN          ; Test sign of FPREG
      003651 06 88            [ 7] 3511 FLGREL: LD      B,#0x80+8       ; 8 bit integer in exponent
      003653 11 00 00         [10] 3512         LD      DE,#0           ; Zero NMSB and LSB
      003656 21 E7 42         [10] 3513 RETINT: LD      HL,#FPEXP       ; Point to exponent
      003659 4F               [ 4] 3514         LD      C,A             ; CDE = MSB,NMSB and LSB
      00365A 70               [ 7] 3515         LD      (HL),B          ; Save exponent
      00365B 06 00            [ 7] 3516         LD      B,#0            ; CDE = integer to normalise
      00365D 23               [ 6] 3517         INC     HL              ; Point to sign of result
      00365E 36 80            [10] 3518         LD      (HL),#0x80      ; Set sign of result
      003660 17               [ 4] 3519         RLA                     ; Carry = sign of integer
      003661 C3 47 34         [10] 3520         JP      CONPOS          ; Set sign of result
                                   3521 
      003664 CD 3F 36         [17] 3522 ABS:    CALL    TSTSGN          ; Test sign of FPREG
      003667 F0               [11] 3523         RET     P               ; Return if positive
      003668 21 E6 42         [10] 3524 INVSGN: LD      HL,#FPREG+2     ; Point to MSB
      00366B 7E               [ 7] 3525         LD      A,(HL)          ; Get sign of mantissa
      00366C EE 80            [ 7] 3526         XOR     #0x80           ; Invert sign of mantissa
      00366E 77               [ 7] 3527         LD      (HL),A          ; Re-save sign of mantissa
      00366F C9               [10] 3528         RET
                                   3529 
      003670 EB               [ 4] 3530 STAKFP: EX      DE,HL           ; Save code string address
      003671 2A E4 42         [16] 3531         LD      HL,(FPREG)      ; LSB,NLSB of FPREG
      003674 E3               [19] 3532         EX      (SP),HL         ; Stack them,get return
      003675 E5               [11] 3533         PUSH    HL              ; Re-save return
      003676 2A E6 42         [16] 3534         LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
      003679 E3               [19] 3535         EX      (SP),HL         ; Stack them,get return
      00367A E5               [11] 3536         PUSH    HL              ; Re-save return
      00367B EB               [ 4] 3537         EX      DE,HL           ; Restore code string address
      00367C C9               [10] 3538         RET
                                   3539 
      00367D CD 8E 36         [17] 3540 PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
      003680 EB               [ 4] 3541 FPBCDE: EX      DE,HL           ; Save code string address
      003681 22 E4 42         [16] 3542         LD      (FPREG),HL      ; Save LSB,NLSB of number
      003684 60               [ 4] 3543         LD      H,B             ; Exponent of number
      003685 69               [ 4] 3544         LD      L,C             ; MSB of number
      003686 22 E6 42         [16] 3545         LD      (FPREG+2),HL    ; Save MSB and exponent
      003689 EB               [ 4] 3546         EX      DE,HL           ; Restore code string address
      00368A C9               [10] 3547         RET
                                   3548 
      00368B 21 E4 42         [10] 3549 BCDEFP: LD      HL,#FPREG       ; Point to FPREG
      00368E 5E               [ 7] 3550 LOADFP: LD      E,(HL)          ; Get LSB of number
      00368F 23               [ 6] 3551         INC     HL
      003690 56               [ 7] 3552         LD      D,(HL)          ; Get NMSB of number
      003691 23               [ 6] 3553         INC     HL
      003692 4E               [ 7] 3554         LD      C,(HL)          ; Get MSB of number
      003693 23               [ 6] 3555         INC     HL
      003694 46               [ 7] 3556         LD      B,(HL)          ; Get exponent of number
      003695 23               [ 6] 3557 INCHL:  INC     HL              ; Used for conditional "INC HL"
      003696 C9               [10] 3558         RET
                                   3559 
      003697 11 E4 42         [10] 3560 FPTHL:  LD      DE,#FPREG       ; Point to FPREG
      00369A 06 04            [ 7] 3561 DETHL4: LD      B,#4            ; 4 bytes to move
      00369C 1A               [ 7] 3562 DETHLB: LD      A,(DE)          ; Get source
      00369D 77               [ 7] 3563         LD      (HL),A          ; Save destination
      00369E 13               [ 6] 3564         INC     DE              ; Next source
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 66.
Hexadecimal [24-Bits]



      00369F 23               [ 6] 3565         INC     HL              ; Next destination
      0036A0 05               [ 4] 3566         DEC     B               ; Count bytes
      0036A1 C2 9C 36         [10] 3567         JP      NZ,DETHLB       ; Loop if more
      0036A4 C9               [10] 3568         RET
                                   3569 
      0036A5 21 E6 42         [10] 3570 SIGNS:  LD      HL,#FPREG+2     ; Point to MSB of FPREG
      0036A8 7E               [ 7] 3571         LD      A,(HL)          ; Get MSB
      0036A9 07               [ 4] 3572         RLCA                    ; Old sign to carry
      0036AA 37               [ 4] 3573         SCF                     ; Set MSBit
      0036AB 1F               [ 4] 3574         RRA                     ; Set MSBit of MSB
      0036AC 77               [ 7] 3575         LD      (HL),A          ; Save new MSB
      0036AD 3F               [ 4] 3576         CCF                     ; Complement sign
      0036AE 1F               [ 4] 3577         RRA                     ; Old sign to carry
      0036AF 23               [ 6] 3578         INC     HL
      0036B0 23               [ 6] 3579         INC     HL
      0036B1 77               [ 7] 3580         LD      (HL),A          ; Set sign of result
      0036B2 79               [ 4] 3581         LD      A,C             ; Get MSB
      0036B3 07               [ 4] 3582         RLCA                    ; Old sign to carry
      0036B4 37               [ 4] 3583         SCF                     ; Set MSBit
      0036B5 1F               [ 4] 3584         RRA                     ; Set MSBit of MSB
      0036B6 4F               [ 4] 3585         LD      C,A             ; Save MSB
      0036B7 1F               [ 4] 3586         RRA
      0036B8 AE               [ 7] 3587         XOR     (HL)            ; New sign of result
      0036B9 C9               [10] 3588         RET
                                   3589 
      0036BA 78               [ 4] 3590 CMPNUM: LD      A,B             ; Get exponent of number
      0036BB B7               [ 4] 3591         OR      A
      0036BC CA 3F 36         [10] 3592         JP      Z,TSTSGN        ; Zero - Test sign of FPREG
      0036BF 21 48 36         [10] 3593         LD      HL,#RETREL      ; Return relation routine
      0036C2 E5               [11] 3594         PUSH    HL              ; Save for return
      0036C3 CD 3F 36         [17] 3595         CALL    TSTSGN          ; Test sign of FPREG
      0036C6 79               [ 4] 3596         LD      A,C             ; Get MSB of number
      0036C7 C8               [11] 3597         RET     Z               ; FPREG zero - Number's MSB
      0036C8 21 E6 42         [10] 3598         LD      HL,#FPREG+2     ; MSB of FPREG
      0036CB AE               [ 7] 3599         XOR     (HL)            ; Combine signs
      0036CC 79               [ 4] 3600         LD      A,C             ; Get MSB of number
      0036CD F8               [11] 3601         RET     M               ; Exit if signs different
      0036CE CD D4 36         [17] 3602         CALL    CMPFP           ; Compare FP numbers
      0036D1 1F               [ 4] 3603         RRA                     ; Get carry to sign
      0036D2 A9               [ 4] 3604         XOR     C               ; Combine with MSB of number
      0036D3 C9               [10] 3605         RET
                                   3606 
      0036D4 23               [ 6] 3607 CMPFP:  INC     HL              ; Point to exponent
      0036D5 78               [ 4] 3608         LD      A,B             ; Get exponent
      0036D6 BE               [ 7] 3609         CP      (HL)            ; Compare exponents
      0036D7 C0               [11] 3610         RET     NZ              ; Different
      0036D8 2B               [ 6] 3611         DEC     HL              ; Point to MBS
      0036D9 79               [ 4] 3612         LD      A,C             ; Get MSB
      0036DA BE               [ 7] 3613         CP      (HL)            ; Compare MSBs
      0036DB C0               [11] 3614         RET     NZ              ; Different
      0036DC 2B               [ 6] 3615         DEC     HL              ; Point to NMSB
      0036DD 7A               [ 4] 3616         LD      A,D             ; Get NMSB
      0036DE BE               [ 7] 3617         CP      (HL)            ; Compare NMSBs
      0036DF C0               [11] 3618         RET     NZ              ; Different
      0036E0 2B               [ 6] 3619         DEC     HL              ; Point to LSB
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 67.
Hexadecimal [24-Bits]



      0036E1 7B               [ 4] 3620         LD      A,E             ; Get LSB
      0036E2 96               [ 7] 3621         SUB     (HL)            ; Compare LSBs
      0036E3 C0               [11] 3622         RET     NZ              ; Different
      0036E4 E1               [10] 3623         POP     HL              ; Drop RETurn
      0036E5 E1               [10] 3624         POP     HL              ; Drop another RETurn
      0036E6 C9               [10] 3625         RET
                                   3626 
      0036E7 47               [ 4] 3627 FPINT:  LD      B,A             ; <- Move
      0036E8 4F               [ 4] 3628         LD      C,A             ; <- exponent
      0036E9 57               [ 4] 3629         LD      D,A             ; <- to all
      0036EA 5F               [ 4] 3630         LD      E,A             ; <- bits
      0036EB B7               [ 4] 3631         OR      A               ; Test exponent
      0036EC C8               [11] 3632         RET     Z               ; Zero - Return zero
      0036ED E5               [11] 3633         PUSH    HL              ; Save pointer to number
      0036EE CD 8B 36         [17] 3634         CALL    BCDEFP          ; Move FPREG to BCDE
      0036F1 CD A5 36         [17] 3635         CALL    SIGNS           ; Set MSBs & sign of result
      0036F4 AE               [ 7] 3636         XOR     (HL)            ; Combine with sign of FPREG
      0036F5 67               [ 4] 3637         LD      H,A             ; Save combined signs
      0036F6 FC 0B 37         [17] 3638         CALL    M,DCBCDE        ; Negative - Decrement BCDE
      0036F9 3E 98            [ 7] 3639         LD      A,#0x80+24      ; 24 bits
      0036FB 90               [ 4] 3640         SUB     B               ; Bits to shift
      0036FC CD BE 34         [17] 3641         CALL    SCALE           ; Shift BCDE
      0036FF 7C               [ 4] 3642         LD      A,H             ; Get combined sign
      003700 17               [ 4] 3643         RLA                     ; Sign to carry
      003701 DC 91 34         [17] 3644         CALL    C,FPROND        ; Negative - Round number up
      003704 06 00            [ 7] 3645         LD      B,#0            ; Zero exponent
      003706 DC AA 34         [17] 3646         CALL    C,COMPL         ; If negative make positive
      003709 E1               [10] 3647         POP     HL              ; Restore pointer to number
      00370A C9               [10] 3648         RET
                                   3649 
      00370B 1B               [ 6] 3650 DCBCDE: DEC     DE              ; Decrement BCDE
      00370C 7A               [ 4] 3651         LD      A,D             ; Test LSBs
      00370D A3               [ 4] 3652         AND     E
      00370E 3C               [ 4] 3653         INC     A
      00370F C0               [11] 3654         RET     NZ              ; Exit if LSBs not FFFF
      003710 0B               [ 6] 3655         DEC     BC              ; Decrement MSBs
      003711 C9               [10] 3656         RET
                                   3657 
      003712 21 E7 42         [10] 3658 INT:    LD      HL,#FPEXP       ; Point to exponent
      003715 7E               [ 7] 3659         LD      A,(HL)          ; Get exponent
      003716 FE 98            [ 7] 3660         CP      #0x80+24        ; Integer accuracy only?
      003718 3A E4 42         [13] 3661         LD      A,(FPREG)       ; Get LSB
      00371B D0               [11] 3662         RET     NC              ; Yes - Already integer
      00371C 7E               [ 7] 3663         LD      A,(HL)          ; Get exponent
      00371D CD E7 36         [17] 3664         CALL    FPINT           ; F.P to integer
      003720 36 98            [10] 3665         LD      (HL),#0x80+24   ; Save 24 bit integer
      003722 7B               [ 4] 3666         LD      A,E             ; Get LSB of number
      003723 F5               [11] 3667         PUSH    AF              ; Save LSB
      003724 79               [ 4] 3668         LD      A,C             ; Get MSB of number
      003725 17               [ 4] 3669         RLA                     ; Sign to carry
      003726 CD 47 34         [17] 3670         CALL    CONPOS          ; Set sign of result
      003729 F1               [10] 3671         POP     AF              ; Restore LSB of number
      00372A C9               [10] 3672         RET
                                   3673 
      00372B 21 00 00         [10] 3674 MLDEBC: LD      HL,#0           ; Clear partial product
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 68.
Hexadecimal [24-Bits]



      00372E 78               [ 4] 3675         LD      A,B             ; Test multiplier
      00372F B1               [ 4] 3676         OR      C
      003730 C8               [11] 3677         RET     Z               ; Return zero if zero
      003731 3E 10            [ 7] 3678         LD      A,#16           ; 16 bits
      003733 29               [11] 3679 MLDBLP: ADD     HL,HL           ; Shift P.P left
      003734 DA 6B 2F         [10] 3680         JP      C,BSERR         ; ?BS Error if overflow
      003737 EB               [ 4] 3681         EX      DE,HL
      003738 29               [11] 3682         ADD     HL,HL           ; Shift multiplier left
      003739 EB               [ 4] 3683         EX      DE,HL
      00373A D2 41 37         [10] 3684         JP      NC,NOMLAD       ; Bit was zero - No add
      00373D 09               [11] 3685         ADD     HL,BC           ; Add multiplicand
      00373E DA 6B 2F         [10] 3686         JP      C,BSERR         ; ?BS Error if overflow
      003741 3D               [ 4] 3687 NOMLAD: DEC     A               ; Count bits
      003742 C2 33 37         [10] 3688         JP      NZ,MLDBLP       ; More
      003745 C9               [10] 3689         RET
                                   3690 
      003746 FE 2D            [ 7] 3691 ASCTFP: CP      #'-'            ; Negative?
      003748 F5               [11] 3692         PUSH    AF              ; Save it and flags
      003749 CA 52 37         [10] 3693         JP      Z,CNVNUM        ; Yes - Convert number
      00374C FE 2B            [ 7] 3694         CP      #'+'            ; Positive?
      00374E CA 52 37         [10] 3695         JP      Z,CNVNUM        ; Yes - Convert number
      003751 2B               [ 6] 3696         DEC     HL              ; DEC 'cos GETCHR INCs
      003752 CD 5F 34         [17] 3697 CNVNUM: CALL    RESZER          ; Set result to zero
      003755 47               [ 4] 3698         LD      B,A             ; Digits after point counter
      003756 57               [ 4] 3699         LD      D,A             ; Sign of exponent
      003757 5F               [ 4] 3700         LD      E,A             ; Exponent of ten
      003758 2F               [ 4] 3701         CPL
      003759 4F               [ 4] 3702         LD      C,A             ; Before or after point flag
      00375A CD F0 27         [17] 3703 MANLP:  CALL    GETCHR          ; Get next character
      00375D DA A3 37         [10] 3704         JP      C,ADDIG         ; Digit - Add to number
      003760 FE 2E            [ 7] 3705         CP      #'.'
      003762 CA 7E 37         [10] 3706         JP      Z,DPOINT        ; '.' - Flag point
      003765 FE 45            [ 7] 3707         CP      #'E'
      003767 C2 82 37         [10] 3708         JP      NZ,CONEXP       ; Not 'E' - Scale number
      00376A CD F0 27         [17] 3709         CALL    GETCHR          ; Get next character
      00376D CD 96 2D         [17] 3710         CALL    SGNEXP          ; Get sign of exponent
      003770 CD F0 27         [17] 3711 EXPLP:  CALL    GETCHR          ; Get next character
      003773 DA C5 37         [10] 3712         JP      C,EDIGIT        ; Digit - Add to exponent
      003776 14               [ 4] 3713         INC     D               ; Is sign negative?
      003777 C2 82 37         [10] 3714         JP      NZ,CONEXP       ; No - Scale number
      00377A AF               [ 4] 3715         XOR     A
      00377B 93               [ 4] 3716         SUB     E               ; Negate exponent
      00377C 5F               [ 4] 3717         LD      E,A             ; And re-save it
      00377D 0C               [ 4] 3718         INC     C               ; Flag end of number
      00377E 0C               [ 4] 3719 DPOINT: INC     C               ; Flag point passed
      00377F CA 5A 37         [10] 3720         JP      Z,MANLP         ; Zero - Get another digit
      003782 E5               [11] 3721 CONEXP: PUSH    HL              ; Save code string address
      003783 7B               [ 4] 3722         LD      A,E             ; Get exponent
      003784 90               [ 4] 3723         SUB     B               ; Subtract digits after point
      003785 F4 9B 37         [17] 3724 SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
      003788 F2 91 37         [10] 3725         JP      P,ENDCON        ; Positive - All done
      00378B F5               [11] 3726         PUSH    AF              ; Save number of times to /10
      00378C CD 87 35         [17] 3727         CALL    DIV10           ; Divide by 10
      00378F F1               [10] 3728         POP     AF              ; Restore count
      003790 3C               [ 4] 3729         INC     A               ; Count divides
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 69.
Hexadecimal [24-Bits]



                                   3730 
      003791 C2 85 37         [10] 3731 ENDCON: JP      NZ,SCALMI       ; More to do
      003794 D1               [10] 3732         POP     DE              ; Restore code string address
      003795 F1               [10] 3733         POP     AF              ; Restore sign of number
      003796 CC 68 36         [17] 3734         CALL    Z,INVSGN        ; Negative - Negate number
      003799 EB               [ 4] 3735         EX      DE,HL           ; Code string address to HL
      00379A C9               [10] 3736         RET
                                   3737 
      00379B C8               [11] 3738 SCALPL: RET     Z               ; Exit if no scaling needed
      00379C F5               [11] 3739 MULTEN: PUSH    AF              ; Save count
      00379D CD 28 36         [17] 3740         CALL    MLSP10          ; Multiply number by 10
      0037A0 F1               [10] 3741         POP     AF              ; Restore count
      0037A1 3D               [ 4] 3742         DEC     A               ; Count multiplies
      0037A2 C9               [10] 3743         RET
                                   3744 
      0037A3 D5               [11] 3745 ADDIG:  PUSH    DE              ; Save sign of exponent
      0037A4 57               [ 4] 3746         LD      D,A             ; Save digit
      0037A5 78               [ 4] 3747         LD      A,B             ; Get digits after point
      0037A6 89               [ 4] 3748         ADC     A,C             ; Add one if after point
      0037A7 47               [ 4] 3749         LD      B,A             ; Re-save counter
      0037A8 C5               [11] 3750         PUSH    BC              ; Save point flags
      0037A9 E5               [11] 3751         PUSH    HL              ; Save code string address
      0037AA D5               [11] 3752         PUSH    DE              ; Save digit
      0037AB CD 28 36         [17] 3753         CALL    MLSP10          ; Multiply number by 10
      0037AE F1               [10] 3754         POP     AF              ; Restore digit
      0037AF D6 30            [ 7] 3755         SUB     #'0'            ; Make it absolute
      0037B1 CD BA 37         [17] 3756         CALL    RSCALE          ; Re-scale number
      0037B4 E1               [10] 3757         POP     HL              ; Restore code string address
      0037B5 C1               [10] 3758         POP     BC              ; Restore point flags
      0037B6 D1               [10] 3759         POP     DE              ; Restore sign of exponent
      0037B7 C3 5A 37         [10] 3760         JP      MANLP           ; Get another digit
                                   3761 
      0037BA CD 70 36         [17] 3762 RSCALE: CALL    STAKFP          ; Put number on stack
      0037BD CD 51 36         [17] 3763         CALL    FLGREL          ; Digit to add to FPREG
      0037C0 C1               [10] 3764 PADD:   POP     BC              ; Restore number
      0037C1 D1               [10] 3765         POP     DE
      0037C2 C3 F9 33         [10] 3766         JP      FPADD           ; Add BCDE to FPREG and return
                                   3767 
      0037C5 7B               [ 4] 3768 EDIGIT: LD      A,E             ; Get digit
      0037C6 07               [ 4] 3769         RLCA                    ; Times 2
      0037C7 07               [ 4] 3770         RLCA                    ; Times 4
      0037C8 83               [ 4] 3771         ADD     A,E             ; Times 5
      0037C9 07               [ 4] 3772         RLCA                    ; Times 10
      0037CA 86               [ 7] 3773         ADD     A,(HL)          ; Add next digit
      0037CB D6 30            [ 7] 3774         SUB     #'0'            ; Make it absolute
      0037CD 5F               [ 4] 3775         LD      E,A             ; Save new digit
      0037CE C3 70 37         [10] 3776         JP      EXPLP           ; Look for another digit
                                   3777 
      0037D1 E5               [11] 3778 LINEIN: PUSH    HL              ; Save code string address
      0037D2 21 30 23         [10] 3779         LD      HL,#INMSG       ; Output " in "
      0037D5 CD 36 31         [17] 3780         CALL    PRS             ; Output string at HL
      0037D8 E1               [10] 3781         POP     HL              ; Restore code string address
      0037D9 EB               [ 4] 3782 PRNTHL: EX      DE,HL           ; Code string address to DE
      0037DA AF               [ 4] 3783         XOR     A
      0037DB 06 98            [ 7] 3784         LD      B,#0x80+24        ; 24 bits
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 70.
Hexadecimal [24-Bits]



      0037DD CD 56 36         [17] 3785         CALL    RETINT          ; Return the integer
      0037E0 21 35 31         [10] 3786         LD      HL,#PRNUMS      ; Print number string
      0037E3 E5               [11] 3787         PUSH    HL              ; Save for return
      0037E4 21 E9 42         [10] 3788 NUMASC: LD      HL,#PBUFF       ; Convert number to ASCII
      0037E7 E5               [11] 3789         PUSH    HL              ; Save for return
      0037E8 CD 3F 36         [17] 3790         CALL    TSTSGN          ; Test sign of FPREG
      0037EB 36 20            [10] 3791         LD      (HL),#' '       ; Space at start
      0037ED F2 F2 37         [10] 3792         JP      P,SPCFST        ; Positive - Space to start
      0037F0 36 2D            [10] 3793         LD      (HL),#'-'       ; '-' sign at start
      0037F2 23               [ 6] 3794 SPCFST: INC     HL              ; First byte of number
      0037F3 36 30            [10] 3795         LD      (HL),#'0'       ; '0' if zero
      0037F5 CA A8 38         [10] 3796         JP      Z,JSTZER        ; Return '0' if zero
      0037F8 E5               [11] 3797         PUSH    HL              ; Save buffer address
      0037F9 FC 68 36         [17] 3798         CALL    M,INVSGN        ; Negate FPREG if negative
      0037FC AF               [ 4] 3799         XOR     A               ; Zero A
      0037FD F5               [11] 3800         PUSH    AF              ; Save it
      0037FE CD AE 38         [17] 3801         CALL    RNGTST          ; Test number is in range
      003801 01 43 91         [10] 3802 SIXDIG: LD      BC,#0x9143      ; BCDE - 99999.9
      003804 11 F8 4F         [10] 3803         LD      DE,#0x4FF8
      003807 CD BA 36         [17] 3804         CALL    CMPNUM          ; Compare numbers
      00380A B7               [ 4] 3805         OR      A
      00380B E2 1F 38         [10] 3806         JP      PO,INRNG        ; > 99999.9 - Sort it out
      00380E F1               [10] 3807         POP     AF              ; Restore count
      00380F CD 9C 37         [17] 3808         CALL    MULTEN          ; Multiply by ten
      003812 F5               [11] 3809         PUSH    AF              ; Re-save count
      003813 C3 01 38         [10] 3810         JP      SIXDIG          ; Test it again
                                   3811 
      003816 CD 87 35         [17] 3812 GTSIXD: CALL    DIV10           ; Divide by 10
      003819 F1               [10] 3813         POP     AF              ; Get count
      00381A 3C               [ 4] 3814         INC     A               ; Count divides
      00381B F5               [11] 3815         PUSH    AF              ; Re-save count
      00381C CD AE 38         [17] 3816         CALL    RNGTST          ; Test number is in range
      00381F CD E7 33         [17] 3817 INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
      003822 3C               [ 4] 3818         INC     A
      003823 CD E7 36         [17] 3819         CALL    FPINT           ; F.P to integer
      003826 CD 80 36         [17] 3820         CALL    FPBCDE          ; Move BCDE to FPREG
      003829 01 06 03         [10] 3821         LD      BC,#0x0306      ; 1E+06 to 1E-03 range
      00382C F1               [10] 3822         POP     AF              ; Restore count
      00382D 81               [ 4] 3823         ADD     A,C             ; 6 digits before point
      00382E 3C               [ 4] 3824         INC     A               ; Add one
      00382F FA 3B 38         [10] 3825         JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
      003832 FE 08            [ 7] 3826         CP      #6+1+1          ; More than 999999 ?
      003834 D2 3B 38         [10] 3827         JP      NC,MAKNUM       ; Yes - Do it in 'E' form
      003837 3C               [ 4] 3828         INC     A               ; Adjust for exponent
      003838 47               [ 4] 3829         LD      B,A             ; Exponent of number
      003839 3E 02            [ 7] 3830         LD      A,#2            ; Make it zero after
                                   3831 
      00383B 3D               [ 4] 3832 MAKNUM: DEC     A               ; Adjust for digits to do
      00383C 3D               [ 4] 3833         DEC     A
      00383D E1               [10] 3834         POP     HL              ; Restore buffer address
      00383E F5               [11] 3835         PUSH    AF              ; Save count
      00383F 11 C1 38         [10] 3836         LD      DE,#POWERS      ; Powers of ten
      003842 05               [ 4] 3837         DEC     B               ; Count digits before point
      003843 C2 4C 38         [10] 3838         JP      NZ,DIGTXT       ; Not zero - Do number
      003846 36 2E            [10] 3839         LD      (HL),#'.'       ; Save point
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 71.
Hexadecimal [24-Bits]



      003848 23               [ 6] 3840         INC     HL              ; Move on
      003849 36 30            [10] 3841         LD      (HL),#'0'       ; Save zero
      00384B 23               [ 6] 3842         INC     HL              ; Move on
      00384C 05               [ 4] 3843 DIGTXT: DEC     B               ; Count digits before point
      00384D 36 2E            [10] 3844         LD      (HL),#'.'       ; Save point in case
      00384F CC 95 36         [17] 3845         CALL    Z,INCHL         ; Last digit - move on
      003852 C5               [11] 3846         PUSH    BC              ; Save digits before point
      003853 E5               [11] 3847         PUSH    HL              ; Save buffer address
      003854 D5               [11] 3848         PUSH    DE              ; Save powers of ten
      003855 CD 8B 36         [17] 3849         CALL    BCDEFP          ; Move FPREG to BCDE
      003858 E1               [10] 3850         POP     HL              ; Powers of ten table
      003859 06 2F            [ 7] 3851         LD      B, #'0'-1       ; ASCII '0' - 1
      00385B 04               [ 4] 3852 TRYAGN: INC     B               ; Count subtractions
      00385C 7B               [ 4] 3853         LD      A,E             ; Get LSB
      00385D 96               [ 7] 3854         SUB     (HL)            ; Subtract LSB
      00385E 5F               [ 4] 3855         LD      E,A             ; Save LSB
      00385F 23               [ 6] 3856         INC     HL
      003860 7A               [ 4] 3857         LD      A,D             ; Get NMSB
      003861 9E               [ 7] 3858         SBC     A,(HL)          ; Subtract NMSB
      003862 57               [ 4] 3859         LD      D,A             ; Save NMSB
      003863 23               [ 6] 3860         INC     HL
      003864 79               [ 4] 3861         LD      A,C             ; Get MSB
      003865 9E               [ 7] 3862         SBC     A,(HL)          ; Subtract MSB
      003866 4F               [ 4] 3863         LD      C,A             ; Save MSB
      003867 2B               [ 6] 3864         DEC     HL              ; Point back to start
      003868 2B               [ 6] 3865         DEC     HL
      003869 D2 5B 38         [10] 3866         JP      NC,TRYAGN       ; No overflow - Try again
      00386C CD 9E 34         [17] 3867         CALL    PLUCDE          ; Restore number
      00386F 23               [ 6] 3868         INC     HL              ; Start of next number
      003870 CD 80 36         [17] 3869         CALL    FPBCDE          ; Move BCDE to FPREG
      003873 EB               [ 4] 3870         EX      DE,HL           ; Save point in table
      003874 E1               [10] 3871         POP     HL              ; Restore buffer address
      003875 70               [ 7] 3872         LD      (HL),B          ; Save digit in buffer
      003876 23               [ 6] 3873         INC     HL              ; And move on
      003877 C1               [10] 3874         POP     BC              ; Restore digit count
      003878 0D               [ 4] 3875         DEC     C               ; Count digits
      003879 C2 4C 38         [10] 3876         JP      NZ,DIGTXT       ; More - Do them
      00387C 05               [ 4] 3877         DEC     B               ; Any decimal part?
      00387D CA 8C 38         [10] 3878         JP      Z,DOEBIT        ; No - Do 'E' bit
      003880 2B               [ 6] 3879 SUPTLZ: DEC     HL              ; Move back through buffer
      003881 7E               [ 7] 3880         LD      A,(HL)          ; Get character
      003882 FE 30            [ 7] 3881         CP      #'0'            ; '0' character?
      003884 CA 80 38         [10] 3882         JP      Z,SUPTLZ        ; Yes - Look back for more
      003887 FE 2E            [ 7] 3883         CP      #'.'            ; A decimal point?
      003889 C4 95 36         [17] 3884         CALL    NZ,INCHL        ; Move back over digit
                                   3885 
      00388C F1               [10] 3886 DOEBIT: POP     AF              ; Get 'E' flag
      00388D CA AB 38         [10] 3887         JP      Z,NOENED        ; No 'E' needed - End buffer
      003890 36 45            [10] 3888         LD      (HL),#'E'       ; Put 'E' in buffer
      003892 23               [ 6] 3889         INC     HL              ; And move on
      003893 36 2B            [10] 3890         LD      (HL),#'+'       ; Put '+' in buffer
      003895 F2 9C 38         [10] 3891         JP      P,OUTEXP        ; Positive - Output exponent
      003898 36 2D            [10] 3892         LD      (HL),#'-'       ; Put '-' in buffer
      00389A 2F               [ 4] 3893         CPL                     ; Negate exponent
      00389B 3C               [ 4] 3894         INC     A
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 72.
Hexadecimal [24-Bits]



      00389C 06 2F            [ 7] 3895 OUTEXP: LD      B,#'0'-1         ; ASCII '0' - 1
      00389E 04               [ 4] 3896 EXPTEN: INC     B               ; Count subtractions
      00389F D6 0A            [ 7] 3897         SUB     #10              ; Tens digit
      0038A1 D2 9E 38         [10] 3898         JP      NC,EXPTEN       ; More to do
      0038A4 C6 3A            [ 7] 3899         ADD     A,#'0'+10        ; Restore and make ASCII
      0038A6 23               [ 6] 3900         INC     HL              ; Move on
      0038A7 70               [ 7] 3901         LD      (HL),B          ; Save MSB of exponent
      0038A8 23               [ 6] 3902 JSTZER: INC     HL              ;
      0038A9 77               [ 7] 3903         LD      (HL),A          ; Save LSB of exponent
      0038AA 23               [ 6] 3904         INC     HL
      0038AB 71               [ 7] 3905 NOENED: LD      (HL),C          ; Mark end of buffer
      0038AC E1               [10] 3906         POP     HL              ; Restore code string address
      0038AD C9               [10] 3907         RET
                                   3908 
      0038AE 01 74 94         [10] 3909 RNGTST: LD      BC,#0x9474      ; BCDE = 999999.
      0038B1 11 F7 23         [10] 3910         LD      DE,#0x23F7
      0038B4 CD BA 36         [17] 3911         CALL    CMPNUM          ; Compare numbers
      0038B7 B7               [ 4] 3912         OR      A
      0038B8 E1               [10] 3913         POP     HL              ; Return address to HL
      0038B9 E2 16 38         [10] 3914         JP      PO,GTSIXD       ; Too big - Divide by ten
      0038BC E9               [ 4] 3915         JP      (HL)            ; Otherwise return to caller
                                   3916 
      0038BD 00 00 00 80           3917 HALF:   .BYTE      0x00,0x00,0x00,0x80 ; 0.5
                                   3918 
      0038C1 A0 86 01              3919 POWERS: .BYTE      0xA0,0x86,0x01  ; 100000
      0038C4 10 27 00              3920         .BYTE      0x10,0x27,0x00  ;  10000
      0038C7 E8 03 00              3921         .BYTE      0xE8,0x03,0x00  ;   1000
      0038CA 64 00 00              3922         .BYTE      0x64,0x00,0x00  ;    100
      0038CD 0A 00 00              3923         .BYTE      0x0A,0x00,0x00  ;     10
      0038D0 01 00 00              3924         .BYTE      0x01,0x00,0x00  ;      1
                                   3925 
      0038D3 21 68 36         [10] 3926 NEGAFT: LD  HL,#INVSGN          ; Negate result
      0038D6 E3               [19] 3927         EX      (SP),HL         ; To be done after caller
      0038D7 E9               [ 4] 3928         JP      (HL)            ; Return to caller
                                   3929 
      0038D8 CD 70 36         [17] 3930 SQR:    CALL    STAKFP          ; Put value on stack
      0038DB 21 BD 38         [10] 3931         LD      HL,#HALF        ; Set power to 1/2
      0038DE CD 7D 36         [17] 3932         CALL    PHLTFP          ; Move 1/2 to FPREG
                                   3933 
      0038E1 C1               [10] 3934 POWER:  POP     BC              ; Get base
      0038E2 D1               [10] 3935         POP     DE
      0038E3 CD 3F 36         [17] 3936         CALL    TSTSGN          ; Test sign of power
      0038E6 78               [ 4] 3937         LD      A,B             ; Get exponent of base
      0038E7 CA 26 39         [10] 3938         JP      Z,EXP           ; Make result 1 if zero
      0038EA F2 F1 38         [10] 3939         JP      P,POWER1        ; Positive base - Ok
      0038ED B7               [ 4] 3940         OR      A               ; Zero to negative power?
      0038EE CA 9B 23         [10] 3941         JP      Z,DZERR         ; Yes - ?/0 Error
      0038F1 B7               [ 4] 3942 POWER1: OR      A               ; Base zero?
      0038F2 CA 60 34         [10] 3943         JP      Z,SAVEXP        ; Yes - Return zero
      0038F5 D5               [11] 3944         PUSH    DE              ; Save base
      0038F6 C5               [11] 3945         PUSH    BC
      0038F7 79               [ 4] 3946         LD      A,C             ; Get MSB of base
      0038F8 F6 7F            [ 7] 3947         OR      #0b01111111     ; Get sign status
      0038FA CD 8B 36         [17] 3948         CALL    BCDEFP          ; Move power to BCDE
      0038FD F2 0E 39         [10] 3949         JP      P,POWER2        ; Positive base - Ok
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 73.
Hexadecimal [24-Bits]



      003900 D5               [11] 3950         PUSH    DE              ; Save power
      003901 C5               [11] 3951         PUSH    BC
      003902 CD 12 37         [17] 3952         CALL    INT             ; Get integer of power
      003905 C1               [10] 3953         POP     BC              ; Restore power
      003906 D1               [10] 3954         POP     DE
      003907 F5               [11] 3955         PUSH    AF              ; MSB of base
      003908 CD BA 36         [17] 3956         CALL    CMPNUM          ; Power an integer?
      00390B E1               [10] 3957         POP     HL              ; Restore MSB of base
      00390C 7C               [ 4] 3958         LD      A,H             ; but don't affect flags
      00390D 1F               [ 4] 3959         RRA                     ; Exponent odd or even?
      00390E E1               [10] 3960 POWER2: POP     HL              ; Restore MSB and exponent
      00390F 22 E6 42         [16] 3961         LD      (FPREG+2),HL    ; Save base in FPREG
      003912 E1               [10] 3962         POP     HL              ; LSBs of base
      003913 22 E4 42         [16] 3963         LD      (FPREG),HL      ; Save in FPREG
      003916 DC D3 38         [17] 3964         CALL    C,NEGAFT        ; Odd power - Negate result
      003919 CC 68 36         [17] 3965         CALL    Z,INVSGN        ; Negative base - Negate it
      00391C D5               [11] 3966         PUSH    DE              ; Save power
      00391D C5               [11] 3967         PUSH    BC
      00391E CD F3 34         [17] 3968         CALL    LOG             ; Get LOG of base
      003921 C1               [10] 3969         POP     BC              ; Restore power
      003922 D1               [10] 3970         POP     DE
      003923 CD 34 35         [17] 3971         CALL    FPMULT          ; Multiply LOG by power
                                   3972 
      003926 CD 70 36         [17] 3973 EXP:    CALL    STAKFP          ; Put value on stack
      003929 01 38 81         [10] 3974         LD      BC,#0x08138     ; BCDE = 1/Ln(2)
      00392C 11 3B AA         [10] 3975         LD      DE,#0x0AA3B
      00392F CD 34 35         [17] 3976         CALL    FPMULT          ; Multiply value by 1/LN(2)
      003932 3A E7 42         [13] 3977         LD      A,(FPEXP)       ; Get exponent
      003935 FE 88            [ 7] 3978         CP      #0x80+8         ; Is it in range?
      003937 D2 1B 36         [10] 3979         JP      NC,OVTST1       ; No - Test for overflow
      00393A CD 12 37         [17] 3980         CALL    INT             ; Get INT of FPREG
      00393D C6 80            [ 7] 3981         ADD     A,#0x80         ; For excess 128
      00393F C6 02            [ 7] 3982         ADD     A,#2            ; Exponent > 126?
      003941 DA 1B 36         [10] 3983         JP      C,OVTST1        ; Yes - Test for overflow
      003944 F5               [11] 3984         PUSH    AF              ; Save scaling factor
      003945 21 E2 34         [10] 3985         LD      HL,#UNITY       ; Point to 1.
      003948 CD EA 33         [17] 3986         CALL    ADDPHL          ; Add 1 to FPREG
      00394B CD 2B 35         [17] 3987         CALL    MULLN2          ; Multiply by LN(2)
      00394E F1               [10] 3988         POP     AF              ; Restore scaling factor
      00394F C1               [10] 3989         POP     BC              ; Restore exponent
      003950 D1               [10] 3990         POP     DE
      003951 F5               [11] 3991         PUSH    AF              ; Save scaling factor
      003952 CD F6 33         [17] 3992         CALL    SUBCDE          ; Subtract exponent from FPREG
      003955 CD 68 36         [17] 3993         CALL    INVSGN          ; Negate result
      003958 21 66 39         [10] 3994         LD      HL,#EXPTAB      ; Coefficient table
      00395B CD 96 39         [17] 3995         CALL    SMSER1          ; Sum the series
      00395E 11 00 00         [10] 3996         LD      DE,#0           ; Zero LSBs
      003961 C1               [10] 3997         POP     BC              ; Scaling factor
      003962 4A               [ 4] 3998         LD      C,D             ; Zero MSB
      003963 C3 34 35         [10] 3999         JP      FPMULT          ; Scale result to correct value
                                   4000 
      003966 08                    4001 EXPTAB: .BYTE      8                       ; Table used by EXP
      003967 40 2E 94 74           4002         .BYTE      0x40,0x2E,0x94,0x74     ; -1/7! (-1/5040)
      00396B 70 4F 2E 77           4003         .BYTE      0x70,0x4F,0x2E,0x77     ;  1/6! ( 1/720)
      00396F 6E 02 88 7A           4004         .BYTE      0x6E,0x02,0x88,0x7A     ; -1/5! (-1/120)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 74.
Hexadecimal [24-Bits]



      003973 E6 A0 2A 7C           4005         .BYTE      0xE6,0xA0,0x2A,0x7C     ;  1/4! ( 1/24)
      003977 50 AA AA 7E           4006         .BYTE      0x50,0xAA,0xAA,0x7E     ; -1/3! (-1/6)
      00397B FF FF 7F 7F           4007         .BYTE      0xFF,0xFF,0x7F,0x7F     ;  1/2! ( 1/2)
      00397F 00 00 80 81           4008         .BYTE      0x00,0x00,0x80,0x81     ; -1/1! (-1/1)
      003983 00 00 00 81           4009         .BYTE      0x00,0x00,0x00,0x81     ;  1/0! ( 1/1)
                                   4010 
      003987 CD 70 36         [17] 4011 SUMSER: CALL    STAKFP          ; Put FPREG on stack
      00398A 11 32 35         [10] 4012         LD      DE,#MULT        ; Multiply by "X"
      00398D D5               [11] 4013         PUSH    DE              ; To be done after
      00398E E5               [11] 4014         PUSH    HL              ; Save address of table
      00398F CD 8B 36         [17] 4015         CALL    BCDEFP          ; Move FPREG to BCDE
      003992 CD 34 35         [17] 4016         CALL    FPMULT          ; Square the value
      003995 E1               [10] 4017         POP     HL              ; Restore address of table
      003996 CD 70 36         [17] 4018 SMSER1: CALL    STAKFP          ; Put value on stack
      003999 7E               [ 7] 4019         LD      A,(HL)          ; Get number of coefficients
      00399A 23               [ 6] 4020         INC     HL              ; Point to start of table
      00399B CD 7D 36         [17] 4021         CALL    PHLTFP          ; Move coefficient to FPREG
      00399E 06                    4022         .BYTE      0x06         ; Skip "POP AF"
      00399F F1               [10] 4023 SUMLP:  POP     AF              ; Restore count
      0039A0 C1               [10] 4024         POP     BC              ; Restore number
      0039A1 D1               [10] 4025         POP     DE
      0039A2 3D               [ 4] 4026         DEC     A               ; Cont coefficients
      0039A3 C8               [11] 4027         RET     Z               ; All done
      0039A4 D5               [11] 4028         PUSH    DE              ; Save number
      0039A5 C5               [11] 4029         PUSH    BC
      0039A6 F5               [11] 4030         PUSH    AF              ; Save count
      0039A7 E5               [11] 4031         PUSH    HL              ; Save address in table
      0039A8 CD 34 35         [17] 4032         CALL    FPMULT          ; Multiply FPREG by BCDE
      0039AB E1               [10] 4033         POP     HL              ; Restore address in table
      0039AC CD 8E 36         [17] 4034         CALL    LOADFP          ; Number at HL to BCDE
      0039AF E5               [11] 4035         PUSH    HL              ; Save address in table
      0039B0 CD F9 33         [17] 4036         CALL    FPADD           ; Add coefficient to FPREG
      0039B3 E1               [10] 4037         POP     HL              ; Restore address in table
      0039B4 C3 9F 39         [10] 4038         JP      SUMLP           ; More coefficients
                                   4039 
      0039B7 CD 3F 36         [17] 4040 RND:    CALL    TSTSGN          ; Test sign of FPREG
      0039BA 21 19 42         [10] 4041         LD      HL,#SEED+2      ; Random number seed
      0039BD FA 18 3A         [10] 4042         JP      M,RESEED        ; Negative - Re-seed
      0039C0 21 3A 42         [10] 4043         LD      HL,#LSTRND      ; Last random number
      0039C3 CD 7D 36         [17] 4044         CALL    PHLTFP          ; Move last RND to FPREG
      0039C6 21 19 42         [10] 4045         LD      HL,#SEED+2      ; Random number seed
      0039C9 C8               [11] 4046         RET     Z               ; Return if RND(0)
      0039CA 86               [ 7] 4047         ADD     A,(HL)          ; Add (SEED)+2)
      0039CB E6 07            [ 7] 4048         AND     #0b00000111     ; 0 to 7
      0039CD 06 00            [ 7] 4049         LD      B,#0
      0039CF 77               [ 7] 4050         LD      (HL),A          ; Re-save seed
      0039D0 23               [ 6] 4051         INC     HL              ; Move to coefficient table
      0039D1 87               [ 4] 4052         ADD     A,A             ; 4 bytes
      0039D2 87               [ 4] 4053         ADD     A,A             ; per entry
      0039D3 4F               [ 4] 4054         LD      C,A             ; BC = Offset into table
      0039D4 09               [11] 4055         ADD     HL,BC           ; Point to coefficient
      0039D5 CD 8E 36         [17] 4056         CALL    LOADFP          ; Coefficient to BCDE
      0039D8 CD 34 35         [17] 4057         CALL    FPMULT  ;       ; Multiply FPREG by coefficient
      0039DB 3A 18 42         [13] 4058         LD      A,(SEED+1)      ; Get (SEED+1)
      0039DE 3C               [ 4] 4059         INC     A               ; Add 1
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 75.
Hexadecimal [24-Bits]



      0039DF E6 03            [ 7] 4060         AND     #0b00000011     ; 0 to 3
      0039E1 06 00            [ 7] 4061         LD      B,#0
      0039E3 FE 01            [ 7] 4062         CP      #1              ; Is it zero?
      0039E5 88               [ 4] 4063         ADC     A,B             ; Yes - Make it 1
      0039E6 32 18 42         [13] 4064         LD      (SEED+1),A      ; Re-save seed
      0039E9 21 1C 3A         [10] 4065         LD      HL,#RNDTAB-4    ; Addition table
      0039EC 87               [ 4] 4066         ADD     A,A             ; 4 bytes
      0039ED 87               [ 4] 4067         ADD     A,A             ; per entry
      0039EE 4F               [ 4] 4068         LD      C,A             ; BC = Offset into table
      0039EF 09               [11] 4069         ADD     HL,BC           ; Point to value
      0039F0 CD EA 33         [17] 4070         CALL    ADDPHL          ; Add value to FPREG
      0039F3 CD 8B 36         [17] 4071 RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
      0039F6 7B               [ 4] 4072         LD      A,E             ; Get LSB
      0039F7 59               [ 4] 4073         LD      E,C             ; LSB = MSB
      0039F8 EE 4F            [ 7] 4074         XOR     #0b01001111     ; Fiddle around
      0039FA 4F               [ 4] 4075         LD      C,A             ; New MSB
      0039FB 36 80            [10] 4076         LD      (HL),#0x80      ; Set exponent
      0039FD 2B               [ 6] 4077         DEC     HL              ; Point to MSB
      0039FE 46               [ 7] 4078         LD      B,(HL)          ; Get MSB
      0039FF 36 80            [10] 4079         LD      (HL),#0x80      ; Make value -0.5
      003A01 21 17 42         [10] 4080         LD      HL,#SEED        ; Random number seed
      003A04 34               [11] 4081         INC     (HL)            ; Count seed
      003A05 7E               [ 7] 4082         LD      A,(HL)          ; Get seed
      003A06 D6 AB            [ 7] 4083         SUB     #171            ; Do it modulo 171
      003A08 C2 0F 3A         [10] 4084         JP      NZ,RND2         ; Non-zero - Ok
      003A0B 77               [ 7] 4085         LD      (HL),A          ; Zero seed
      003A0C 0C               [ 4] 4086         INC     C               ; Fillde about
      003A0D 15               [ 4] 4087         DEC     D               ; with the
      003A0E 1C               [ 4] 4088         INC     E               ; number
      003A0F CD 4A 34         [17] 4089 RND2:   CALL    BNORM           ; Normalise number
      003A12 21 3A 42         [10] 4090         LD      HL,#LSTRND      ; Save random number
      003A15 C3 97 36         [10] 4091         JP      FPTHL           ; Move FPREG to last and return
                                   4092 
      003A18 77               [ 7] 4093 RESEED: LD      (HL),A          ; Re-seed random numbers
      003A19 2B               [ 6] 4094         DEC     HL
      003A1A 77               [ 7] 4095         LD      (HL),A
      003A1B 2B               [ 6] 4096         DEC     HL
      003A1C 77               [ 7] 4097         LD      (HL),A
      003A1D C3 F3 39         [10] 4098         JP      RND1            ; Return RND seed
                                   4099 
      003A20 68 B1 46 68           4100 RNDTAB: .BYTE   0x68,0xB1,0x46,0x68     ; Table used by RND
      003A24 99 E9 92 69           4101         .BYTE   0x99,0xE9,0x92,0x69
      003A28 10 D1 75 68           4102         .BYTE   0x10,0xD1,0x75,0x68
                                   4103 
      003A2C 21 76 3A         [10] 4104 COS:    LD      HL,#HALFPI      ; Point to PI/2
      003A2F CD EA 33         [17] 4105         CALL    ADDPHL          ; Add it to PPREG
      003A32 CD 70 36         [17] 4106 SIN:    CALL    STAKFP          ; Put angle on stack
      003A35 01 49 83         [10] 4107         LD      BC,#0x8349      ; BCDE = 2 PI
      003A38 11 DB 0F         [10] 4108         LD      DE,#0x0FDB
      003A3B CD 80 36         [17] 4109         CALL    FPBCDE          ; Move 2 PI to FPREG
      003A3E C1               [10] 4110         POP     BC              ; Restore angle
      003A3F D1               [10] 4111         POP     DE
      003A40 CD 95 35         [17] 4112         CALL    DVBCDE          ; Divide angle by 2 PI
      003A43 CD 70 36         [17] 4113         CALL    STAKFP          ; Put it on stack
      003A46 CD 12 37         [17] 4114         CALL    INT             ; Get INT of result
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 76.
Hexadecimal [24-Bits]



      003A49 C1               [10] 4115         POP     BC              ; Restore number
      003A4A D1               [10] 4116         POP     DE
      003A4B CD F6 33         [17] 4117         CALL    SUBCDE          ; Make it 0 <= value < 1
      003A4E 21 7A 3A         [10] 4118         LD      HL,#QUARTR      ; Point to 0.25
      003A51 CD F0 33         [17] 4119         CALL    SUBPHL          ; Subtract value from 0.25
      003A54 CD 3F 36         [17] 4120         CALL    TSTSGN          ; Test sign of value
      003A57 37               [ 4] 4121         SCF                     ; Flag positive
      003A58 F2 62 3A         [10] 4122         JP      P,SIN1          ; Positive - Ok
      003A5B CD E7 33         [17] 4123         CALL    ROUND           ; Add 0.5 to value
      003A5E CD 3F 36         [17] 4124         CALL    TSTSGN          ; Test sign of value
      003A61 B7               [ 4] 4125         OR      A               ; Flag negative
      003A62 F5               [11] 4126 SIN1:   PUSH    AF              ; Save sign
      003A63 F4 68 36         [17] 4127         CALL    P,INVSGN        ; Negate value if positive
      003A66 21 7A 3A         [10] 4128         LD      HL,#QUARTR      ; Point to 0.25
      003A69 CD EA 33         [17] 4129         CALL    ADDPHL          ; Add 0.25 to value
      003A6C F1               [10] 4130         POP     AF              ; Restore sign
      003A6D D4 68 36         [17] 4131         CALL    NC,INVSGN       ; Negative - Make positive
      003A70 21 7E 3A         [10] 4132         LD      HL,#SINTAB      ; Coefficient table
      003A73 C3 87 39         [10] 4133         JP      SUMSER          ; Evaluate sum of series
                                   4134 
      003A76 DB 0F 49 81           4135 HALFPI: .BYTE   0xDB,0x0F,0x49,0x81     ; 1.5708 (PI/2)
                                   4136 
      003A7A 00 00 00 7F           4137 QUARTR: .BYTE   0x00,0x00,0x00,0x7F     ; 0.25
                                   4138 
      003A7E 05                    4139 SINTAB: .BYTE   5                       ; Table used by SIN
      003A7F BA D7 1E 86           4140         .BYTE   0xBA,0xD7,0x1E,0x86     ; 39.711
      003A83 64 26 99 87           4141         .BYTE   0x64,0x26,0x99,0x87     ;-76.575
      003A87 58 34 23 87           4142         .BYTE   0x58,0x34,0x23,0x87     ; 81.602
      003A8B E0 5D A5 86           4143         .BYTE   0xE0,0x5D,0xA5,0x86     ;-41.342
      003A8F DA 0F 49 83           4144         .BYTE   0xDA,0x0F,0x49,0x83     ;  6.2832
                                   4145 
      003A93 CD 70 36         [17] 4146 TAN:    CALL    STAKFP          ; Put angle on stack
      003A96 CD 32 3A         [17] 4147         CALL    SIN             ; Get SIN of angle
      003A99 C1               [10] 4148         POP     BC              ; Restore angle
      003A9A E1               [10] 4149         POP     HL
      003A9B CD 70 36         [17] 4150         CALL    STAKFP          ; Save SIN of angle
      003A9E EB               [ 4] 4151         EX      DE,HL           ; BCDE = Angle
      003A9F CD 80 36         [17] 4152         CALL    FPBCDE          ; Angle to FPREG
      003AA2 CD 2C 3A         [17] 4153         CALL    COS             ; Get COS of angle
      003AA5 C3 93 35         [10] 4154         JP      DIV             ; TAN = SIN / COS
                                   4155 
      003AA8 CD 3F 36         [17] 4156 ATN:    CALL    TSTSGN          ; Test sign of value
      003AAB FC D3 38         [17] 4157         CALL    M,NEGAFT        ; Negate result after if -ve
      003AAE FC 68 36         [17] 4158         CALL    M,INVSGN        ; Negate value if -ve
      003AB1 3A E7 42         [13] 4159         LD      A,(FPEXP)       ; Get exponent
      003AB4 FE 81            [ 7] 4160         CP      #0x81           ; Number less than 1?
      003AB6 DA C5 3A         [10] 4161         JP      C,ATN1          ; Yes - Get arc tangnt
      003AB9 01 00 81         [10] 4162         LD      BC,#0x8100      ; BCDE = 1
      003ABC 51               [ 4] 4163         LD      D,C
      003ABD 59               [ 4] 4164         LD      E,C
      003ABE CD 95 35         [17] 4165         CALL    DVBCDE          ; Get reciprocal of number
      003AC1 21 F0 33         [10] 4166         LD      HL,#SUBPHL      ; Sub angle from PI/2
      003AC4 E5               [11] 4167         PUSH    HL              ; Save for angle > 1
      003AC5 21 CF 3A         [10] 4168 ATN1:   LD      HL,#ATNTAB      ; Coefficient table
      003AC8 CD 87 39         [17] 4169         CALL    SUMSER          ; Evaluate sum of series
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 77.
Hexadecimal [24-Bits]



      003ACB 21 76 3A         [10] 4170         LD      HL,#HALFPI      ; PI/2 - angle in case > 1
      003ACE C9               [10] 4171         RET                     ; Number > 1 - Sub from PI/2
                                   4172 
      003ACF 09                    4173 ATNTAB: .BYTE   9                       ; Table used by ATN
      003AD0 4A D7 3B 78           4174         .BYTE   0x4A,0xD7,0x3B,0x78     ; 1/17
      003AD4 02 6E 84 7B           4175         .BYTE   0x02,0x6E,0x84,0x7B     ;-1/15
      003AD8 FE C1 2F 7C           4176         .BYTE   0xFE,0xC1,0x2F,0x7C     ; 1/13
      003ADC 74 31 9A 7D           4177         .BYTE   0x74,0x31,0x9A,0x7D     ;-1/11
      003AE0 84 3D 5A 7D           4178         .BYTE   0x84,0x3D,0x5A,0x7D     ; 1/9
      003AE4 C8 7F 91 7E           4179         .BYTE   0xC8,0x7F,0x91,0x7E     ;-1/7
      003AE8 E4 BB 4C 7E           4180         .BYTE   0xE4,0xBB,0x4C,0x7E     ; 1/5
      003AEC 6C AA AA 7F           4181         .BYTE   0x6C,0xAA,0xAA,0x7F     ;-1/3
      003AF0 00 00 00 81           4182         .BYTE   0x00,0x00,0x00,0x81     ; 1/1
                                   4183 
                                   4184 
      003AF4 C9               [10] 4185 ARET:   RET                     ; A RETurn instruction
                                   4186 
      003AF5 D7               [11] 4187 GETINP: RST	    0x10        ;input a character
      003AF6 C9               [10] 4188         RET
                                   4189 
      003AF7                       4190 CLS: 
      003AF7 3E 0C            [ 7] 4191         LD      A,#CS           ; ASCII Clear screen
      003AF9 C3 31 3C         [10] 4192         JP      MONOUT          ; Output character
                                   4193 
      003AFC CD BE 33         [17] 4194 WIDTH:  CALL    GETINT          ; Get integer 0-255
      003AFF 7B               [ 4] 4195         LD      A,E             ; Width to A
      003B00 32 42 42         [13] 4196         LD      (LWIDTH),A      ; Set width
      003B03 C9               [10] 4197         RET
                                   4198 
      003B04 CD 5D 2C         [17] 4199 LINES:  CALL    GETNUM          ; Get a number
      003B07 CD A2 28         [17] 4200         CALL    DEINT           ; Get integer -32768 to 32767
      003B0A ED 53 46 42      [20] 4201         LD      (LINESC),DE     ; Set lines counter
      003B0E ED 53 48 42      [20] 4202         LD      (LINESN),DE     ; Set lines number
      003B12 C9               [10] 4203         RET
                                   4204 
      003B13 CD A2 28         [17] 4205 DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
      003B16 D5               [11] 4206         PUSH    DE              ; Save number
      003B17 E1               [10] 4207         POP     HL              ; Number to HL
      003B18 46               [ 7] 4208         LD      B,(HL)          ; Get LSB of contents
      003B19 23               [ 6] 4209         INC     HL
      003B1A 7E               [ 7] 4210         LD      A,(HL)          ; Get MSB of contents
      003B1B C3 18 30         [10] 4211         JP      ABPASS          ; Return integer AB
                                   4212 
      003B1E CD 5D 2C         [17] 4213 DOKE:   CALL    GETNUM          ; Get a number
      003B21 CD A2 28         [17] 4214         CALL    DEINT           ; Get integer -32768 to 32767
      003B24 D5               [11] 4215         PUSH    DE              ; Save address
      003B25 CD 66 26         [17] 4216         CALL    CHKSYN          ; Make sure ',' follows
      003B28 2C                    4217         .BYTE      ','
      003B29 CD 5D 2C         [17] 4218         CALL    GETNUM          ; Get a number
      003B2C CD A2 28         [17] 4219         CALL    DEINT           ; Get integer -32768 to 32767
      003B2F E3               [19] 4220         EX      (SP),HL         ; Save value,get address
      003B30 73               [ 7] 4221         LD      (HL),E          ; Save LSB of value
      003B31 23               [ 6] 4222         INC     HL
      003B32 72               [ 7] 4223         LD      (HL),D          ; Save MSB of value
      003B33 E1               [10] 4224         POP     HL              ; Restore code string address
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 78.
Hexadecimal [24-Bits]



      003B34 C9               [10] 4225         RET
                                   4226 
                                   4227 
                                   4228 ; HEX$(nn) Convert 16 bit number to Hexadecimal string
                                   4229 
      003B35 CD 60 2C         [17] 4230 HEX: 	CALL	TSTNUM          ; Verify it's a number
      003B38 CD A2 28         [17] 4231         CALL	DEINT           ; Get integer -32768 to 32767
      003B3B C5               [11] 4232         PUSH	BC              ; Save contents of BC
      003B3C 21 E9 42         [10] 4233         LD	HL,#PBUFF
      003B3F 7A               [ 4] 4234         LD	    A,D             ; Get high order into A
      003B40 FE 00            [ 7] 4235         CP      #0
      003B42 28 0C            [12] 4236 	JR      Z,HEX2          ; Skip output if both high digits are zero
      003B44 CD 6D 3B         [17] 4237         CALL    BYT2ASC         ; Convert D to ASCII
      003B47 78               [ 4] 4238 	LD      A,B
      003B48 FE 30            [ 7] 4239 	CP      #'0'
      003B4A 28 02            [12] 4240 	JR      Z,HEX1          ; Don't store high digit if zero
      003B4C 70               [ 7] 4241         LD	    (HL),B          ; Store it to PBUFF
      003B4D 23               [ 6] 4242         INC	    HL              ; Next location
      003B4E 71               [ 7] 4243 HEX1:   LD	    (HL),C          ; Store C to PBUFF+1
      003B4F 23               [ 6] 4244         INC     HL              ; Next location
      003B50 7B               [ 4] 4245 HEX2:   LD	    A,E             ; Get lower byte
      003B51 CD 6D 3B         [17] 4246         CALL    BYT2ASC         ; Convert E to ASCII
      003B54 7A               [ 4] 4247 		LD      A,D
      003B55 FE 00            [ 7] 4248         CP      #0
      003B57 20 05            [12] 4249 	JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
      003B59 78               [ 4] 4250 	LD      A,B
      003B5A FE 30            [ 7] 4251 	CP      #'0'             ; If high digit of lower byte is zero then don't print
      003B5C 28 02            [12] 4252 	JR      Z,HEX4
      003B5E 70               [ 7] 4253 HEX3:   LD      (HL),B          ; to PBUFF+2
      003B5F 23               [ 6] 4254         INC     HL              ; Next location
      003B60 71               [ 7] 4255 HEX4:   LD      (HL),C          ; to PBUFF+3
      003B61 23               [ 6] 4256         INC     HL              ; PBUFF+4 to zero
      003B62 AF               [ 4] 4257         XOR     A               ; Terminating character
      003B63 77               [ 7] 4258         LD      (HL),A          ; Store zero to terminate
      003B64 23               [ 6] 4259         INC     HL              ; Make sure PBUFF is terminated
      003B65 77               [ 7] 4260         LD      (HL),A          ; Store the double zero there
      003B66 C1               [10] 4261         POP     BC              ; Get BC back
      003B67 21 E9 42         [10] 4262         LD      HL,#PBUFF       ; Reset to start of PBUFF
      003B6A C3 C6 30         [10] 4263         JP      STR1            ; Convert the PBUFF to a string and return it
                                   4264 
      003B6D 47               [ 4] 4265 BYT2ASC:LD      B,A             ; Save original value
      003B6E E6 0F            [ 7] 4266         AND     #0x0F           ; Strip off upper nybble
      003B70 FE 0A            [ 7] 4267         CP      #0x0A           ; 0-9?
      003B72 38 02            [12] 4268         JR      C,#ADD30        ; If A-F, add 7 more
      003B74 C6 07            [ 7] 4269         ADD     A,#0x07         ; Bring value up to ASCII A-F
      003B76 C6 30            [ 7] 4270 ADD30:	ADD     A,#0x30         ; And make ASCII
      003B78 4F               [ 4] 4271         LD      C,A             ; Save converted char to C
      003B79 78               [ 4] 4272         LD      A,B             ; Retrieve original value
      003B7A 0F               [ 4] 4273         RRCA                    ; and Rotate it right
      003B7B 0F               [ 4] 4274         RRCA
      003B7C 0F               [ 4] 4275         RRCA
      003B7D 0F               [ 4] 4276         RRCA
      003B7E E6 0F            [ 7] 4277         AND     #0x0F           ; Mask off upper nybble
      003B80 FE 0A            [ 7] 4278         CP      #0x0A           ; 0-9? < A hex?
      003B82 38 02            [12] 4279         JR      C,ADD301        ; Skip Add 7
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 79.
Hexadecimal [24-Bits]



      003B84 C6 07            [ 7] 4280         ADD     A,#0x07         ; Bring it up to ASCII A-F
      003B86 C6 30            [ 7] 4281 ADD301:	ADD     A,#0x30         ; And make it full ASCII
      003B88 47               [ 4] 4282         LD      B,A             ; Store high order byte
      003B89 C9               [10] 4283         RET	
                                   4284 
                                   4285 ; Convert "&Hnnnn" to FPREG
                                   4286 ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
                                   4287 ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
      003B8A EB               [ 4] 4288 HEXTFP: EX      DE,HL           ; Move code string pointer to DE
      003B8B 21 00 00         [10] 4289         LD      HL,#0x0000      ; Zero out the value
      003B8E CD A3 3B         [17] 4290         CALL    GETHEX          ; Check the number for valid hex
      003B91 DA C3 3B         [10] 4291         JP      C,HXERR         ; First value wasn't hex, HX error
      003B94 18 05            [12] 4292         JR      HEXLP1          ; Convert first character
      003B96 CD A3 3B         [17] 4293 HEXLP:  CALL    GETHEX          ; Get second and addtional characters
      003B99 38 1F            [12] 4294         JR      C,HEXIT         ; Exit if not a hex character
      003B9B 29               [11] 4295 HEXLP1: ADD     HL,HL           ; Rotate 4 bits to the left
      003B9C 29               [11] 4296         ADD     HL,HL
      003B9D 29               [11] 4297         ADD     HL,HL
      003B9E 29               [11] 4298         ADD     HL,HL
      003B9F B5               [ 4] 4299         OR      L               ; Add in D0-D3 into L
      003BA0 6F               [ 4] 4300         LD      L,A             ; Save new value
      003BA1 18 F3            [12] 4301         JR      HEXLP           ; And continue until all hex characters are in
                                   4302 
      003BA3 13               [ 6] 4303 GETHEX: INC     DE              ; Next location
      003BA4 1A               [ 7] 4304         LD      A,(DE)          ; Load character at pointer
      003BA5 FE 20            [ 7] 4305         CP      #' '
      003BA7 CA A3 3B         [10] 4306         JP      Z,GETHEX        ; Skip spaces
      003BAA D6 30            [ 7] 4307         SUB     #0x30           ; Get absolute value
      003BAC D8               [11] 4308         RET     C               ; < "0", error
      003BAD FE 0A            [ 7] 4309         CP      #0x0A
      003BAF 38 05            [12] 4310         JR      C,NOSUB7        ; Is already in the range 0-9
      003BB1 D6 07            [ 7] 4311         SUB     #0x07           ; Reduce to A-F
      003BB3 FE 0A            [ 7] 4312         CP      #0x0A           ; Value should be $0A-$0F at this point
      003BB5 D8               [11] 4313         RET     C               ; CY set if was :            ; < = > ? @
      003BB6 FE 10            [ 7] 4314 NOSUB7: CP      #0x10           ; > Greater than "F"?
      003BB8 3F               [ 4] 4315         CCF
      003BB9 C9               [10] 4316         RET                     ; CY set if it wasn't valid hex
                                   4317     
      003BBA EB               [ 4] 4318 HEXIT:  EX      DE,HL           ; Value into DE, Code string into HL
      003BBB 7A               [ 4] 4319         LD      A,D             ; Load DE into AC
      003BBC 4B               [ 4] 4320         LD      C,E             ; For prep to 
      003BBD E5               [11] 4321         PUSH    HL
      003BBE CD 17 30         [17] 4322         CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
      003BC1 E1               [10] 4323         POP     HL
      003BC2 C9               [10] 4324         RET
                                   4325 
      003BC3 1E 26            [ 7] 4326 HXERR:  LD      E,#HX           ; ?HEX Error
      003BC5 C3 AC 23         [10] 4327         JP      ERROR
                                   4328 
                                   4329 ; BIN$(NN) Convert integer to a 1-16 char binary string
      003BC8 CD 60 2C         [17] 4330 BIN:    CALL    TSTNUM          ; Verify it's a number
      003BCB CD A2 28         [17] 4331         CALL    DEINT           ; Get integer -32768 to 32767
      003BCE C5               [11] 4332 BIN2:   PUSH    BC              ; Save contents of BC
      003BCF 21 E9 42         [10] 4333         LD      HL,#PBUFF
      003BD2 06 11            [ 7] 4334         LD      B,#17           ; One higher than max char count
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 80.
Hexadecimal [24-Bits]



      003BD4                       4335 ZEROSUP:                        ; Suppress leading zeros
      003BD4 05               [ 4] 4336         DEC     B               ; Max 16 chars
      003BD5 78               [ 4] 4337         LD      A,B
      003BD6 FE 01            [ 7] 4338         CP      #0x01
      003BD8 28 08            [12] 4339         JR      Z,BITOUT        ; Always output at least one character
      003BDA CB 13            [ 8] 4340         RL      E
      003BDC CB 12            [ 8] 4341         RL      D
      003BDE 30 F4            [12] 4342         JR      NC,ZEROSUP
      003BE0 18 04            [12] 4343         JR      BITOUT2
      003BE2                       4344 BITOUT:      
      003BE2 CB 13            [ 8] 4345         RL      E
      003BE4 CB 12            [ 8] 4346         RL      D               ; Top bit now in carry
      003BE6                       4347 BITOUT2:
      003BE6 3E 30            [ 7] 4348         LD      A,#'0'          ; Char for '0'
      003BE8 CE 00            [ 7] 4349         ADC     A,#0            ; If carry set then '0' --> '1'
      003BEA 77               [ 7] 4350         LD      (HL),A
      003BEB 23               [ 6] 4351         INC     HL
      003BEC 05               [ 4] 4352         DEC     B
      003BED 20 F3            [12] 4353         JR      NZ,BITOUT
      003BEF AF               [ 4] 4354         XOR     A               ; Terminating character
      003BF0 77               [ 7] 4355         LD      (HL),A          ; Store zero to terminate
      003BF1 23               [ 6] 4356         INC     HL              ; Make sure PBUFF is terminated
      003BF2 77               [ 7] 4357         LD      (HL),A          ; Store the double zero there
      003BF3 C1               [10] 4358         POP     BC
      003BF4 21 E9 42         [10] 4359         LD      HL,#PBUFF
      003BF7 C3 C6 30         [10] 4360         JP      STR1
                                   4361 
                                   4362 ; Convert "&Bnnnn" to FPREG
                                   4363 ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
      003BFA EB               [ 4] 4364 BINTFP: EX      DE,HL           ; Move code string pointer to DE
      003BFB 21 00 00         [10] 4365         LD      HL,#0x0000      ; Zero out the value
      003BFE CD 17 3C         [17] 4366         CALL    CHKBIN          ; Check the number for valid bin
      003C01 DA 25 3C         [10] 4367         JP      C,BINERR        ; First value wasn't bin, HX error
      003C04 D6 30            [ 7] 4368 BINIT:  SUB     #'0'
      003C06 29               [11] 4369         ADD     HL,HL           ; Rotate HL left
      003C07 B5               [ 4] 4370         OR      L
      003C08 6F               [ 4] 4371         LD      L,A
      003C09 CD 17 3C         [17] 4372         CALL    CHKBIN          ; Get second and addtional characters
      003C0C 30 F6            [12] 4373         JR      NC,BINIT        ; Process if a bin character
      003C0E EB               [ 4] 4374         EX      DE,HL           ; Value into DE, Code string into HL
      003C0F 7A               [ 4] 4375         LD      A,D             ; Load DE into AC
      003C10 4B               [ 4] 4376         LD      C,E             ; For prep to 
      003C11 E5               [11] 4377         PUSH    HL
      003C12 CD 17 30         [17] 4378         CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
      003C15 E1               [10] 4379         POP     HL
      003C16 C9               [10] 4380         RET
                                   4381 
                                   4382 ; Char is in A, NC if char is 0 or 1
      003C17 13               [ 6] 4383 CHKBIN: INC     DE
      003C18 1A               [ 7] 4384         LD      A,(DE)
      003C19 FE 20            [ 7] 4385         CP      #' '
      003C1B CA 17 3C         [10] 4386         JP      Z,CHKBIN        ; Skip spaces
      003C1E FE 30            [ 7] 4387         CP      #'0'            ; Set C if < '0'
      003C20 D8               [11] 4388         RET     C
      003C21 FE 32            [ 7] 4389         CP      #'2'
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 81.
Hexadecimal [24-Bits]



      003C23 3F               [ 4] 4390         CCF                     ; Set C if > '1'
      003C24 C9               [10] 4391         RET
                                   4392 
      003C25 1E 28            [ 7] 4393 BINERR: LD      E,#BN           ; ?BIN Error
      003C27 C3 AC 23         [10] 4394         JP      ERROR
                                   4395 
                                   4396 
      003C2A                       4397 JJUMP1: 
      003C2A DD 21 FF FF      [14] 4398         LD      IX,#-1          ; Flag cold start
      003C2E C3 11 20         [10] 4399         JP      CSTART          ; Go and initialise
                                   4400 
      003C31 F5               [11] 4401 MONOUT: PUSH    AF
      003C32 CF               [11] 4402         RST     0x0008           ; output a char
      003C33 F1               [10] 4403         POP     AF
      003C34 C9               [10] 4404         RET
                                   4405 
      003C35                       4406 MONITR: 
      003C35 C3 00 00         [10] 4407         JP      0x0000           ; Restart (Normally Monitor Start)
                                   4408 
                                   4409 
      003C38 3E 00            [ 7] 4410 INITST: LD      A,#0            ; Clear break flag
      003C3A 32 4D 42         [13] 4411         LD      (BRKFLG),A
      003C3D C3 18 20         [10] 4412         JP      INIT
                                   4413 
      003C40 ED 45            [14] 4414 ARETN:  RETN                    ; Return from NMI
                                   4415 
                                   4416 
      003C42 F5               [11] 4417 TSTBIT: PUSH    AF              ; Save bit mask
      003C43 A0               [ 4] 4418         AND     B               ; Get common bits
      003C44 C1               [10] 4419         POP     BC              ; Restore bit mask
      003C45 B8               [ 4] 4420         CP      B               ; Same bit set?
      003C46 3E 00            [ 7] 4421         LD      A,#0            ; Return 0 in A
      003C48 C9               [10] 4422         RET
                                   4423 
      003C49 CD 71 26         [17] 4424 OUTNCR: CALL    OUTC            ; Output character in A
      003C4C C3 98 2A         [10] 4425         JP      PRNTCRLF        ; Output CRLF
                                   4426 
                                   4427 	.area	_DATA
                                   4428 ;.end
                                   4429 
